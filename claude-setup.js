#!/usr/bin/env node
/**
 * Claude Code Integration Setup
 *
 * Automatically generates .claude/CLAUDE.md with query-first instructions
 * for all users of llm-context tools.
 */

import { writeFileSync, mkdirSync, existsSync, readFileSync } from 'fs';
import { join } from 'path';

/**
 * Generate .claude/CLAUDE.md with project instructions
 * @param {object} options - Generation options
 * @param {string} options.projectName - Name of the project
 * @param {boolean} options.force - Force overwrite if exists
 */
export function setupClaudeIntegration(options = {}) {
  const { projectName = 'this project', force = false } = options;

  const claudeDir = join(process.cwd(), '.claude');
  const claudeMdPath = join(claudeDir, 'CLAUDE.md');

  // Check if already exists
  if (existsSync(claudeMdPath) && !force) {
    console.log('   ‚ÑπÔ∏è  .claude/CLAUDE.md already exists (use --force to overwrite)');
    return false;
  }

  // Create .claude directory
  mkdirSync(claudeDir, { recursive: true });

  // Generate CLAUDE.md content
  const claudeMd = generateClaudeMd(projectName);

  // Write file
  writeFileSync(claudeMdPath, claudeMd);

  console.log('   ‚úì Generated .claude/CLAUDE.md (Claude Code integration)');
  return true;
}

/**
 * Generate CLAUDE.md content
 * @param {string} projectName - Project name
 * @returns {string} CLAUDE.md content
 */
function generateClaudeMd(projectName) {
  return `# ${projectName} - LLM Context Instructions

## üö® MANDATORY: Query-First Exploration

**This codebase has llm-context analysis available.**

### BEFORE using Grep/Bash/Read for code exploration:

1. **Check if \`.llm-context/\` exists** (it does in this project)
2. **Use queries FIRST**:
   \`\`\`bash
   llm-context query find-function <name>     # Find & describe function
   llm-context query calls-to <name>          # Who calls this?
   llm-context query trace <name>             # Full call tree
   llm-context side-effects                   # Functions with I/O
   llm-context entry-points                   # Entry points
   \`\`\`
3. **Only use grep/read** if queries insufficient

### Why This Matters

**Grep/Bash limitations:**
- ‚ùå Shows only text matches
- ‚ùå Misses call relationships
- ‚ùå Doesn't show side effects
- ‚ùå No architectural context

**Query advantages:**
- ‚úÖ Shows semantic relationships
- ‚úÖ Includes call graphs
- ‚úÖ Detects side effects (file_io, network, database)
- ‚úÖ Identifies entry points
- ‚úÖ 80-95% fewer tokens

### Examples

**‚ùå Anti-pattern (what NOT to do):**
\`\`\`bash
# DON'T: Use grep when queries exist
grep -r "someFunction" --include="*.js"
\`\`\`

**‚úÖ Correct pattern:**
\`\`\`bash
# DO: Use queries first
llm-context query find-function someFunction
# Shows: signature, calls, side effects, patterns, line number

# Then if needed:
llm-context query calls-to someFunction
# Shows: which functions call it

# Only read source for implementation details:
cat file.js | sed -n '42,100p'
\`\`\`

## Development Workflow

### Understanding Codebase (First Time)
\`\`\`bash
# 1. Read progressive disclosure
cat .llm-context/summaries/L0-system.md  # System overview
cat .llm-context/summaries/L1-domains.json  # Domain boundaries
llm-context stats  # Statistics

# 2. Explore specific areas
llm-context entry-points  # Where does execution start?
llm-context side-effects  # What does I/O?

# 3. Deep dive with queries
llm-context query trace <entry-point>  # Understand flow
\`\`\`

### After Code Changes
\`\`\`bash
# Incremental analysis (99% faster)
llm-context analyze

# Check what changed
llm-context check-changes
\`\`\`

### Debugging
\`\`\`bash
# Find function and understand context
llm-context query find-function <buggy-func>
llm-context query calls-to <buggy-func>  # Who calls it?
llm-context query trace <buggy-func>     # Full call path

# Check for side effects
llm-context side-effects | grep <buggy-func>
\`\`\`

## Common Tasks

| Task | Command |
|------|---------|
| Analyze codebase | \`llm-context analyze\` |
| Find function | \`llm-context query find-function <name>\` |
| Find callers | \`llm-context query calls-to <name>\` |
| Trace calls | \`llm-context query trace <name>\` |
| Side effects | \`llm-context side-effects\` |
| Statistics | \`llm-context stats\` |
| Entry points | \`llm-context entry-points\` |

## Success Indicators

You're using this tool correctly when:
1. ‚úÖ You read L0 summary before exploring code
2. ‚úÖ You use queries instead of grep for function lookups
3. ‚úÖ You mention side effects when discussing functions
4. ‚úÖ You run incremental analysis after changes
5. ‚úÖ Your token usage is 50-95% lower than raw file reading

---

*This file was auto-generated by llm-context tools.*
*Learn more: https://github.com/devame/llm-context-tools*
`;
}

// CLI execution
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);
  const force = args.includes('--force');

  // Try to detect project name from package.json
  let projectName = 'Project';
  try {
    const packageJsonPath = join(process.cwd(), 'package.json');
    if (existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));
      projectName = packageJson.name || 'Project';
    }
  } catch (e) {
    // Ignore errors, use default
  }

  console.log('üîß Setting up Claude Code integration...\n');
  setupClaudeIntegration({ projectName, force });
  console.log('\n‚úÖ Setup complete!');
  console.log('   Claude Code will now see query instructions in .claude/CLAUDE.md');
}
