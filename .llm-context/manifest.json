{
  "version": "2.0.0",
  "granularity": "function",
  "generated": "2026-02-08T13:47:27.550Z",
  "files": {
    ".claude/settings.local.json": {
      "hash": "8788b4323edd5b781a648bdd56798a50",
      "size": 1507,
      "lastModified": "2026-01-23T07:14:26.156Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {}
    },
    "bin/llm-context.js": {
      "hash": "05f2644e94d067db942cb8ddf4258f89",
      "size": 5497,
      "lastModified": "2026-02-08T13:30:40.510Z",
      "functions": [
        "runScript"
      ],
      "analysisTime": null,
      "functionHashes": {
        "runScript": {
          "hash": "e827c6462e8b185197a2c3a3d069b591",
          "line": 24,
          "endLine": 41,
          "size": 452,
          "async": false,
          "language": "javascript",
          "source": "function runScript(scriptPath, extraArgs = []) {\r\n  const fullPath = join(rootDir, scriptPath);\r\n\r\n  if (!existsSync(fullPath)) {\r\n    console.error(`Error: Script not found: ${scriptPath}`);\r\n    process.exit(1);\r\n  }\r\n\r\n  try {\r\n    const allArgs = [...extraArgs, ...commandArgs].join(' ');\r\n    execSync(`node \"${fullPath}\" ${allArgs}`, {\r\n      stdio: 'inherit',\r\n      cwd: process.cwd()\r\n    });\r\n  } catch (error) {\r\n    process.exit(1);\r\n  }\r\n}"
        }
      }
    },
    "data/effect-patterns.json": {
      "hash": "4f2782b1714746141763dc16a9f42e2d",
      "size": 9621,
      "lastModified": "2026-01-11T10:45:22.654Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {}
    },
    "data/semantic-patterns.json": {
      "hash": "5ce0c49ec75160f3cdc919437a35dff2",
      "size": 3016,
      "lastModified": "2026-02-08T13:05:53.793Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {}
    },
    "llm-context.config.json": {
      "hash": "a1810c5fdba5e67eefe6a2fff0a1248e",
      "size": 1163,
      "lastModified": "2026-01-11T10:45:22.710Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {}
    },
    "package-lock.json": {
      "hash": "36d19a3723955983689f82dc6be76b83",
      "size": 74013,
      "lastModified": "2026-02-08T13:05:55.873Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {}
    },
    "package.json": {
      "hash": "b625747ac39491028293139b58d04dbc",
      "size": 2356,
      "lastModified": "2026-02-08T13:31:48.722Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {}
    },
    "src/cli.js": {
      "hash": "c887d49dc3adc8c967dfe9cd2b4f7cd1",
      "size": 5647,
      "lastModified": "2026-02-08T13:12:18.689Z",
      "functions": [
        "main",
        "runQuery",
        "runGrep",
        "showVersion",
        "showHelp"
      ],
      "analysisTime": null,
      "functionHashes": {
        "main": {
          "hash": "d35d53b94b6462722dd093c7aeafb2ca",
          "line": 18,
          "endLine": 192,
          "size": 4967,
          "async": true,
          "language": "javascript",
          "source": "async function main() {\n\n// Commands that delegate to existing tools\nconst commands = {\n  'analyze': 'src/index.js',\n  'analyze:full': async () => {\n    // Delete manifest and run analyze\n    const manifestPath = '.llm-context/manifest.json';\n    if (existsSync(manifestPath)) {\n      unlinkSync(manifestPath);\n    }\n    return 'src/index.js';\n  },\n  'check-changes': 'src/core/change-detector.js',\n  'query': 'src/utils/query.js',\n  'stats': () => runQuery('stats'),\n  'entry-points': () => runQuery('entry-points'),\n  'side-effects': () => runQuery('side-effects'),\n  'grep': () => runGrep(args),\n  'search': () => runGrep(args),\n  // 'find-symbol': () => runSymbolSearch(args),\n  // 'show-context': () => showContext(args),\n  'help': () => showHelp(),\n  'version': () => showVersion()\n};\n\n// Show help if no command or help requested\nif (!command || command === 'help' || command === '--help' || command === '-h') {\n  showHelp();\n  process.exit(0);\n}\n\n// Execute command\nif (commands[command]) {\n  const handler = commands[command];\n\n  if (typeof handler === 'function') {\n    await handler();\n  } else {\n    // Delegate to existing script\n    const script = handler;\n    const child = spawn('node', [script, ...args], {\n      stdio: 'inherit',\n      cwd: process.cwd()\n    });\n\n    child.on('exit', code => process.exit(code));\n  }\n} else {\n  console.error(`❌ Unknown command: ${command}`);\n  console.error(`   Run \"llm-context help\" for usage`);\n  process.exit(1);\n}\n\n// Helper functions\n\nasync function runQuery(queryType) {\n  const { default: queryModule } = await import('./utils/query.js');\n  // Query module will handle its own execution\n}\n\nasync function runGrep(args) {\n  const { grep } = await import('./utils/grep.js');\n  await grep(args);\n}\n\n  // async function runSymbolSearch(args) {\n  //   const { searchSymbol } = await import('./symbol-search.js');\n  //   await searchSymbol(args);\n  // }\n\n  // async function showContext(args) {\n  //   const { showContext: show } = await import('./context-extractor.js');\n  //   await show(args);\n  // }\n\nfunction showVersion() {\n  const pkg = JSON.parse(readFileSync('./package.json', 'utf-8'));\n  console.log(`llm-context v${pkg.version}`);\n}\n\nfunction showHelp() {\n  console.log(`\n╔═══════════════════════════════════════════════════════════════╗\n║                   LLM Context Tools CLI                        ║\n║   Generate LLM-optimized code context with incremental updates ║\n╚═══════════════════════════════════════════════════════════════╝\n\nUSAGE\n  llm-context <command> [options]\n\nCOMMANDS\n\n  Analysis:\n    analyze              Run analysis (auto-detects full vs incremental)\n    analyze:full         Force full re-analysis\n    check-changes        Preview what files changed\n\n  Queries:\n    query <cmd> [args]   Query the generated graph\n    stats                Show codebase statistics\n    entry-points         Find entry point functions\n    side-effects         Find functions with side effects\n\n  Search:\n    grep <pattern>       Search code contents (ripgrep-style)\n    search <pattern>     Alias for grep\n    find-symbol <name>   Find symbol definitions/usage\n    show-context <ref>   Show code context around reference\n\n  Setup:\n    init                 Initialize LLM context tools in current project\n    version              Show version\n    help                 Show this help\n\nGREP/SEARCH EXAMPLES\n\n  # Search for pattern in all files\n  llm-context grep \"qualified name\"\n\n  # Search with context lines\n  llm-context grep \"parsePrimary\" -C 5\n\n  # Search in specific files\n  llm-context grep \"TokenType\" --files \"parser.js\"\n  llm-context grep \"SLASH\" --files \"*.js\"\n\n  # Case-insensitive search\n  llm-context grep \"error\" -i\n\n  # Search with line numbers\n  llm-context grep \"function\" -n\n\nSYMBOL SEARCH EXAMPLES\n\n  # Find all uses of a symbol\n  llm-context find-symbol \"TokenType.SLASH\"\n  llm-context find-symbol \"QualifiedName\"\n\nCONTEXT EXTRACTION EXAMPLES\n\n  # Show context around a function\n  llm-context show-context \"parser.js:parsePrimary\" --lines 20\n\n  # Extract specific line range\n  llm-context show-context \"parser.js:450-600\"\n\nQUERY COMMANDS\n\n  node query.js stats                    # Statistics\n  node query.js find-function <name>     # Find function\n  node query.js calls-to <name>          # Who calls this?\n  node query.js called-by <name>         # What does it call?\n  node query.js trace <name>             # Call tree\n  node query.js entry-points             # Entry points\n  node query.js side-effects             # Side effects\n\nGENERATED FILES\n\n  .llm-context/\n  ├── graph.jsonl           # Function call graph\n  ├── manifest.json         # Change tracking\n  └── summaries/\n      ├── L0-system.md      # System overview\n      ├── L1-domains.json   # Domain summaries\n      └── L2-modules.json   # Module summaries\n\nDOCUMENTATION\n\n  GitHub: https://github.com/devame/llm-context-tools\n  Issues: https://github.com/devame/llm-context-tools/issues\n`);\n}\n\n} // end main()"
        },
        "runQuery": {
          "hash": "72e870c6f3e23cf449b85977bbe0c6a7",
          "line": 74,
          "endLine": 77,
          "size": 155,
          "async": true,
          "language": "javascript",
          "source": "async function runQuery(queryType) {\n  const { default: queryModule } = await import('./utils/query.js');\n  // Query module will handle its own execution\n}"
        },
        "runGrep": {
          "hash": "322520a8ede462b49edc984680e61cba",
          "line": 79,
          "endLine": 82,
          "size": 104,
          "async": true,
          "language": "javascript",
          "source": "async function runGrep(args) {\n  const { grep } = await import('./utils/grep.js');\n  await grep(args);\n}"
        },
        "showVersion": {
          "hash": "134128c05d084ced74d6a0db2987fcfb",
          "line": 94,
          "endLine": 97,
          "size": 139,
          "async": false,
          "language": "javascript",
          "source": "function showVersion() {\n  const pkg = JSON.parse(readFileSync('./package.json', 'utf-8'));\n  console.log(`llm-context v${pkg.version}`);\n}"
        },
        "showHelp": {
          "hash": "3c7c71b54cba70cce5fabd8c2ba635dd",
          "line": 99,
          "endLine": 190,
          "size": 2749,
          "async": false,
          "language": "javascript",
          "source": "function showHelp() {\n  console.log(`\n╔═══════════════════════════════════════════════════════════════╗\n║                   LLM Context Tools CLI                        ║\n║   Generate LLM-optimized code context with incremental updates ║\n╚═══════════════════════════════════════════════════════════════╝\n\nUSAGE\n  llm-context <command> [options]\n\nCOMMANDS\n\n  Analysis:\n    analyze              Run analysis (auto-detects full vs incremental)\n    analyze:full         Force full re-analysis\n    check-changes        Preview what files changed\n\n  Queries:\n    query <cmd> [args]   Query the generated graph\n    stats                Show codebase statistics\n    entry-points         Find entry point functions\n    side-effects         Find functions with side effects\n\n  Search:\n    grep <pattern>       Search code contents (ripgrep-style)\n    search <pattern>     Alias for grep\n    find-symbol <name>   Find symbol definitions/usage\n    show-context <ref>   Show code context around reference\n\n  Setup:\n    init                 Initialize LLM context tools in current project\n    version              Show version\n    help                 Show this help\n\nGREP/SEARCH EXAMPLES\n\n  # Search for pattern in all files\n  llm-context grep \"qualified name\"\n\n  # Search with context lines\n  llm-context grep \"parsePrimary\" -C 5\n\n  # Search in specific files\n  llm-context grep \"TokenType\" --files \"parser.js\"\n  llm-context grep \"SLASH\" --files \"*.js\"\n\n  # Case-insensitive search\n  llm-context grep \"error\" -i\n\n  # Search with line numbers\n  llm-context grep \"function\" -n\n\nSYMBOL SEARCH EXAMPLES\n\n  # Find all uses of a symbol\n  llm-context find-symbol \"TokenType.SLASH\"\n  llm-context find-symbol \"QualifiedName\"\n\nCONTEXT EXTRACTION EXAMPLES\n\n  # Show context around a function\n  llm-context show-context \"parser.js:parsePrimary\" --lines 20\n\n  # Extract specific line range\n  llm-context show-context \"parser.js:450-600\"\n\nQUERY COMMANDS\n\n  node query.js stats                    # Statistics\n  node query.js find-function <name>     # Find function\n  node query.js calls-to <name>          # Who calls this?\n  node query.js called-by <name>         # What does it call?\n  node query.js trace <name>             # Call tree\n  node query.js entry-points             # Entry points\n  node query.js side-effects             # Side effects\n\nGENERATED FILES\n\n  .llm-context/\n  ├── graph.jsonl           # Function call graph\n  ├── manifest.json         # Change tracking\n  └── summaries/\n      ├── L0-system.md      # System overview\n      ├── L1-domains.json   # Domain summaries\n      └── L2-modules.json   # Module summaries\n\nDOCUMENTATION\n\n  GitHub: https://github.com/devame/llm-context-tools\n  Issues: https://github.com/devame/llm-context-tools/issues\n`);\n}"
        }
      }
    },
    "src/core/change-detector.js": {
      "hash": "76b80db1cb85e011c5c82ed2876322e4",
      "size": 6069,
      "lastModified": "2026-02-08T13:46:26.172Z",
      "functions": [
        "hashFile",
        "findJsFiles",
        "walk",
        "loadManifest",
        "detectChanges",
        "printSummary",
        "main"
      ],
      "analysisTime": null,
      "functionHashes": {
        "hashFile": {
          "hash": "71c5b221aa6e627ab1a7e7f345955f5b",
          "line": 23,
          "endLine": 27,
          "size": 156,
          "async": false,
          "language": "javascript",
          "source": "function hashFile(filePath) {\r\n  const content = readFileSync(filePath);\r\n  const hash = createHash('md5').update(content).digest('hex');\r\n  return hash;\r\n}"
        },
        "findJsFiles": {
          "hash": "a1bec8befbb100efee139449a9801c3d",
          "line": 35,
          "endLine": 60,
          "size": 742,
          "async": false,
          "language": "javascript",
          "source": "function findJsFiles(dir = '.', ignore = ['node_modules', '.git', '.llm-context']) {\r\n  const files = [];\r\n\r\n  function walk(currentDir) {\r\n    const entries = readdirSync(currentDir, { withFileTypes: true });\r\n\r\n    for (const entry of entries) {\r\n      const fullPath = join(currentDir, entry.name);\r\n      // Determine relative path from the *target directory* not CWD\r\n      const relativePath = relative(dir, fullPath);\r\n\r\n      if (ignore.some(pattern => relativePath.includes(pattern))) {\r\n        continue;\r\n      }\r\n\r\n      if (entry.isDirectory()) {\r\n        walk(fullPath);\r\n      } else if (entry.isFile() && entry.name.endsWith('.js')) {\r\n        files.push(relativePath);\r\n      }\r\n    }\r\n  }\r\n\r\n  walk(dir);\r\n  return files;\r\n}"
        },
        "walk": {
          "hash": "cd026b7b21bf3e91f49fa061288cee78",
          "line": 38,
          "endLine": 56,
          "size": 595,
          "async": false,
          "language": "javascript",
          "source": "function walk(currentDir) {\r\n    const entries = readdirSync(currentDir, { withFileTypes: true });\r\n\r\n    for (const entry of entries) {\r\n      const fullPath = join(currentDir, entry.name);\r\n      // Determine relative path from the *target directory* not CWD\r\n      const relativePath = relative(dir, fullPath);\r\n\r\n      if (ignore.some(pattern => relativePath.includes(pattern))) {\r\n        continue;\r\n      }\r\n\r\n      if (entry.isDirectory()) {\r\n        walk(fullPath);\r\n      } else if (entry.isFile() && entry.name.endsWith('.js')) {\r\n        files.push(relativePath);\r\n      }\r\n    }\r\n  }"
        },
        "loadManifest": {
          "hash": "6d393cd286b3e9d7568ec8a83c56e389",
          "line": 66,
          "endLine": 75,
          "size": 312,
          "async": false,
          "language": "javascript",
          "source": "function loadManifest(rootDir = '.') {\r\n  const manifestPath = join(rootDir, '.llm-context/manifest.json');\r\n\r\n  if (!existsSync(manifestPath)) {\r\n    console.log('⚠ No manifest.json found - run manifest-generator.js first');\r\n    return null;\r\n  }\r\n\r\n  return JSON.parse(readFileSync(manifestPath, 'utf-8'));\r\n}"
        },
        "detectChanges": {
          "hash": "0f81c13245663c1362bb83eef46b5d46",
          "line": 81,
          "endLine": 154,
          "size": 2061,
          "async": false,
          "language": "javascript",
          "source": "function detectChanges(rootDir = '.') {\r\n  console.log('[1] Loading manifest...');\r\n  const manifest = loadManifest(rootDir);\r\n\r\n  if (!manifest) {\r\n    return {\r\n      added: [],\r\n      modified: [],\r\n      deleted: [],\r\n      unchanged: [],\r\n      needsFullAnalysis: true\r\n    };\r\n  }\r\n\r\n  console.log(`    Last analysis: ${manifest.generated}`);\r\n  console.log(`    Files tracked: ${Object.keys(manifest.files).length}\\n`);\r\n\r\n  console.log('[2] Discovering current files...');\r\n  const currentFiles = findJsFiles(rootDir);\r\n  console.log(`    Found ${currentFiles.length} JavaScript files\\n`);\r\n\r\n  console.log('[3] Computing changes...');\r\n\r\n  const manifestFiles = new Set(Object.keys(manifest.files));\r\n  const currentFilesSet = new Set(currentFiles);\r\n\r\n  const added = [];\r\n  const modified = [];\r\n  const deleted = [];\r\n  const unchanged = [];\r\n\r\n  // Check for new and modified files\r\n  for (const filePath of currentFiles) {\r\n    if (!manifestFiles.has(filePath)) {\r\n      // New file\r\n      added.push(filePath);\r\n      console.log(`    + ${filePath} (NEW)`);\r\n    } else {\r\n      // Existing file - check hash\r\n      const currentHash = hashFile(join(rootDir, filePath));\r\n      const manifestHash = manifest.files[filePath].hash;\r\n\r\n      if (currentHash !== manifestHash) {\r\n        modified.push(filePath);\r\n        console.log(`    M ${filePath} (MODIFIED)`);\r\n        console.log(`      Old: ${manifestHash.substring(0, 12)}...`);\r\n        console.log(`      New: ${currentHash.substring(0, 12)}...`);\r\n      } else {\r\n        unchanged.push(filePath);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check for deleted files\r\n  for (const filePath of manifestFiles) {\r\n    if (!currentFilesSet.has(filePath)) {\r\n      deleted.push(filePath);\r\n      console.log(`    - ${filePath} (DELETED)`);\r\n    }\r\n  }\r\n\r\n  if (added.length === 0 && modified.length === 0 && deleted.length === 0) {\r\n    console.log('    ✓ No changes detected');\r\n  }\r\n\r\n  return {\r\n    added,\r\n    modified,\r\n    deleted,\r\n    unchanged,\r\n    needsFullAnalysis: false,\r\n    manifest\r\n  };\r\n}"
        },
        "printSummary": {
          "hash": "0418a6235631b007d157dfbd0b687b49",
          "line": 160,
          "endLine": 192,
          "size": 1333,
          "async": false,
          "language": "javascript",
          "source": "function printSummary(report) {\r\n  console.log('\\n=== Change Summary ===');\r\n\r\n  if (report.needsFullAnalysis) {\r\n    console.log('Status: Full analysis needed (no existing manifest)');\r\n    return;\r\n  }\r\n\r\n  const total = report.added.length + report.modified.length + report.deleted.length;\r\n\r\n  console.log(`Total files: ${report.added.length + report.modified.length + report.unchanged.length}`);\r\n  console.log(`Changes detected: ${total}`);\r\n  console.log(`  Added: ${report.added.length}`);\r\n  console.log(`  Modified: ${report.modified.length}`);\r\n  console.log(`  Deleted: ${report.deleted.length}`);\r\n  console.log(`  Unchanged: ${report.unchanged.length}`);\r\n\r\n  if (total === 0) {\r\n    console.log('\\n✓ All files up to date - no re-analysis needed!');\r\n  } else {\r\n    const percentChanged = ((total / (total + report.unchanged.length)) * 100).toFixed(1);\r\n    console.log(`\\nRe-analysis needed for ${total} files (${percentChanged}% of codebase)`);\r\n\r\n    // Estimate time savings\r\n    const unchangedCount = report.unchanged.length;\r\n    if (unchangedCount > 0) {\r\n      console.log(`\\nEstimated savings:`);\r\n      console.log(`  Files skipped: ${unchangedCount}`);\r\n      console.log(`  Approximate time saved: ${(unchangedCount * 0.5).toFixed(1)}s`);\r\n      console.log(`  (Assuming ~500ms per file)`);\r\n    }\r\n  }\r\n}"
        },
        "main": {
          "hash": "4f9eb79d178d556a82c3fc56d520eb7d",
          "line": 197,
          "endLine": 201,
          "size": 98,
          "async": false,
          "language": "javascript",
          "source": "function main() {\r\n  const report = detectChanges();\r\n  printSummary(report);\r\n  return report;\r\n}"
        }
      }
    },
    "src/core/dependency-analyzer.js": {
      "hash": "ba4d56e44a040a06c18f3bdc18d18c13",
      "size": 10937,
      "lastModified": "2026-01-11T10:45:22.645Z",
      "functions": [
        "loadConfig",
        "loadGraph",
        "buildDependencyGraph",
        "computeImpactSet",
        "findEntryPoints",
        "findLeafFunctions",
        "detectCycles",
        "dfs",
        "computeDependencyDepth",
        "dfs",
        "analyzeDependencies",
        "analyzeImpact"
      ],
      "analysisTime": null,
      "functionHashes": {
        "loadConfig": {
          "hash": "e5d4ee6d6d71f6ddde52267611e3fe8c",
          "line": 17,
          "endLine": 25,
          "size": 233,
          "async": false,
          "language": "javascript",
          "source": "function loadConfig() {\r\n  const configPath = './llm-context.config.json';\r\n\r\n  if (!existsSync(configPath)) {\r\n    return { analysis: { trackDependencies: false } };\r\n  }\r\n\r\n  return JSON.parse(readFileSync(configPath, 'utf-8'));\r\n}"
        },
        "loadGraph": {
          "hash": "3531f2f406780d18bdf509653c26c2d0",
          "line": 31,
          "endLine": 40,
          "size": 258,
          "async": false,
          "language": "javascript",
          "source": "function loadGraph() {\r\n  const graphPath = '.llm-context/graph.jsonl';\r\n\r\n  if (!existsSync(graphPath)) {\r\n    return [];\r\n  }\r\n\r\n  const lines = readFileSync(graphPath, 'utf-8').split('\\n').filter(Boolean);\r\n  return lines.map(line => JSON.parse(line));\r\n}"
        },
        "buildDependencyGraph": {
          "hash": "11a863d178c19d264d4cc73fa1c761d6",
          "line": 47,
          "endLine": 79,
          "size": 1033,
          "async": false,
          "language": "javascript",
          "source": "function buildDependencyGraph(functions) {\r\n  const dependencies = new Map(); // function -> functions it depends on\r\n  const dependents = new Map();   // function -> functions that depend on it\r\n  const functionMap = new Map();  // name -> full entry\r\n\r\n  // Index functions by name\r\n  for (const func of functions) {\r\n    const name = func.name || func.id;\r\n    functionMap.set(name, func);\r\n    dependencies.set(name, new Set());\r\n    dependents.set(name, new Set());\r\n  }\r\n\r\n  // Build dependency relationships\r\n  for (const func of functions) {\r\n    const name = func.name || func.id;\r\n    const calls = func.calls || [];\r\n\r\n    for (const calledName of calls) {\r\n      // Only track dependencies to functions we know about\r\n      if (functionMap.has(calledName)) {\r\n        dependencies.get(name).add(calledName);\r\n        dependents.get(calledName).add(name);\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    dependencies,  // what each function depends on\r\n    dependents,    // what depends on each function\r\n    functionMap\r\n  };\r\n}"
        },
        "computeImpactSet": {
          "hash": "d970394d0508399237a83d917abce5cb",
          "line": 88,
          "endLine": 116,
          "size": 718,
          "async": false,
          "language": "javascript",
          "source": "function computeImpactSet(functionName, dependents, maxDepth = 10) {\r\n  const impacted = new Set();\r\n  const queue = [[functionName, 0]]; // [name, depth]\r\n  const visited = new Set();\r\n\r\n  while (queue.length > 0) {\r\n    const [current, depth] = queue.shift();\r\n\r\n    if (visited.has(current) || depth > maxDepth) {\r\n      continue;\r\n    }\r\n\r\n    visited.add(current);\r\n\r\n    if (current !== functionName) {\r\n      impacted.add(current);\r\n    }\r\n\r\n    // Add all functions that depend on current\r\n    const deps = dependents.get(current) || new Set();\r\n    for (const dependent of deps) {\r\n      if (!visited.has(dependent)) {\r\n        queue.push([dependent, depth + 1]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return impacted;\r\n}"
        },
        "findEntryPoints": {
          "hash": "e24fc5fa7bc1d1407db6368133d3d03b",
          "line": 124,
          "endLine": 140,
          "size": 459,
          "async": false,
          "language": "javascript",
          "source": "function findEntryPoints(dependents, maxCallers = 2) {\r\n  const entryPoints = [];\r\n\r\n  for (const [funcName, callers] of dependents) {\r\n    if (callers.size <= maxCallers ||\r\n        funcName.includes('main') ||\r\n        funcName.includes('init') ||\r\n        funcName.includes('start')) {\r\n      entryPoints.push({\r\n        name: funcName,\r\n        callers: callers.size\r\n      });\r\n    }\r\n  }\r\n\r\n  return entryPoints.sort((a, b) => a.callers - b.callers);\r\n}"
        },
        "findLeafFunctions": {
          "hash": "cfa0a3660a275ca1e2a849c2aab98da2",
          "line": 147,
          "endLine": 157,
          "size": 209,
          "async": false,
          "language": "javascript",
          "source": "function findLeafFunctions(dependencies) {\r\n  const leaves = [];\r\n\r\n  for (const [funcName, deps] of dependencies) {\r\n    if (deps.size === 0) {\r\n      leaves.push(funcName);\r\n    }\r\n  }\r\n\r\n  return leaves;\r\n}"
        },
        "detectCycles": {
          "hash": "2f030a306346c4be54fa1c228db2f034",
          "line": 164,
          "endLine": 203,
          "size": 892,
          "async": false,
          "language": "javascript",
          "source": "function detectCycles(dependencies) {\r\n  const cycles = [];\r\n  const visited = new Set();\r\n  const recursionStack = new Set();\r\n  const path = [];\r\n\r\n  function dfs(node) {\r\n    visited.add(node);\r\n    recursionStack.add(node);\r\n    path.push(node);\r\n\r\n    const deps = dependencies.get(node) || new Set();\r\n\r\n    for (const dep of deps) {\r\n      if (!visited.has(dep)) {\r\n        if (dfs(dep)) {\r\n          return true;\r\n        }\r\n      } else if (recursionStack.has(dep)) {\r\n        // Found cycle\r\n        const cycleStart = path.indexOf(dep);\r\n        const cycle = path.slice(cycleStart);\r\n        cycle.push(dep); // Close the cycle\r\n        cycles.push(cycle);\r\n      }\r\n    }\r\n\r\n    path.pop();\r\n    recursionStack.delete(node);\r\n    return false;\r\n  }\r\n\r\n  for (const node of dependencies.keys()) {\r\n    if (!visited.has(node)) {\r\n      dfs(node);\r\n    }\r\n  }\r\n\r\n  return cycles;\r\n}"
        },
        "dfs": {
          "hash": "e814f6f119c16230bf1f09c7bca596c9",
          "line": 214,
          "endLine": 233,
          "size": 429,
          "async": false,
          "language": "javascript",
          "source": "function dfs(node, depth) {\r\n    if (visited.has(node)) {\r\n      return 0; // Avoid cycles\r\n    }\r\n\r\n    visited.add(node);\r\n\r\n    const deps = dependencies.get(node) || new Set();\r\n    if (deps.size === 0) {\r\n      return depth;\r\n    }\r\n\r\n    let maxDepth = depth;\r\n    for (const dep of deps) {\r\n      const childDepth = dfs(dep, depth + 1);\r\n      maxDepth = Math.max(maxDepth, childDepth);\r\n    }\r\n\r\n    return maxDepth;\r\n  }"
        },
        "computeDependencyDepth": {
          "hash": "0ba439aa57155b92e2157b1bc2df6979",
          "line": 211,
          "endLine": 236,
          "size": 563,
          "async": false,
          "language": "javascript",
          "source": "function computeDependencyDepth(functionName, dependencies) {\r\n  const visited = new Set();\r\n\r\n  function dfs(node, depth) {\r\n    if (visited.has(node)) {\r\n      return 0; // Avoid cycles\r\n    }\r\n\r\n    visited.add(node);\r\n\r\n    const deps = dependencies.get(node) || new Set();\r\n    if (deps.size === 0) {\r\n      return depth;\r\n    }\r\n\r\n    let maxDepth = depth;\r\n    for (const dep of deps) {\r\n      const childDepth = dfs(dep, depth + 1);\r\n      maxDepth = Math.max(maxDepth, childDepth);\r\n    }\r\n\r\n    return maxDepth;\r\n  }\r\n\r\n  return dfs(functionName, 0);\r\n}"
        },
        "analyzeDependencies": {
          "hash": "1e272bd8c3e40494a53658fc85cfcff8",
          "line": 241,
          "endLine": 324,
          "size": 2837,
          "async": false,
          "language": "javascript",
          "source": "function analyzeDependencies() {\r\n  console.log('=== Dependency Analyzer ===\\n');\r\n\r\n  const config = loadConfig();\r\n  const trackDeps = config.analysis?.trackDependencies || false;\r\n\r\n  if (!trackDeps) {\r\n    console.log('Dependency tracking disabled in config');\r\n    console.log('Set analysis.trackDependencies = true to enable');\r\n    return null;\r\n  }\r\n\r\n  const functions = loadGraph();\r\n  console.log(`[1] Loaded ${functions.length} functions from graph\\n`);\r\n\r\n  const { dependencies, dependents, functionMap } = buildDependencyGraph(functions);\r\n  console.log(`[2] Built dependency graph`);\r\n  console.log(`    Total dependencies: ${Array.from(dependencies.values()).reduce((sum, deps) => sum + deps.size, 0)}\\n`);\r\n\r\n  // Find entry points\r\n  const entryPoints = findEntryPoints(dependents);\r\n  console.log(`[3] Entry points (${entryPoints.length}):`);\r\n  for (const ep of entryPoints.slice(0, 10)) {\r\n    console.log(`    - ${ep.name} (${ep.callers} callers)`);\r\n  }\r\n  if (entryPoints.length > 10) {\r\n    console.log(`    ... and ${entryPoints.length - 10} more`);\r\n  }\r\n\r\n  // Find leaf functions\r\n  const leaves = findLeafFunctions(dependencies);\r\n  console.log(`\\n[4] Leaf functions (${leaves.length}):`);\r\n  console.log(`    ${leaves.slice(0, 20).join(', ')}`);\r\n  if (leaves.length > 20) {\r\n    console.log(`    ... and ${leaves.length - 20} more`);\r\n  }\r\n\r\n  // Detect cycles\r\n  const cycles = detectCycles(dependencies);\r\n  if (cycles.length > 0) {\r\n    console.log(`\\n[5] ⚠ Dependency cycles detected (${cycles.length}):`);\r\n    for (const cycle of cycles.slice(0, 5)) {\r\n      console.log(`    ${cycle.join(' → ')}`);\r\n    }\r\n    if (cycles.length > 5) {\r\n      console.log(`    ... and ${cycles.length - 5} more`);\r\n    }\r\n  } else {\r\n    console.log(`\\n[5] ✓ No dependency cycles detected`);\r\n  }\r\n\r\n  // Save dependency graph\r\n  const depGraph = {\r\n    version: '1.0.0',\r\n    generated: new Date().toISOString(),\r\n    stats: {\r\n      totalFunctions: functions.length,\r\n      totalDependencies: Array.from(dependencies.values()).reduce((sum, deps) => sum + deps.size, 0),\r\n      entryPoints: entryPoints.length,\r\n      leafFunctions: leaves.length,\r\n      cycles: cycles.length\r\n    },\r\n    entryPoints,\r\n    leaves,\r\n    cycles,\r\n    dependencies: Object.fromEntries(\r\n      Array.from(dependencies.entries()).map(([name, deps]) => [\r\n        name,\r\n        Array.from(deps)\r\n      ])\r\n    ),\r\n    dependents: Object.fromEntries(\r\n      Array.from(dependents.entries()).map(([name, deps]) => [\r\n        name,\r\n        Array.from(deps)\r\n      ])\r\n    )\r\n  };\r\n\r\n  writeFileSync('.llm-context/dependencies.json', JSON.stringify(depGraph, null, 2));\r\n  console.log(`\\n✓ Dependency graph saved to .llm-context/dependencies.json`);\r\n\r\n  return { dependencies, dependents, functionMap, cycles, entryPoints, leaves };\r\n}"
        },
        "analyzeImpact": {
          "hash": "7d22ad21caa23506795578408f263b6b",
          "line": 331,
          "endLine": 377,
          "size": 1571,
          "async": false,
          "language": "javascript",
          "source": "function analyzeImpact(changedFunctions) {\r\n  const functions = loadGraph();\r\n  const { dependencies, dependents, functionMap } = buildDependencyGraph(functions);\r\n\r\n  const config = loadConfig();\r\n  const maxDepth = config.analysis?.maxCallDepth || 10;\r\n\r\n  const impactReport = {\r\n    changedFunctions,\r\n    totalImpacted: new Set(),\r\n    perFunctionImpact: {}\r\n  };\r\n\r\n  console.log('\\n=== Impact Analysis ===\\n');\r\n\r\n  for (const funcName of changedFunctions) {\r\n    const impacted = computeImpactSet(funcName, dependents, maxDepth);\r\n\r\n    impactReport.perFunctionImpact[funcName] = {\r\n      directCallers: Array.from(dependents.get(funcName) || new Set()),\r\n      totalImpacted: impacted.size,\r\n      impactedFunctions: Array.from(impacted)\r\n    };\r\n\r\n    // Add to total impacted set\r\n    for (const imp of impacted) {\r\n      impactReport.totalImpacted.add(imp);\r\n    }\r\n\r\n    console.log(`${funcName}:`);\r\n    console.log(`  Direct callers: ${impactReport.perFunctionImpact[funcName].directCallers.length}`);\r\n    console.log(`  Total impacted: ${impacted.size}`);\r\n\r\n    if (impacted.size > 0 && impacted.size <= 10) {\r\n      console.log(`  Affected functions: ${Array.from(impacted).join(', ')}`);\r\n    } else if (impacted.size > 10) {\r\n      console.log(`  Affected functions: ${Array.from(impacted).slice(0, 10).join(', ')}...`);\r\n    }\r\n\r\n    console.log('');\r\n  }\r\n\r\n  impactReport.totalImpacted = Array.from(impactReport.totalImpacted);\r\n  console.log(`Total unique functions impacted: ${impactReport.totalImpacted.length}\\n`);\r\n\r\n  return impactReport;\r\n}"
        }
      }
    },
    "src/core/full-analysis.js": {
      "hash": "4176c46d22c8943c06abb30543865fa3",
      "size": 5626,
      "lastModified": "2026-02-08T13:12:46.933Z",
      "functions": [
        "loadConfig",
        "findSourceFiles",
        "walk",
        "analyzeFile",
        "main"
      ],
      "analysisTime": null,
      "functionHashes": {
        "loadConfig": {
          "hash": "5bd1d5303e5baafca2e385e9cd481f96",
          "line": 22,
          "endLine": 28,
          "size": 276,
          "async": false,
          "language": "javascript",
          "source": "function loadConfig() {\r\n  const configPath = './llm-context.config.json';\r\n  if (!existsSync(configPath)) {\r\n    return { patterns: { include: ['**/*.js'], exclude: ['node_modules', '.git', '.llm-context'] } };\r\n  }\r\n  return JSON.parse(readFileSync(configPath, 'utf-8'));\r\n}"
        },
        "findSourceFiles": {
          "hash": "c5d9067df22ccbae8b0dd01f1b949eca",
          "line": 33,
          "endLine": 93,
          "size": 1695,
          "async": false,
          "language": "javascript",
          "source": "function findSourceFiles() {\r\n  const config = loadConfig();\r\n  const files = [];\r\n\r\n  // Create gitignore checker\r\n  const isIgnored = parseGitignore();\r\n\r\n  // Extensions to include based on config\r\n  const extensions = new Set();\r\n  for (const pattern of config.patterns.include) {\r\n    const match = pattern.match(/\\*\\.(\\w+)$/);\r\n    if (match) {\r\n      extensions.add('.' + match[1]);\r\n    }\r\n  }\r\n\r\n  function walk(dir) {\r\n    try {\r\n      const entries = readdirSync(dir);\r\n\r\n      for (const entry of entries) {\r\n        const fullPath = join(dir, entry);\r\n        const stat = statSync(fullPath);\r\n        const isDirectory = stat.isDirectory();\r\n\r\n        // Skip if ignored by .gitignore or default patterns\r\n        if (isIgnored(fullPath, isDirectory)) {\r\n          continue;\r\n        }\r\n\r\n        // Skip excluded directories/files from config\r\n        const isExcluded = config.patterns.exclude.some(pattern => {\r\n          return fullPath.includes('/' + pattern + '/') ||\r\n                 fullPath.includes('\\\\' + pattern + '\\\\') ||\r\n                 fullPath.endsWith('/' + pattern) ||\r\n                 fullPath.endsWith('\\\\' + pattern) ||\r\n                 entry === pattern;\r\n        });\r\n\r\n        if (isExcluded) {\r\n          continue;\r\n        }\r\n\r\n        if (isDirectory) {\r\n          walk(fullPath);\r\n        } else if (stat.isFile()) {\r\n          // Check if file has matching extension\r\n          const ext = entry.substring(entry.lastIndexOf('.'));\r\n          if (extensions.has(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      // Skip inaccessible directories\r\n    }\r\n  }\r\n\r\n  walk('.');\r\n  return files;\r\n}"
        },
        "walk": {
          "hash": "a666a105b845764463acc93abc6e17b0",
          "line": 49,
          "endLine": 89,
          "size": 1252,
          "async": false,
          "language": "javascript",
          "source": "function walk(dir) {\r\n    try {\r\n      const entries = readdirSync(dir);\r\n\r\n      for (const entry of entries) {\r\n        const fullPath = join(dir, entry);\r\n        const stat = statSync(fullPath);\r\n        const isDirectory = stat.isDirectory();\r\n\r\n        // Skip if ignored by .gitignore or default patterns\r\n        if (isIgnored(fullPath, isDirectory)) {\r\n          continue;\r\n        }\r\n\r\n        // Skip excluded directories/files from config\r\n        const isExcluded = config.patterns.exclude.some(pattern => {\r\n          return fullPath.includes('/' + pattern + '/') ||\r\n                 fullPath.includes('\\\\' + pattern + '\\\\') ||\r\n                 fullPath.endsWith('/' + pattern) ||\r\n                 fullPath.endsWith('\\\\' + pattern) ||\r\n                 entry === pattern;\r\n        });\r\n\r\n        if (isExcluded) {\r\n          continue;\r\n        }\r\n\r\n        if (isDirectory) {\r\n          walk(fullPath);\r\n        } else if (stat.isFile()) {\r\n          // Check if file has matching extension\r\n          const ext = entry.substring(entry.lastIndexOf('.'));\r\n          if (extensions.has(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      // Skip inaccessible directories\r\n    }\r\n  }"
        },
        "analyzeFile": {
          "hash": "4e49ab0110f4bc20ee76249c9d637c8d",
          "line": 98,
          "endLine": 158,
          "size": 1939,
          "async": true,
          "language": "javascript",
          "source": "async function analyzeFile(filePath) {\r\n  try {\r\n    const source = readFileSync(filePath, 'utf-8');\r\n\r\n    // Detect language\r\n    const language = ParserFactory.detectLanguage(filePath);\r\n    if (!language) {\r\n      console.log(`  ⚠ Skipping ${filePath} (unsupported language)`);\r\n      return [];\r\n    }\r\n\r\n    // Parse\r\n    const { tree } = await ParserFactory.parseFile(filePath);\r\n    const adapter = createAdapter(tree, language, source, filePath);\r\n\r\n    // Extract functions\r\n    const functions = adapter.extractFunctionsWithNodes();\r\n    if (functions.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    // Extract imports\r\n    const imports = adapter.extractImports();\r\n    const sideEffectAnalyzer = createAnalyzer(language, imports);\r\n    const semanticAnalyzer = createSemanticAnalyzer(language);\r\n\r\n    // Build graph entries\r\n    const entries = functions.map(({ metadata }) => {\r\n      const calls = adapter.extractCallGraph(metadata);\r\n      const uniqueCalls = [...new Set(calls)].filter(c => c !== metadata.name);\r\n\r\n      // Analyze side effects\r\n      const effectsWithConfidence = sideEffectAnalyzer.analyze(uniqueCalls, metadata.source);\r\n      const uniqueEffects = [...new Set(effectsWithConfidence.map(e => e.type))];\r\n\r\n      // Semantic tagging\r\n      const tags = semanticAnalyzer.analyze(metadata.source);\r\n\r\n      return {\r\n        id: metadata.name,\r\n        type: 'function',\r\n        file: filePath,\r\n        line: metadata.line,\r\n        sig: `(${metadata.isAsync ? 'async ' : ''}${metadata.params || ''})`,\r\n        async: metadata.isAsync || false,\r\n        calls: uniqueCalls.slice(0, 10),\r\n        effects: uniqueEffects,\r\n        tags: tags,\r\n        scipDoc: '',\r\n        language: language\r\n      };\r\n    });\r\n\r\n    console.log(`  ✓ ${filePath}: ${entries.length} functions`);\r\n    return entries;\r\n\r\n  } catch (error) {\r\n    console.log(`  ✗ ${filePath}: ${error.message}`);\r\n    return [];\r\n  }\r\n}"
        },
        "main": {
          "hash": "b8dc1af7f6b3330d4acd3f87a0ea6314",
          "line": 163,
          "endLine": 184,
          "size": 756,
          "async": true,
          "language": "javascript",
          "source": "async function main() {\r\n  console.log('[1] Finding source files...');\r\n  const files = findSourceFiles();\r\n  console.log(`    Found ${files.length} files\\n`);\r\n\r\n  console.log('[2] Analyzing files...');\r\n  const allEntries = [];\r\n\r\n  for (const file of files) {\r\n    const entries = await analyzeFile(file);\r\n    allEntries.push(...entries);\r\n  }\r\n\r\n  console.log(`\\n[3] Writing graph.jsonl...`);\r\n  const jsonlContent = allEntries.map(entry => JSON.stringify(entry)).join('\\n');\r\n  writeFileSync('.llm-context/graph.jsonl', jsonlContent);\r\n\r\n  console.log(`\\n✅ Analysis complete!`);\r\n  console.log(`   Files analyzed: ${files.length}`);\r\n  console.log(`   Functions found: ${allEntries.length}`);\r\n  console.log(`   Output: .llm-context/graph.jsonl`);\r\n}"
        }
      }
    },
    "src/core/function-change-detector.js": {
      "hash": "a69e33fbc1d60a792906ce7f1b81ce1c",
      "size": 9090,
      "lastModified": "2026-02-08T13:13:05.099Z",
      "functions": [
        "loadConfig",
        "extractCurrentFunctions",
        "detectFunctionChanges",
        "detectAllFunctionChanges",
        "printFunctionChangeSummary"
      ],
      "analysisTime": null,
      "functionHashes": {
        "loadConfig": {
          "hash": "1cb52fe4e91e7b7016bc44fa014e40a1",
          "line": 17,
          "endLine": 25,
          "size": 214,
          "async": false,
          "language": "javascript",
          "source": "function loadConfig() {\r\n  const configPath = './llm-context.config.json';\r\n\r\n  if (!existsSync(configPath)) {\r\n    return { granularity: 'file' };\r\n  }\r\n\r\n  return JSON.parse(readFileSync(configPath, 'utf-8'));\r\n}"
        },
        "extractCurrentFunctions": {
          "hash": "f6981426b1f3ec107a415334f3035b82",
          "line": 32,
          "endLine": 61,
          "size": 861,
          "async": true,
          "language": "javascript",
          "source": "async function extractCurrentFunctions(filePath) {\r\n  const functionMap = new Map();\r\n\r\n  try {\r\n    const source = readFileSync(filePath, 'utf-8');\r\n\r\n    // Detect language and parse with Tree-sitter\r\n    const language = ParserFactory.detectLanguage(filePath);\r\n    if (!language) {\r\n      console.log(`    Warning: Unsupported file type: ${filePath}`);\r\n      return functionMap;\r\n    }\r\n\r\n    const { tree } = await ParserFactory.parseFile(filePath);\r\n    const adapter = createAdapter(tree, language, source, filePath);\r\n\r\n    // Extract all functions\r\n    const functions = adapter.extractFunctions();\r\n\r\n    // Build map\r\n    for (const metadata of functions) {\r\n      functionMap.set(metadata.name, metadata);\r\n    }\r\n\r\n  } catch (error) {\r\n    console.log(`    Warning: Could not parse ${filePath}: ${error.message}`);\r\n  }\r\n\r\n  return functionMap;\r\n}"
        },
        "detectFunctionChanges": {
          "hash": "751ac3b8c16334e7b3a67198932bb721",
          "line": 69,
          "endLine": 184,
          "size": 3623,
          "async": true,
          "language": "javascript",
          "source": "async function detectFunctionChanges(filePath, manifest) {\r\n  const changes = {\r\n    filePath,\r\n    added: [],\r\n    modified: [],\r\n    deleted: [],\r\n    unchanged: [],\r\n    renames: []\r\n  };\r\n\r\n  // Get current functions\r\n  const currentFunctions = await extractCurrentFunctions(filePath);\r\n\r\n  // Get manifest functions\r\n  const fileEntry = manifest.files[filePath];\r\n  if (!fileEntry || !fileEntry.functionHashes) {\r\n    // No previous function data - all current functions are \"added\"\r\n    for (const [name, metadata] of currentFunctions) {\r\n      changes.added.push({\r\n        name,\r\n        hash: metadata.hash,\r\n        line: metadata.line,\r\n        size: metadata.size\r\n      });\r\n    }\r\n    return changes;\r\n  }\r\n\r\n  const manifestFunctions = fileEntry.functionHashes;\r\n\r\n  // Compare current vs manifest\r\n  for (const [name, metadata] of currentFunctions) {\r\n    const manifestFunc = manifestFunctions[name];\r\n\r\n    if (!manifestFunc) {\r\n      // New function\r\n      changes.added.push({\r\n        name,\r\n        hash: metadata.hash,\r\n        line: metadata.line,\r\n        size: metadata.size\r\n      });\r\n    } else if (manifestFunc.hash !== metadata.hash) {\r\n      // Modified function\r\n      changes.modified.push({\r\n        name,\r\n        oldHash: manifestFunc.hash,\r\n        newHash: metadata.hash,\r\n        oldLine: manifestFunc.line,\r\n        newLine: metadata.line,\r\n        sizeDelta: metadata.size - manifestFunc.size\r\n      });\r\n    } else {\r\n      // Unchanged function\r\n      changes.unchanged.push(name);\r\n    }\r\n  }\r\n\r\n  // Find deleted functions\r\n  for (const name in manifestFunctions) {\r\n    if (!currentFunctions.has(name)) {\r\n      changes.deleted.push({\r\n        name,\r\n        hash: manifestFunctions[name].hash,\r\n        line: manifestFunctions[name].line\r\n      });\r\n    }\r\n  }\r\n\r\n  // Detect potential renames (deleted + added with similar code)\r\n  if (changes.deleted.length > 0 && changes.added.length > 0) {\r\n    const config = loadConfig();\r\n    const detectRenames = config.incremental?.detectRenames || false;\r\n\r\n    if (detectRenames && fileEntry.functionHashes) {\r\n      // Check if we have source stored for similarity comparison\r\n      const hasStoredSource = Object.values(fileEntry.functionHashes).some(f => f.source);\r\n\r\n      if (hasStoredSource) {\r\n        const { computeSimilarity } = await import('../utils/function-source-extractor.js');\r\n        const threshold = config.incremental?.similarityThreshold || 0.85;\r\n\r\n        for (const deletedFunc of changes.deleted) {\r\n          const oldSource = manifestFunctions[deletedFunc.name]?.source;\r\n\r\n          if (!oldSource) continue;\r\n\r\n          // Compare with each added function\r\n          for (const addedFunc of changes.added) {\r\n            const newMetadata = currentFunctions.get(addedFunc.name);\r\n            if (!newMetadata || !newMetadata.source) continue;\r\n\r\n            const similarity = computeSimilarity(oldSource, newMetadata.source);\r\n\r\n            if (similarity >= threshold) {\r\n              changes.renames.push({\r\n                from: deletedFunc.name,\r\n                to: addedFunc.name,\r\n                similarity: similarity.toFixed(3),\r\n                oldLine: deletedFunc.line,\r\n                newLine: addedFunc.line\r\n              });\r\n\r\n              // Remove from deleted and added since it's a rename\r\n              changes.deleted = changes.deleted.filter(f => f.name !== deletedFunc.name);\r\n              changes.added = changes.added.filter(f => f.name !== addedFunc.name);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return changes;\r\n}"
        },
        "detectAllFunctionChanges": {
          "hash": "7077924c66f53ee8920322db32bd6eff",
          "line": 192,
          "endLine": 208,
          "size": 527,
          "async": true,
          "language": "javascript",
          "source": "async function detectAllFunctionChanges(changedFiles, manifest) {\r\n  const allChanges = new Map();\r\n\r\n  for (const filePath of changedFiles) {\r\n    const changes = await detectFunctionChanges(filePath, manifest);\r\n\r\n    // Only include files with actual function changes\r\n    if (changes.added.length > 0 ||\r\n        changes.modified.length > 0 ||\r\n        changes.deleted.length > 0 ||\r\n        (changes.renames && changes.renames.length > 0)) {\r\n      allChanges.set(filePath, changes);\r\n    }\r\n  }\r\n\r\n  return allChanges;\r\n}"
        },
        "printFunctionChangeSummary": {
          "hash": "ceca671dcce52e77deb47a15f8f011b9",
          "line": 214,
          "endLine": 283,
          "size": 2599,
          "async": false,
          "language": "javascript",
          "source": "function printFunctionChangeSummary(functionChanges) {\r\n  let totalAdded = 0;\r\n  let totalModified = 0;\r\n  let totalDeleted = 0;\r\n  let totalRenamed = 0;\r\n  let totalUnchanged = 0;\r\n\r\n  console.log('\\n=== Function-Level Changes ===\\n');\r\n\r\n  for (const [filePath, changes] of functionChanges) {\r\n    console.log(`${filePath}:`);\r\n\r\n    if (changes.renames && changes.renames.length > 0) {\r\n      console.log(`  Renamed (${changes.renames.length}):`);\r\n      for (const rename of changes.renames) {\r\n        console.log(`    ≈ ${rename.from} → ${rename.to} (${(rename.similarity * 100).toFixed(1)}% similar, line ${rename.oldLine}→${rename.newLine})`);\r\n      }\r\n      totalRenamed += changes.renames.length;\r\n    }\r\n\r\n    if (changes.added.length > 0) {\r\n      console.log(`  Added (${changes.added.length}):`);\r\n      for (const func of changes.added) {\r\n        console.log(`    + ${func.name} (line ${func.line}, ${func.size} bytes)`);\r\n      }\r\n      totalAdded += changes.added.length;\r\n    }\r\n\r\n    if (changes.modified.length > 0) {\r\n      console.log(`  Modified (${changes.modified.length}):`);\r\n      for (const func of changes.modified) {\r\n        const delta = func.sizeDelta >= 0 ? `+${func.sizeDelta}` : `${func.sizeDelta}`;\r\n        console.log(`    ~ ${func.name} (line ${func.oldLine}→${func.newLine}, ${delta} bytes)`);\r\n      }\r\n      totalModified += changes.modified.length;\r\n    }\r\n\r\n    if (changes.deleted.length > 0) {\r\n      console.log(`  Deleted (${changes.deleted.length}):`);\r\n      for (const func of changes.deleted) {\r\n        console.log(`    - ${func.name} (was line ${func.line})`);\r\n      }\r\n      totalDeleted += changes.deleted.length;\r\n    }\r\n\r\n    if (changes.unchanged.length > 0) {\r\n      console.log(`  Unchanged: ${changes.unchanged.length} functions`);\r\n      totalUnchanged += changes.unchanged.length;\r\n    }\r\n\r\n    console.log('');\r\n  }\r\n\r\n  console.log('=== Summary ===');\r\n  if (totalRenamed > 0) {\r\n    console.log(`Total functions renamed: ${totalRenamed}`);\r\n  }\r\n  console.log(`Total functions added: ${totalAdded}`);\r\n  console.log(`Total functions modified: ${totalModified}`);\r\n  console.log(`Total functions deleted: ${totalDeleted}`);\r\n  console.log(`Total functions unchanged: ${totalUnchanged}`);\r\n\r\n  const totalChanged = totalAdded + totalModified + totalDeleted + totalRenamed;\r\n  const totalFunctions = totalChanged + totalUnchanged;\r\n  const percentUnchanged = totalFunctions > 0\r\n    ? ((totalUnchanged / totalFunctions) * 100).toFixed(1)\r\n    : 0;\r\n\r\n  console.log(`\\n✓ Efficiency: ${percentUnchanged}% of functions skipped!`);\r\n}"
        }
      }
    },
    "src/core/incremental-analyzer.js": {
      "hash": "a48c151ac17cd3862bebdd9487763b47",
      "size": 19316,
      "lastModified": "2026-02-08T13:12:49.470Z",
      "functions": [
        "loadConfig",
        "computeFileHash",
        "getFileMetadata",
        "analyzeSpecificFunctions",
        "analyzeSingleFile",
        "loadGraph",
        "updateGraphFunctionLevel",
        "updateGraph",
        "updateManifest",
        "mainFunctionLevel",
        "mainFileLevel",
        "main"
      ],
      "analysisTime": null,
      "functionHashes": {
        "loadConfig": {
          "hash": "1cb52fe4e91e7b7016bc44fa014e40a1",
          "line": 28,
          "endLine": 36,
          "size": 214,
          "async": false,
          "language": "javascript",
          "source": "function loadConfig() {\r\n  const configPath = './llm-context.config.json';\r\n\r\n  if (!existsSync(configPath)) {\r\n    return { granularity: 'file' };\r\n  }\r\n\r\n  return JSON.parse(readFileSync(configPath, 'utf-8'));\r\n}"
        },
        "computeFileHash": {
          "hash": "b62e98f7bf6d9f8483abb37a86b85f59",
          "line": 41,
          "endLine": 44,
          "size": 141,
          "async": false,
          "language": "javascript",
          "source": "function computeFileHash(filePath) {\r\n  const content = readFileSync(filePath);\r\n  return createHash('md5').update(content).digest('hex');\r\n}"
        },
        "getFileMetadata": {
          "hash": "bf688e494f0c96c3acf2ef82db6cc11f",
          "line": 49,
          "endLine": 55,
          "size": 162,
          "async": false,
          "language": "javascript",
          "source": "function getFileMetadata(filePath) {\r\n  const stats = statSync(filePath);\r\n  return {\r\n    size: stats.size,\r\n    lastModified: stats.mtime.toISOString()\r\n  };\r\n}"
        },
        "analyzeSpecificFunctions": {
          "hash": "e286a1c0373d4ac6390e9f8a59de7f21",
          "line": 63,
          "endLine": 167,
          "size": 3665,
          "async": true,
          "language": "javascript",
          "source": "async function analyzeSpecificFunctions(sourcePath, targetFunctions = null) {\r\n  const startTime = Date.now();\r\n  const source = readFileSync(sourcePath, 'utf-8');\r\n\r\n  // Detect language and parse with Tree-sitter\r\n  const language = ParserFactory.detectLanguage(sourcePath);\r\n  if (!language) {\r\n    console.warn(`Unsupported file type: ${sourcePath}`);\r\n    return { entries: [], analysisTime: 0, totalFunctions: 0, analyzedFunctions: 0 };\r\n  }\r\n\r\n  const { tree } = await ParserFactory.parseFile(sourcePath);\r\n  const adapter = createAdapter(tree, language, source, sourcePath);\r\n\r\n  // Extract all functions\r\n  const allFunctions = adapter.extractFunctionsWithNodes();\r\n\r\n  // Filter to target functions if specified\r\n  const functionsToAnalyze = targetFunctions\r\n    ? allFunctions.filter(f => targetFunctions.includes(f.metadata.name))\r\n    : allFunctions;\r\n\r\n  // Extract imports for side effect analysis\r\n  const imports = adapter.extractImports();\r\n  const sideEffectAnalyzer = createAnalyzer(language, imports);\r\n  const semanticAnalyzer = createSemanticAnalyzer(language);\r\n\r\n  // Analyze each function\r\n  const results = [];\r\n\r\n  for (const { metadata } of functionsToAnalyze) {\r\n    // Extract call graph\r\n    const calls = adapter.extractCallGraph(metadata);\r\n    const uniqueCalls = [...new Set(calls)].filter(c => c !== metadata.name);\r\n\r\n    // Analyze side effects (AST-based, not regex!)\r\n    const effectsWithConfidence = sideEffectAnalyzer.analyze(uniqueCalls, metadata.source);\r\n    const uniqueEffects = [...new Set(effectsWithConfidence.map(e => e.type))];\r\n\r\n    // Semantic tagging\r\n    const tags = semanticAnalyzer.analyze(metadata.source);\r\n\r\n    // Detect code patterns\r\n    const patterns = [];\r\n\r\n    // Parsing patterns\r\n    if (uniqueCalls.some(c => c === 'parse' || c.includes('parse'))) {\r\n      patterns.push({\r\n        type: 'parsing',\r\n        tool: uniqueCalls.find(c => c.includes('tree-sitter') || c.includes('parser')) ? 'tree-sitter' : 'unknown',\r\n        description: 'Parses source code into AST'\r\n      });\r\n    }\r\n\r\n    // Hash/crypto patterns\r\n    if (uniqueCalls.some(c => /hash|md5|sha|digest|crypto/i.test(c))) {\r\n      patterns.push({\r\n        type: 'hashing',\r\n        method: uniqueCalls.find(c => /md5|sha/i.test(c)) || 'hash',\r\n        description: 'Computes file/content hash for change detection'\r\n      });\r\n    }\r\n\r\n    // Side effect detection patterns (now AST-based!)\r\n    if (effectsWithConfidence.length > 0) {\r\n      patterns.push({\r\n        type: 'side-effect-detection',\r\n        method: 'ast-analysis',\r\n        description: 'Detects side effects via AST analysis with import tracking'\r\n      });\r\n    }\r\n\r\n    // Graph manipulation\r\n    if (uniqueCalls.some(c => /map|filter|reduce|forEach/i.test(c)) &&\r\n        uniqueCalls.some(c => /graph|entries|functions/i.test(c))) {\r\n      patterns.push({\r\n        type: 'graph-transformation',\r\n        description: 'Transforms or filters call graph data'\r\n      });\r\n    }\r\n\r\n    results.push({\r\n      id: metadata.name,\r\n      type: 'function',\r\n      file: sourcePath,\r\n      line: metadata.line,\r\n      sig: `(${metadata.isAsync ? 'async ' : ''}${metadata.params || ''})`,\r\n      async: metadata.isAsync,\r\n      calls: uniqueCalls.slice(0, 10),\r\n      effects: uniqueEffects,\r\n      tags: tags,\r\n      patterns: patterns.length > 0 ? patterns : undefined,\r\n      scipDoc: '',\r\n      functionHash: metadata.hash,\r\n      language: language  // NEW: Include language\r\n    });\r\n  }\r\n\r\n  return {\r\n    entries: results,\r\n    analysisTime: Date.now() - startTime,\r\n    totalFunctions: allFunctions.length,\r\n    analyzedFunctions: results.length\r\n  };\r\n}"
        },
        "analyzeSingleFile": {
          "hash": "c6ab02976f1dad313005da05dabce196",
          "line": 174,
          "endLine": 235,
          "size": 2271,
          "async": true,
          "language": "javascript",
          "source": "async function analyzeSingleFile(sourcePath) {\r\n  const startTime = Date.now();\r\n\r\n  try {\r\n    const source = readFileSync(sourcePath, 'utf-8');\r\n\r\n    // Detect language and parse with Tree-sitter\r\n    const language = ParserFactory.detectLanguage(sourcePath);\r\n    if (!language) {\r\n      console.warn(`Unsupported file type: ${sourcePath}`);\r\n      return { entries: [], analysisTime: Date.now() - startTime };\r\n    }\r\n\r\n    const { tree } = await ParserFactory.parseFile(sourcePath);\r\n    const adapter = createAdapter(tree, language, source, sourcePath);\r\n\r\n    // Extract all functions\r\n    const allFunctions = adapter.extractFunctionsWithNodes();\r\n\r\n    // Extract imports for side effect analysis\r\n    const imports = adapter.extractImports();\r\n    const sideEffectAnalyzer = createAnalyzer(language, imports);\r\n    const semanticAnalyzer = createSemanticAnalyzer(language);\r\n\r\n    // Build output\r\n    const result = allFunctions.map(({ metadata }) => {\r\n      // Extract call graph\r\n      const calls = adapter.extractCallGraph(metadata);\r\n      const uniqueCalls = [...new Set(calls)].filter(c => c !== metadata.name);\r\n\r\n      // Analyze side effects (AST-based!)\r\n      const effectsWithConfidence = sideEffectAnalyzer.analyze(uniqueCalls, metadata.source);\r\n      const uniqueEffects = [...new Set(effectsWithConfidence.map(e => e.type))];\r\n\r\n      // Semantic tagging\r\n      const tags = semanticAnalyzer.analyze(metadata.source);\r\n\r\n      return {\r\n        id: metadata.name,\r\n        type: 'function',\r\n        file: sourcePath,\r\n        line: metadata.line,\r\n        sig: `(${metadata.isAsync ? 'async ' : ''}${metadata.params || ''})`,\r\n        async: metadata.isAsync || false,\r\n        calls: uniqueCalls.slice(0, 10),\r\n        effects: uniqueEffects,\r\n        tags: tags,\r\n        scipDoc: '',\r\n        language: language  // NEW: Include language\r\n      };\r\n    });\r\n\r\n    const analysisTime = Date.now() - startTime;\r\n    console.log(`      Analysis complete: ${allFunctions.length} functions, ${analysisTime}ms`);\r\n\r\n    return { entries: result, analysisTime };\r\n\r\n  } catch (error) {\r\n    console.log(`      Warning: Could not parse ${sourcePath}: ${error.message}`);\r\n    return { entries: [], analysisTime: Date.now() - startTime };\r\n  }\r\n}"
        },
        "loadGraph": {
          "hash": "3531f2f406780d18bdf509653c26c2d0",
          "line": 240,
          "endLine": 249,
          "size": 258,
          "async": false,
          "language": "javascript",
          "source": "function loadGraph() {\r\n  const graphPath = '.llm-context/graph.jsonl';\r\n\r\n  if (!existsSync(graphPath)) {\r\n    return [];\r\n  }\r\n\r\n  const lines = readFileSync(graphPath, 'utf-8').split('\\n').filter(Boolean);\r\n  return lines.map(line => JSON.parse(line));\r\n}"
        },
        "updateGraphFunctionLevel": {
          "hash": "78787eaad5298619bfdc5be9fb4121fb",
          "line": 254,
          "endLine": 291,
          "size": 1413,
          "async": false,
          "language": "javascript",
          "source": "function updateGraphFunctionLevel(functionChanges, newEntries) {\r\n  console.log('\\n[4] Updating graph.jsonl (function-level)...');\r\n\r\n  const existingEntries = loadGraph();\r\n  console.log(`    Current entries: ${existingEntries.length}`);\r\n\r\n  // Build a set of (file, function) pairs to remove\r\n  const toRemove = new Set();\r\n\r\n  for (const [filePath, changes] of functionChanges) {\r\n    // Remove modified and deleted functions\r\n    for (const func of [...changes.modified, ...changes.deleted]) {\r\n      toRemove.add(`${filePath}#${func.name}`);\r\n    }\r\n  }\r\n\r\n  // Keep entries that aren't in the remove set\r\n  const keptEntries = existingEntries.filter(entry => {\r\n    const key = `${entry.file}#${entry.id}`;\r\n    return !toRemove.has(key);\r\n  });\r\n\r\n  console.log(`    Entries kept (unchanged functions): ${keptEntries.length}`);\r\n  console.log(`    Entries removed (changed/deleted functions): ${existingEntries.length - keptEntries.length}`);\r\n\r\n  // Add new entries\r\n  const updatedGraph = [...keptEntries, ...newEntries];\r\n  console.log(`    New entries added: ${newEntries.length}`);\r\n  console.log(`    Total entries: ${updatedGraph.length}`);\r\n\r\n  // Write updated graph\r\n  const jsonlContent = updatedGraph.map(node => JSON.stringify(node)).join('\\n');\r\n  writeFileSync('.llm-context/graph.jsonl', jsonlContent);\r\n\r\n  console.log('    ✓ Graph updated (function-level)');\r\n\r\n  return updatedGraph;\r\n}"
        },
        "updateGraph": {
          "hash": "764c9f860df61c5d3f236db1e7bad832",
          "line": 296,
          "endLine": 323,
          "size": 1116,
          "async": false,
          "language": "javascript",
          "source": "function updateGraph(changedFiles, newEntries) {\r\n  console.log('\\n[4] Updating graph.jsonl (file-level)...');\r\n\r\n  // Load existing graph\r\n  const existingEntries = loadGraph();\r\n  console.log(`    Current entries: ${existingEntries.length}`);\r\n\r\n  // Create set of changed files for fast lookup\r\n  const changedSet = new Set(changedFiles);\r\n\r\n  // Keep only entries from unchanged files\r\n  const keptEntries = existingEntries.filter(entry => !changedSet.has(entry.file));\r\n  console.log(`    Entries kept (unchanged files): ${keptEntries.length}`);\r\n  console.log(`    Entries removed (changed files): ${existingEntries.length - keptEntries.length}`);\r\n\r\n  // Add all new entries\r\n  const updatedGraph = [...keptEntries, ...newEntries];\r\n  console.log(`    New entries added: ${newEntries.length}`);\r\n  console.log(`    Total entries: ${updatedGraph.length}`);\r\n\r\n  // Write updated graph\r\n  const jsonlContent = updatedGraph.map(node => JSON.stringify(node)).join('\\n');\r\n  writeFileSync('.llm-context/graph.jsonl', jsonlContent);\r\n\r\n  console.log('    ✓ Graph updated (file-level)');\r\n\r\n  return updatedGraph;\r\n}"
        },
        "updateManifest": {
          "hash": "9ceec15308b79fd70e99ba797e097820",
          "line": 328,
          "endLine": 370,
          "size": 1437,
          "async": false,
          "language": "javascript",
          "source": "function updateManifest(changeReport, analysisResults) {\r\n  console.log('\\n[5] Updating manifest.json...');\r\n\r\n  const manifest = changeReport.manifest;\r\n\r\n  // Remove deleted files\r\n  for (const filePath of changeReport.deleted) {\r\n    delete manifest.files[filePath];\r\n    console.log(`    - Removed: ${filePath}`);\r\n  }\r\n\r\n  // Update changed and new files\r\n  const allChangedFiles = [...changeReport.added, ...changeReport.modified];\r\n\r\n  for (const filePath of allChangedFiles) {\r\n    const hash = computeFileHash(filePath);\r\n    const metadata = getFileMetadata(filePath);\r\n    const result = analysisResults.get(filePath);\r\n\r\n    manifest.files[filePath] = {\r\n      hash,\r\n      size: metadata.size,\r\n      lastModified: metadata.lastModified,\r\n      functions: result ? result.entries.map(e => e.id) : [],\r\n      analysisTime: result ? result.analysisTime : null\r\n    };\r\n\r\n    console.log(`    ✓ Updated: ${filePath}`);\r\n  }\r\n\r\n  // Update global stats\r\n  const graph = loadGraph();\r\n  manifest.globalStats.totalFunctions = graph.length;\r\n  manifest.globalStats.totalCalls = graph.reduce((sum, f) => sum + (f.calls?.length || 0), 0);\r\n  manifest.globalStats.totalFiles = Object.keys(manifest.files).length;\r\n  manifest.generated = new Date().toISOString();\r\n\r\n  // Save manifest\r\n  writeFileSync('.llm-context/manifest.json', JSON.stringify(manifest, null, 2));\r\n  console.log('    ✓ Manifest updated');\r\n\r\n  return manifest;\r\n}"
        },
        "mainFunctionLevel": {
          "hash": "9ae8c5194df70f05b03ed5220db2ac8f",
          "line": 375,
          "endLine": 490,
          "size": 4233,
          "async": true,
          "language": "javascript",
          "source": "async function mainFunctionLevel() {\r\n  console.log('[1] Detecting file-level changes...');\r\n  const changeReport = detectChanges();\r\n\r\n  if (changeReport.needsFullAnalysis) {\r\n    console.log('\\n⚠ No manifest found - run full analysis first');\r\n    return;\r\n  }\r\n\r\n  const changedFiles = [...changeReport.added, ...changeReport.modified];\r\n\r\n  if (changedFiles.length === 0) {\r\n    console.log('\\n✓ No changes detected - all files up to date!');\r\n    return;\r\n  }\r\n\r\n  console.log(`\\n[2] Detecting function-level changes in ${changedFiles.length} files...`);\r\n  const functionChanges = await detectAllFunctionChanges(changedFiles, changeReport.manifest);\r\n\r\n  if (functionChanges.size === 0) {\r\n    console.log('\\n✓ No function-level changes detected!');\r\n    return;\r\n  }\r\n\r\n  printFunctionChangeSummary(functionChanges);\r\n\r\n  // Impact analysis (if enabled)\r\n  const config = loadConfig();\r\n  if (config.analysis?.trackDependencies) {\r\n    const changedFunctionNames = [];\r\n    for (const [filePath, changes] of functionChanges) {\r\n      changedFunctionNames.push(...changes.modified.map(f => f.name));\r\n      changedFunctionNames.push(...changes.added.map(f => f.name));\r\n      if (changes.renames) {\r\n        changedFunctionNames.push(...changes.renames.map(r => r.to));\r\n      }\r\n    }\r\n\r\n    if (changedFunctionNames.length > 0) {\r\n      try {\r\n        analyzeImpact(changedFunctionNames);\r\n      } catch (error) {\r\n        console.log(`\\nWarning: Impact analysis failed: ${error.message}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  console.log('\\n[3] Re-analyzing changed/added functions...');\r\n\r\n  const allNewEntries = [];\r\n  const analysisResults = new Map();\r\n\r\n  for (const [filePath, changes] of functionChanges) {\r\n    // Get names of functions to analyze (modified + added)\r\n    const targetFunctions = [\r\n      ...changes.modified.map(f => f.name),\r\n      ...changes.added.map(f => f.name)\r\n    ];\r\n\r\n    if (targetFunctions.length === 0) {\r\n      continue;\r\n    }\r\n\r\n    console.log(`    ${filePath}: analyzing ${targetFunctions.length} functions`);\r\n\r\n    try {\r\n      const result = await analyzeSpecificFunctions(filePath, targetFunctions);\r\n      analysisResults.set(filePath, result);\r\n      allNewEntries.push(...result.entries);\r\n\r\n      console.log(`      Found: ${result.entries.length} entries, ${result.analysisTime}ms`);\r\n      console.log(`      Skipped: ${result.totalFunctions - result.analyzedFunctions} unchanged functions`);\r\n    } catch (error) {\r\n      console.log(`      Error: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Update graph (function-level)\r\n  const updatedGraph = updateGraphFunctionLevel(functionChanges, allNewEntries);\r\n\r\n  // Update manifest (note: still need to update function hashes)\r\n  console.log('\\n[5] Updating manifest.json...');\r\n  const manifest = changeReport.manifest;\r\n  const storeSource = config.incremental?.storeSource || false;\r\n\r\n  for (const filePath of changedFiles) {\r\n    const hash = computeFileHash(filePath);\r\n    const metadata = getFileMetadata(filePath);\r\n\r\n    // Re-extract all function hashes for changed files\r\n    const { extractFileFunctions } = await import('../parser/manifest-generator.js');\r\n    const functionHashes = extractFileFunctions(filePath, storeSource);\r\n\r\n    if (manifest.files[filePath]) {\r\n      manifest.files[filePath].hash = hash;\r\n      manifest.files[filePath].size = metadata.size;\r\n      manifest.files[filePath].lastModified = metadata.lastModified;\r\n      manifest.files[filePath].functionHashes = functionHashes;\r\n    }\r\n\r\n    console.log(`    ✓ Updated: ${filePath}`);\r\n  }\r\n\r\n  // Update global stats\r\n  manifest.globalStats.totalFunctions = updatedGraph.length;\r\n  manifest.globalStats.totalCalls = updatedGraph.reduce((sum, f) => sum + (f.calls?.length || 0), 0);\r\n  manifest.generated = new Date().toISOString();\r\n\r\n  writeFileSync('.llm-context/manifest.json', JSON.stringify(manifest, null, 2));\r\n  console.log('    ✓ Manifest updated');\r\n\r\n  console.log('\\n=== Incremental Analysis Complete (Function-Level) ===');\r\n  console.log(`Functions re-analyzed: ${allNewEntries.length}`);\r\n  console.log(`Total functions in graph: ${updatedGraph.length}`);\r\n  console.log(`Total calls tracked: ${manifest.globalStats.totalCalls}`);\r\n}"
        },
        "mainFileLevel": {
          "hash": "85577e0b371c9a4c05036b94d439ad07",
          "line": 495,
          "endLine": 545,
          "size": 2038,
          "async": true,
          "language": "javascript",
          "source": "async function mainFileLevel() {\r\n  console.log('[1] Detecting changes...');\r\n  const changeReport = detectChanges();\r\n\r\n  if (changeReport.needsFullAnalysis) {\r\n    console.log('\\n⚠ No manifest found - run full analysis first:');\r\n    console.log('  1. node manifest-generator.js');\r\n    console.log('  2. Ensure graph.jsonl exists');\r\n    console.log('  3. Run this script again');\r\n    return;\r\n  }\r\n\r\n  const changedFiles = [...changeReport.added, ...changeReport.modified];\r\n\r\n  if (changedFiles.length === 0) {\r\n    console.log('\\n✓ No changes detected - all files up to date!');\r\n    return;\r\n  }\r\n\r\n  console.log(`\\n[2] Re-analyzing ${changedFiles.length} changed files...`);\r\n\r\n  const analysisResults = new Map();\r\n  const allNewEntries = [];\r\n\r\n  for (const filePath of changedFiles) {\r\n    console.log(`    Analyzing: ${filePath}`);\r\n    const result = await analyzeSingleFile(filePath);\r\n    analysisResults.set(filePath, result);\r\n    allNewEntries.push(...result.entries);\r\n  }\r\n\r\n  console.log(`\\n[3] Summary of re-analysis:`);\r\n  console.log(`    Files analyzed: ${changedFiles.length}`);\r\n  console.log(`    Functions found: ${allNewEntries.length}`);\r\n  console.log(`    Total time: ${Array.from(analysisResults.values()).reduce((sum, r) => sum + r.analysisTime, 0)}ms`);\r\n\r\n  // Update graph\r\n  const updatedGraph = updateGraph(changedFiles, allNewEntries);\r\n\r\n  // Update manifest\r\n  const updatedManifest = updateManifest(changeReport, analysisResults);\r\n\r\n  console.log('\\n=== Incremental Analysis Complete (File-Level) ===');\r\n  console.log(`Files re-analyzed: ${changedFiles.length}`);\r\n  console.log(`Files skipped: ${changeReport.unchanged.length}`);\r\n  console.log(`Total functions in graph: ${updatedGraph.length}`);\r\n  console.log(`Total calls tracked: ${updatedManifest.globalStats.totalCalls}`);\r\n\r\n  const percentSkipped = ((changeReport.unchanged.length / (changedFiles.length + changeReport.unchanged.length)) * 100).toFixed(1);\r\n  console.log(`\\n✓ Efficiency: ${percentSkipped}% of files skipped!`);\r\n}"
        },
        "main": {
          "hash": "da4ebf58e105a1514f265375c1504154",
          "line": 550,
          "endLine": 561,
          "size": 283,
          "async": true,
          "language": "javascript",
          "source": "async function main() {\r\n  const config = loadConfig();\r\n  const granularity = config.granularity || 'file';\r\n\r\n  console.log(`Granularity mode: ${granularity}\\n`);\r\n\r\n  if (granularity === 'function') {\r\n    await mainFunctionLevel();\r\n  } else {\r\n    await mainFileLevel();\r\n  }\r\n}"
        }
      }
    },
    "src/core/language-detector.js": {
      "hash": "a9d50733ec644a1bd725a7fcb3592789",
      "size": 8987,
      "lastModified": "2026-02-08T13:13:07.094Z",
      "functions": [
        "detectLanguages",
        "walk",
        "printLanguageReport",
        "shouldAnalyze"
      ],
      "analysisTime": null,
      "functionHashes": {
        "detectLanguages": {
          "hash": "c8de48776662299240b87b3d97019ceb",
          "line": 81,
          "endLine": 164,
          "size": 2293,
          "async": false,
          "language": "javascript",
          "source": "function detectLanguages(rootDir = '.') {\r\n  const isIgnored = parseGitignore();\r\n  const extensionCounts = new Map();\r\n  const sampleFiles = new Map(); // Store sample files for each extension\r\n\r\n  function walk(dir) {\r\n    try {\r\n      const entries = readdirSync(dir);\r\n\r\n      for (const entry of entries) {\r\n        const fullPath = join(dir, entry);\r\n        const stat = statSync(fullPath);\r\n        const isDirectory = stat.isDirectory();\r\n\r\n        // Skip if ignored\r\n        if (isIgnored(fullPath, isDirectory)) {\r\n          continue;\r\n        }\r\n\r\n        if (isDirectory) {\r\n          walk(fullPath);\r\n        } else {\r\n          const ext = extname(entry).toLowerCase();\r\n          if (ext) {\r\n            extensionCounts.set(ext, (extensionCounts.get(ext) || 0) + 1);\r\n\r\n            // Store sample files (up to 3 per extension)\r\n            if (!sampleFiles.has(ext)) {\r\n              sampleFiles.set(ext, []);\r\n            }\r\n            const samples = sampleFiles.get(ext);\r\n            if (samples.length < 3) {\r\n              samples.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      // Skip inaccessible directories\r\n    }\r\n  }\r\n\r\n  walk(rootDir);\r\n\r\n  // Analyze results\r\n  const languages = [];\r\n  const supported = [];\r\n  const unsupported = [];\r\n\r\n  for (const [ext, count] of extensionCounts.entries()) {\r\n    const info = LANGUAGE_INFO[ext];\r\n    const languageEntry = {\r\n      extension: ext,\r\n      count,\r\n      name: info?.name || 'Unknown',\r\n      supported: info?.supported || false,\r\n      isSource: info?.isSource ?? true,\r\n      samples: sampleFiles.get(ext) || []\r\n    };\r\n\r\n    languages.push(languageEntry);\r\n\r\n    if (languageEntry.isSource) {\r\n      if (languageEntry.supported) {\r\n        supported.push(languageEntry);\r\n      } else if (info) {\r\n        unsupported.push(languageEntry);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Sort by count (descending)\r\n  languages.sort((a, b) => b.count - a.count);\r\n  supported.sort((a, b) => b.count - a.count);\r\n  unsupported.sort((a, b) => b.count - a.count);\r\n\r\n  return {\r\n    all: languages,\r\n    supported,\r\n    unsupported,\r\n    hasUnsupported: unsupported.length > 0,\r\n    totalFiles: Array.from(extensionCounts.values()).reduce((sum, count) => sum + count, 0)\r\n  };\r\n}"
        },
        "walk": {
          "hash": "1a60f8b0c53d94e948e955d2d4ce37b0",
          "line": 86,
          "endLine": 121,
          "size": 995,
          "async": false,
          "language": "javascript",
          "source": "function walk(dir) {\r\n    try {\r\n      const entries = readdirSync(dir);\r\n\r\n      for (const entry of entries) {\r\n        const fullPath = join(dir, entry);\r\n        const stat = statSync(fullPath);\r\n        const isDirectory = stat.isDirectory();\r\n\r\n        // Skip if ignored\r\n        if (isIgnored(fullPath, isDirectory)) {\r\n          continue;\r\n        }\r\n\r\n        if (isDirectory) {\r\n          walk(fullPath);\r\n        } else {\r\n          const ext = extname(entry).toLowerCase();\r\n          if (ext) {\r\n            extensionCounts.set(ext, (extensionCounts.get(ext) || 0) + 1);\r\n\r\n            // Store sample files (up to 3 per extension)\r\n            if (!sampleFiles.has(ext)) {\r\n              sampleFiles.set(ext, []);\r\n            }\r\n            const samples = sampleFiles.get(ext);\r\n            if (samples.length < 3) {\r\n              samples.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      // Skip inaccessible directories\r\n    }\r\n  }"
        },
        "printLanguageReport": {
          "hash": "8abd5825dda10f7a3016d9e9a93c83db",
          "line": 169,
          "endLine": 217,
          "size": 2128,
          "async": false,
          "language": "javascript",
          "source": "function printLanguageReport(detection) {\r\n  console.log('📊 Language Detection Results\\n');\r\n  console.log(`   Total files found: ${detection.totalFiles}\\n`);\r\n\r\n  if (detection.supported.length > 0) {\r\n    console.log('✅ Supported Languages:');\r\n    for (const lang of detection.supported) {\r\n      console.log(`   ${lang.name.padEnd(25)} ${lang.count.toString().padStart(5)} files  (${lang.extension})`);\r\n      if (lang.samples.length > 0) {\r\n        console.log(`      Examples: ${lang.samples.slice(0, 2).join(', ')}`);\r\n      }\r\n    }\r\n    console.log();\r\n  }\r\n\r\n  if (detection.unsupported.length > 0) {\r\n    console.log('⚠️  Unsupported Languages (will be skipped):');\r\n    for (const lang of detection.unsupported) {\r\n      console.log(`   ${lang.name.padEnd(25)} ${lang.count.toString().padStart(5)} files  (${lang.extension})`);\r\n      if (lang.samples.length > 0) {\r\n        console.log(`      Examples: ${lang.samples.slice(0, 2).join(', ')}`);\r\n      }\r\n    }\r\n    console.log();\r\n    console.log('💡 These languages are not yet supported by tree-sitter parsers.');\r\n    console.log('   To add support, install the appropriate tree-sitter parser.\\n');\r\n  }\r\n\r\n  // Warn if unsupported languages are primary\r\n  if (detection.unsupported.length > 0 && detection.supported.length === 0) {\r\n    console.log('🚨 WARNING: No supported languages detected!');\r\n    console.log('   The project appears to use only unsupported languages.');\r\n    console.log('   Analysis will not produce useful results.\\n');\r\n    return false;\r\n  }\r\n\r\n  if (detection.unsupported.length > 0 && detection.supported.length > 0) {\r\n    const unsupportedTotal = detection.unsupported.reduce((sum, l) => sum + l.count, 0);\r\n    const supportedTotal = detection.supported.reduce((sum, l) => sum + l.count, 0);\r\n\r\n    if (unsupportedTotal > supportedTotal) {\r\n      console.log('⚠️  WARNING: Most source files are in unsupported languages!');\r\n      console.log(`   Unsupported: ${unsupportedTotal} files vs Supported: ${supportedTotal} files`);\r\n      console.log('   Analysis may miss the primary codebase.\\n');\r\n    }\r\n  }\r\n\r\n  return true;\r\n}"
        },
        "shouldAnalyze": {
          "hash": "2305568117828ef2ac036077b799ca11",
          "line": 222,
          "endLine": 234,
          "size": 362,
          "async": false,
          "language": "javascript",
          "source": "function shouldAnalyze(detection) {\r\n  // Don't analyze if no supported languages\r\n  if (detection.supported.length === 0) {\r\n    return false;\r\n  }\r\n\r\n  // Don't analyze if only supported files are JSON/config\r\n  const nonConfigSupported = detection.supported.filter(l =>\r\n    !['.json'].includes(l.extension)\r\n  );\r\n\r\n  return nonConfigSupported.length > 0;\r\n}"
        }
      }
    },
    "src/core/semantic-analyzer.js": {
      "hash": "e3c7c3e483acf3d310c44b7ccd16c428",
      "size": 2256,
      "lastModified": "2026-02-08T13:13:09.128Z",
      "functions": [
        "constructor",
        "analyze",
        "matchesTag",
        "createSemanticAnalyzer"
      ],
      "analysisTime": null,
      "functionHashes": {
        "constructor": {
          "hash": "cdb1cea2b51acf742d3dc61ea374dac5",
          "line": 32,
          "endLine": 35,
          "size": 112,
          "async": false,
          "language": "javascript",
          "source": "constructor(language) {\n    this.language = language;\n    this.patterns = SEMANTIC_PATTERNS[language] || {};\n  }"
        },
        "analyze": {
          "hash": "c6497be6fe0e3c10f64840d3dc177185",
          "line": 42,
          "endLine": 52,
          "size": 209,
          "async": false,
          "language": "javascript",
          "source": "analyze(source) {\n    const tags = [];\n\n    for (const [tag, config] of Object.entries(this.patterns)) {\n      if (this.matchesTag(source, config)) {\n        tags.push(tag);\n      }\n    }\n\n    return tags;\n  }"
        },
        "matchesTag": {
          "hash": "ffa8c6d386badb6814021f0f9017d82e",
          "line": 60,
          "endLine": 80,
          "size": 473,
          "async": false,
          "language": "javascript",
          "source": "matchesTag(source, config) {\n    // Check anti-patterns first\n    if (config.antiPatterns) {\n      for (const pattern of config.antiPatterns) {\n        if (new RegExp(pattern, 'm').test(source)) {\n          return false;\n        }\n      }\n    }\n\n    // Check positive patterns\n    if (config.patterns) {\n      for (const pattern of config.patterns) {\n        if (new RegExp(pattern, 'm').test(source)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }"
        },
        "createSemanticAnalyzer": {
          "hash": "91c13615ae823bee72729335432f3f6a",
          "line": 88,
          "endLine": 90,
          "size": 86,
          "async": false,
          "language": "javascript",
          "source": "function createSemanticAnalyzer(language) {\n  return new SemanticAnalyzer(language);\n}"
        }
      }
    },
    "src/core/side-effects-analyzer.js": {
      "hash": "eed83ac8984eac34cee71e8e1a5a7dfd",
      "size": 9007,
      "lastModified": "2026-02-08T13:13:11.098Z",
      "functions": [
        "constructor",
        "analyze",
        "analyzeCall",
        "detectEffect",
        "hasImport",
        "matchesCall",
        "matchesPattern",
        "deduplicateEffects",
        "addImport",
        "getEffectTypes",
        "filterByConfidence",
        "formatForOutput",
        "createAnalyzer",
        "analyzeSideEffects"
      ],
      "analysisTime": null,
      "functionHashes": {
        "constructor": {
          "hash": "e5ba6c9e63fc2e4caad277fbddf9952f",
          "line": 37,
          "endLine": 41,
          "size": 165,
          "async": false,
          "language": "javascript",
          "source": "constructor(language, imports = []) {\r\n    this.language = language;\r\n    this.imports = new Set(imports);\r\n    this.patterns = EFFECT_PATTERNS[language] || {};\r\n  }"
        },
        "analyze": {
          "hash": "85ff72785034b3d186c2fda6ee5fa61c",
          "line": 49,
          "endLine": 60,
          "size": 332,
          "async": false,
          "language": "javascript",
          "source": "analyze(calls, functionSource = '') {\r\n    const effects = [];\r\n\r\n    // Analyze each call\r\n    for (const call of calls) {\r\n      const callEffects = this.analyzeCall(call, functionSource);\r\n      effects.push(...callEffects);\r\n    }\r\n\r\n    // Deduplicate effects (same type + at)\r\n    return this.deduplicateEffects(effects);\r\n  }"
        },
        "analyzeCall": {
          "hash": "d462dfcfc8f71df2597f48add4557f14",
          "line": 69,
          "endLine": 88,
          "size": 529,
          "async": false,
          "language": "javascript",
          "source": "analyzeCall(call, context = '') {\r\n    const effects = [];\r\n    const effectTypes = ['file_io', 'network', 'logging', 'database', 'dom'];\r\n\r\n    for (const effectType of effectTypes) {\r\n      const patterns = this.patterns[effectType];\r\n      if (!patterns) continue;\r\n\r\n      const confidence = this.detectEffect(call, patterns, context);\r\n      if (confidence) {\r\n        effects.push({\r\n          type: effectType,\r\n          at: call,\r\n          confidence: confidence\r\n        });\r\n      }\r\n    }\r\n\r\n    return effects;\r\n  }"
        },
        "detectEffect": {
          "hash": "218150119d64a87db8b891e0703c9f35",
          "line": 98,
          "endLine": 139,
          "size": 1358,
          "async": false,
          "language": "javascript",
          "source": "detectEffect(call, patterns, context) {\r\n    // High confidence: Direct import match\r\n    if (patterns.imports && this.hasImport(patterns.imports)) {\r\n      if (this.matchesCall(call, patterns.calls)) {\r\n        return 'high';\r\n      }\r\n    }\r\n\r\n    // High confidence: Built-in/global function\r\n    if (patterns.builtins && patterns.builtins.some(b => call.includes(b))) {\r\n      return 'high';\r\n    }\r\n\r\n    if (patterns.globals && patterns.globals.some(g => context.includes(g))) {\r\n      return 'high';\r\n    }\r\n\r\n    // Medium confidence: Direct call match (no import verification)\r\n    if (patterns.calls && this.matchesCall(call, patterns.calls)) {\r\n      return 'medium';\r\n    }\r\n\r\n    // Medium confidence: Namespace match (e.g., fs.readFile, console.log)\r\n    if (patterns.namespaces && patterns.namespaces.some(ns => call.startsWith(ns + '.'))) {\r\n      return 'medium';\r\n    }\r\n\r\n    // Low confidence: Pattern/regex match\r\n    if (patterns.patterns && this.matchesPattern(call, patterns.patterns)) {\r\n      return 'low';\r\n    }\r\n\r\n    // C/C++ includes\r\n    if ((patterns.includes || patterns.requires || patterns.commands)) {\r\n      // These are matched differently, return medium confidence if call matches\r\n      if (patterns.calls && this.matchesCall(call, patterns.calls)) {\r\n        return 'medium';\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }"
        },
        "hasImport": {
          "hash": "c38c15725e3fa9f3ed25a35b11592c2e",
          "line": 147,
          "endLine": 157,
          "size": 330,
          "async": false,
          "language": "javascript",
          "source": "hasImport(requiredImports) {\r\n    for (const required of requiredImports) {\r\n      for (const imported of this.imports) {\r\n        // Exact match or starts with (for sub-modules)\r\n        if (imported === required || imported.startsWith(required + '/')) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }"
        },
        "matchesCall": {
          "hash": "e2afc9dbca7ac707339d6b5602f9b15d",
          "line": 166,
          "endLine": 181,
          "size": 447,
          "async": false,
          "language": "javascript",
          "source": "matchesCall(call, expectedCalls) {\r\n    if (!expectedCalls) return false;\r\n\r\n    for (const expected of expectedCalls) {\r\n      // Exact match\r\n      if (call === expected) return true;\r\n\r\n      // Method call (e.g., fs.readFile matches readFile)\r\n      if (call.includes('.' + expected)) return true;\r\n\r\n      // Partial match (e.g., readFileSync matches readFile)\r\n      if (call.includes(expected)) return true;\r\n    }\r\n\r\n    return false;\r\n  }"
        },
        "matchesPattern": {
          "hash": "a520490642f8de1a47ef223098c1c6ab",
          "line": 190,
          "endLine": 204,
          "size": 366,
          "async": false,
          "language": "javascript",
          "source": "matchesPattern(call, patterns) {\r\n    if (!patterns) return false;\r\n\r\n    for (const pattern of patterns) {\r\n      try {\r\n        const regex = new RegExp(pattern, 'i');\r\n        if (regex.test(call)) return true;\r\n      } catch (error) {\r\n        // Invalid regex, skip\r\n        console.warn(`Invalid pattern: ${pattern}`);\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }"
        },
        "deduplicateEffects": {
          "hash": "c72a51c6f0511078207e057fa11e45ef",
          "line": 212,
          "endLine": 232,
          "size": 566,
          "async": false,
          "language": "javascript",
          "source": "deduplicateEffects(effects) {\r\n    const seen = new Map();\r\n\r\n    for (const effect of effects) {\r\n      const key = `${effect.type}:${effect.at}`;\r\n\r\n      if (!seen.has(key)) {\r\n        seen.set(key, effect);\r\n      } else {\r\n        // Keep higher confidence\r\n        const existing = seen.get(key);\r\n        const confidenceOrder = { high: 3, medium: 2, low: 1 };\r\n\r\n        if (confidenceOrder[effect.confidence] > confidenceOrder[existing.confidence]) {\r\n          seen.set(key, effect);\r\n        }\r\n      }\r\n    }\r\n\r\n    return Array.from(seen.values());\r\n  }"
        },
        "addImport": {
          "hash": "b7cb63457d90f6f48719473de959a85d",
          "line": 238,
          "endLine": 240,
          "size": 63,
          "async": false,
          "language": "javascript",
          "source": "addImport(importPath) {\r\n    this.imports.add(importPath);\r\n  }"
        },
        "getEffectTypes": {
          "hash": "3f7d5acee06af35e001b2eb3ad41b3ed",
          "line": 247,
          "endLine": 249,
          "size": 89,
          "async": false,
          "language": "javascript",
          "source": "static getEffectTypes(effects) {\r\n    return [...new Set(effects.map(e => e.type))];\r\n  }"
        },
        "filterByConfidence": {
          "hash": "2c7242af47307d7d0686fec81acd738d",
          "line": 257,
          "endLine": 262,
          "size": 262,
          "async": false,
          "language": "javascript",
          "source": "static filterByConfidence(effects, minConfidence = 'low') {\r\n    const confidenceOrder = { low: 1, medium: 2, high: 3 };\r\n    const minLevel = confidenceOrder[minConfidence] || 1;\r\n\r\n    return effects.filter(e => confidenceOrder[e.confidence] >= minLevel);\r\n  }"
        },
        "formatForOutput": {
          "hash": "442b0041706a5d8d667633d0565f47e5",
          "line": 269,
          "endLine": 274,
          "size": 117,
          "async": false,
          "language": "javascript",
          "source": "static formatForOutput(effects) {\r\n    return effects.map(e => ({\r\n      type: e.type,\r\n      at: e.at\r\n    }));\r\n  }"
        },
        "createAnalyzer": {
          "hash": "9539ba32dbf7e5a557fd5d2016f2df8c",
          "line": 283,
          "endLine": 285,
          "size": 105,
          "async": false,
          "language": "javascript",
          "source": "function createAnalyzer(language, imports = []) {\r\n  return new SideEffectAnalyzer(language, imports);\r\n}"
        },
        "analyzeSideEffects": {
          "hash": "5b75667729231a586039b40cba873eab",
          "line": 295,
          "endLine": 298,
          "size": 198,
          "async": false,
          "language": "javascript",
          "source": "function analyzeSideEffects(language, calls, imports = [], functionSource = '') {\r\n  const analyzer = new SideEffectAnalyzer(language, imports);\r\n  return analyzer.analyze(calls, functionSource);\r\n}"
        }
      }
    },
    "src/index.js": {
      "hash": "45acccbc8b4cc5233026fd0db8d31e0d",
      "size": 13605,
      "lastModified": "2026-02-08T13:46:46.753Z",
      "functions": [
        "log",
        "getTreeSitterParserInfo",
        "getTreeSitterParserName",
        "installMissingParsers",
        "updateParserFactory"
      ],
      "analysisTime": null,
      "functionHashes": {
        "log": {
          "hash": "9959809b6f690c41b9e51b81f789ed9e",
          "line": 36,
          "endLine": 40,
          "size": 77,
          "async": false,
          "language": "javascript",
          "source": "function log(...args) {\r\n  if (!isQuiet) {\r\n    console.log(...args);\r\n  }\r\n}"
        },
        "getTreeSitterParserInfo": {
          "hash": "c22fc696ec50d96c73b2c2f53178fb84",
          "line": 43,
          "endLine": 72,
          "size": 2290,
          "async": false,
          "language": "javascript",
          "source": "function getTreeSitterParserInfo(extension) {\r\n  const parserMap = {\r\n    '.clj': { package: 'tree-sitter-clojure', language: 'clojure', extensions: ['.clj', '.cljs', '.cljc'] },\r\n    '.cljs': { package: 'tree-sitter-clojure', language: 'clojure', extensions: ['.clj', '.cljs', '.cljc'] },\r\n    '.cljc': { package: 'tree-sitter-clojure', language: 'clojure', extensions: ['.clj', '.cljs', '.cljc'] },\r\n    '.janet': null, // No tree-sitter parser available yet\r\n    '.elm': { package: 'tree-sitter-elm', language: 'elm', extensions: ['.elm'] },\r\n    '.ex': { package: 'tree-sitter-elixir', language: 'elixir', extensions: ['.ex', '.exs'] },\r\n    '.exs': { package: 'tree-sitter-elixir', language: 'elixir', extensions: ['.ex', '.exs'] },\r\n    '.erl': { package: 'tree-sitter-erlang', language: 'erlang', extensions: ['.erl', '.hrl'] },\r\n    '.hrl': { package: 'tree-sitter-erlang', language: 'erlang', extensions: ['.erl', '.hrl'] },\r\n    '.hs': { package: 'tree-sitter-haskell', language: 'haskell', extensions: ['.hs'] },\r\n    '.scala': { package: 'tree-sitter-scala', language: 'scala', extensions: ['.scala'] },\r\n    '.kt': { package: 'tree-sitter-kotlin', language: 'kotlin', extensions: ['.kt'] },\r\n    '.swift': { package: 'tree-sitter-swift', language: 'swift', extensions: ['.swift'] },\r\n    '.jl': { package: 'tree-sitter-julia', language: 'julia', extensions: ['.jl'] },\r\n    '.r': { package: 'tree-sitter-r', language: 'r', extensions: ['.r', '.R'] },\r\n    '.ml': { package: 'tree-sitter-ocaml', language: 'ocaml', extensions: ['.ml', '.mli'] },\r\n    '.mli': { package: 'tree-sitter-ocaml', language: 'ocaml', extensions: ['.ml', '.mli'] },\r\n    '.fs': null, // F# doesn't have official tree-sitter\r\n    '.rkt': { package: 'tree-sitter-racket', language: 'racket', extensions: ['.rkt'] },\r\n    '.lua': { package: 'tree-sitter-lua', language: 'lua', extensions: ['.lua'] },\r\n    '.zig': { package: 'tree-sitter-zig', language: 'zig', extensions: ['.zig'] },\r\n    '.nim': null,\r\n    '.cr': { package: 'tree-sitter-crystal', language: 'crystal', extensions: ['.cr'] },\r\n    '.d': { package: 'tree-sitter-d', language: 'd', extensions: ['.d'] },\r\n    '.dart': { package: 'tree-sitter-dart', language: 'dart', extensions: ['.dart'] },\r\n  };\r\n  return parserMap[extension] || null;\r\n}"
        },
        "getTreeSitterParserName": {
          "hash": "a6c3c45397ddb02ec33968b4f61e5299",
          "line": 75,
          "endLine": 78,
          "size": 133,
          "async": false,
          "language": "javascript",
          "source": "function getTreeSitterParserName(extension) {\r\n  const info = getTreeSitterParserInfo(extension);\r\n  return info?.package || null;\r\n}"
        },
        "installMissingParsers": {
          "hash": "be3fa38b82a1d7382ddec2a03ee0804c",
          "line": 81,
          "endLine": 154,
          "size": 2660,
          "async": true,
          "language": "javascript",
          "source": "async function installMissingParsers(unsupportedLanguages) {\r\n  const packagesToInstall = new Map(); // package -> [extensions]\r\n  const unavailableLanguages = [];\r\n\r\n  // Collect packages to install\r\n  for (const lang of unsupportedLanguages) {\r\n    const info = getTreeSitterParserInfo(lang.extension);\r\n    if (info) {\r\n      if (!packagesToInstall.has(info.package)) {\r\n        packagesToInstall.set(info.package, { language: info.language, extensions: info.extensions });\r\n      }\r\n    } else {\r\n      unavailableLanguages.push(lang);\r\n    }\r\n  }\r\n\r\n  if (packagesToInstall.size === 0) {\r\n    console.error('\\n❌ No installable parsers available for your languages.');\r\n    console.error('   These languages do not have tree-sitter parsers yet:');\r\n    for (const lang of unavailableLanguages) {\r\n      console.error(`   - ${lang.name}`);\r\n    }\r\n    console.error('\\n   Please file an issue to request support at:');\r\n    console.error('   https://github.com/devame/llm-context-tools/issues\\n');\r\n    return false;\r\n  }\r\n\r\n  // Show what will be installed\r\n  console.log('\\n📦 Available parser packages:\\n');\r\n  const packages = Array.from(packagesToInstall.keys());\r\n  for (const pkg of packages) {\r\n    const info = packagesToInstall.get(pkg);\r\n    console.log(`   ${pkg.padEnd(30)} → ${info.language} (${info.extensions.join(', ')})`);\r\n  }\r\n\r\n  if (unavailableLanguages.length > 0) {\r\n    console.log('\\n⚠️  Not available (will still be skipped):');\r\n    for (const lang of unavailableLanguages) {\r\n      console.log(`   ${lang.name.padEnd(30)} → No parser exists yet`);\r\n    }\r\n  }\r\n\r\n  // Show commands\r\n  const installCmd = `npm install --save-dev ${packages.join(' ')}`;\r\n  console.log('\\n🔧 Commands to run:\\n');\r\n  console.log(`   ${installCmd}\\n`);\r\n\r\n  // Prompt user\r\n  const shouldInstall = await promptYesNo('\\n📥 Install these parser packages now?');\r\n\r\n  if (!shouldInstall) {\r\n    console.log('\\n⚠️  Installation cancelled. Cannot proceed without language support.\\n');\r\n    return false;\r\n  }\r\n\r\n  // Install packages\r\n  console.log('\\n📥 Installing packages...\\n');\r\n  try {\r\n    execSync(installCmd, { stdio: 'inherit', cwd: process.cwd() });\r\n    console.log('\\n✅ Packages installed successfully!\\n');\r\n\r\n    // Update parser-factory.js\r\n    console.log('🔧 Updating parser configuration...\\n');\r\n    updateParserFactory(packagesToInstall);\r\n    console.log('✅ Parser configuration updated!\\n');\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.error('\\n❌ Installation failed:', error.message);\r\n    console.error('   You may need to install manually with:');\r\n    console.error(`   ${installCmd}\\n`);\r\n    return false;\r\n  }\r\n}"
        },
        "updateParserFactory": {
          "hash": "ba59f45a88fbb633768984f69bb38570",
          "line": 157,
          "endLine": 186,
          "size": 961,
          "async": false,
          "language": "javascript",
          "source": "function updateParserFactory(packagesToInstall) {\r\n  const parserFactoryPath = join(__dirname, 'parser-factory.js');\r\n  let content = readFileSync(parserFactoryPath, 'utf-8');\r\n\r\n  // Add to GRAMMAR_PATHS\r\n  for (const [pkg, info] of packagesToInstall) {\r\n    const grammarEntry = `  ${info.language}: '${pkg}',`;\r\n\r\n    // Check if already exists\r\n    if (!content.includes(`${info.language}:`)) {\r\n      // Add before the closing brace of GRAMMAR_PATHS\r\n      content = content.replace(\r\n        /(const GRAMMAR_PATHS = \\{[^}]+)(}\\;)/,\r\n        `$1  ${info.language}: '${pkg}',\\n$2`\r\n      );\r\n    }\r\n\r\n    // Add extensions to EXTENSION_MAP\r\n    for (const ext of info.extensions) {\r\n      if (!content.includes(`'${ext}':`)) {\r\n        content = content.replace(\r\n          /(const EXTENSION_MAP = \\{[^}]+)(}\\;)/,\r\n          `$1  '${ext}': '${info.language}',\\n$2`\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  writeFileSync(parserFactoryPath, content, 'utf-8');\r\n}"
        }
      }
    },
    "src/parser/ast-adapter.js": {
      "hash": "abaaa92a06e883f52c5041d3e1d553a3",
      "size": 8521,
      "lastModified": "2026-02-08T13:29:33.131Z",
      "functions": [
        "constructor",
        "extractFunctions",
        "extractFunctionMetadata",
        "extractCallGraph",
        "extractImports",
        "isAsyncFunction",
        "isGeneratorFunction",
        "hashFunctionSource",
        "extractFunctionsWithNodes",
        "extractSourceByLines",
        "createAdapter"
      ],
      "analysisTime": null,
      "functionHashes": {
        "constructor": {
          "hash": "764c8b37c63279fa428871490f4b1575",
          "line": 22,
          "endLine": 29,
          "size": 300,
          "async": false,
          "language": "javascript",
          "source": "constructor(tree, language, sourceCode, filePath) {\r\n    this.tree = tree;\r\n    this.language = language;\r\n    this.sourceCode = sourceCode;\r\n    this.filePath = filePath;\r\n    this.rootNode = tree.rootNode;\r\n    this.languageObj = tree.getLanguage();  // Tree-sitter Language object for queries\r\n  }"
        },
        "extractFunctions": {
          "hash": "ec7021244ec6a3660b74fa44dc7138b9",
          "line": 35,
          "endLine": 60,
          "size": 731,
          "async": false,
          "language": "javascript",
          "source": "extractFunctions() {\r\n    const functionQuery = getFunctionQuery(this.language);\r\n    if (!functionQuery || functionQuery.trim() === '') {\r\n      // Language doesn't have functions (e.g., JSON)\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const query = this.languageObj.query(functionQuery);\r\n      const matches = query.matches(this.rootNode);\r\n\r\n      const functions = [];\r\n\r\n      for (const match of matches) {\r\n        const metadata = this.extractFunctionMetadata(match);\r\n        if (metadata) {\r\n          functions.push(metadata);\r\n        }\r\n      }\r\n\r\n      return functions;\r\n    } catch (error) {\r\n      console.warn(`Failed to extract functions for ${this.language}: ${error.message}`);\r\n      return [];\r\n    }\r\n  }"
        },
        "extractFunctionMetadata": {
          "hash": "cb3db3d5a1d5149b508ee1982b40f3a0",
          "line": 68,
          "endLine": 126,
          "size": 1796,
          "async": false,
          "language": "javascript",
          "source": "extractFunctionMetadata(match) {\r\n    const captures = {};\r\n\r\n    // Organize captures by name\r\n    for (const capture of match.captures) {\r\n      captures[capture.name] = capture.node;\r\n    }\r\n\r\n    const functionNode = captures.function;\r\n    if (!functionNode) {\r\n      return null;\r\n    }\r\n\r\n    // Extract function name\r\n    const nameNode = captures.name;\r\n    const funcName = nameNode ? nameNode.text : 'anonymous';\r\n\r\n    // Extract parameters\r\n    const paramsNode = captures.params;\r\n    const params = paramsNode ? paramsNode.text : '';\r\n\r\n    // Extract function body\r\n    const bodyNode = captures.body || functionNode;\r\n\r\n    // Get location information\r\n    const startLine = functionNode.startPosition.row + 1;  // Tree-sitter uses 0-based rows\r\n    const endLine = functionNode.endPosition.row + 1;\r\n    const startCol = functionNode.startPosition.column;\r\n    const endCol = functionNode.endPosition.column;\r\n\r\n    // Extract source code\r\n    const source = functionNode.text;\r\n\r\n    // Compute hash\r\n    const hash = this.hashFunctionSource(source);\r\n\r\n    // Check for async/generator markers (JavaScript/TypeScript specific)\r\n    const isAsync = this.isAsyncFunction(functionNode);\r\n    const isGenerator = this.isGeneratorFunction(functionNode);\r\n\r\n    // Generate unique ID\r\n    const funcId = `${this.filePath}#${funcName}`;\r\n\r\n    return {\r\n      id: funcId,\r\n      name: funcName,\r\n      line: startLine,\r\n      endLine: endLine,\r\n      source: source,\r\n      hash: hash,\r\n      size: source.length,\r\n      params: params,\r\n      isAsync: isAsync,\r\n      isGenerator: isGenerator,\r\n      language: this.language,\r\n      node: functionNode,  // Keep reference for further analysis\r\n      bodyNode: bodyNode   // Keep body reference for call graph extraction\r\n    };\r\n  }"
        },
        "extractCallGraph": {
          "hash": "3c708b8795e689aa6ee412eeac7d5c77",
          "line": 133,
          "endLine": 162,
          "size": 763,
          "async": false,
          "language": "javascript",
          "source": "extractCallGraph(functionMetadata) {\r\n    if (!functionMetadata.bodyNode) {\r\n      return [];\r\n    }\r\n\r\n    const callQuery = getCallQuery(this.language);\r\n    if (!callQuery || callQuery.trim() === '') {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const query = this.languageObj.query(callQuery);\r\n      const matches = query.matches(functionMetadata.bodyNode);\r\n\r\n      const calls = new Set();\r\n\r\n      for (const match of matches) {\r\n        for (const capture of match.captures) {\r\n          if (capture.name === 'call') {\r\n            calls.add(capture.node.text);\r\n          }\r\n        }\r\n      }\r\n\r\n      return Array.from(calls);\r\n    } catch (error) {\r\n      console.warn(`Failed to extract call graph: ${error.message}`);\r\n      return [];\r\n    }\r\n  }"
        },
        "extractImports": {
          "hash": "b232c94d8fd67a0d7a1fd774182c3f4e",
          "line": 168,
          "endLine": 196,
          "size": 841,
          "async": false,
          "language": "javascript",
          "source": "extractImports() {\r\n    const importQuery = getImportQuery(this.language);\r\n    if (!importQuery || importQuery.trim() === '') {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const query = this.languageObj.query(importQuery);\r\n      const matches = query.matches(this.rootNode);\r\n\r\n      const imports = new Set();\r\n\r\n      for (const match of matches) {\r\n        for (const capture of match.captures) {\r\n          if (capture.name === 'source') {\r\n            // Remove quotes from string literals\r\n            let importPath = capture.node.text;\r\n            importPath = importPath.replace(/^['\"]|['\"]$/g, '');\r\n            imports.add(importPath);\r\n          }\r\n        }\r\n      }\r\n\r\n      return Array.from(imports);\r\n    } catch (error) {\r\n      console.warn(`Failed to extract imports: ${error.message}`);\r\n      return [];\r\n    }\r\n  }"
        },
        "isAsyncFunction": {
          "hash": "0abd30e7d89b56f1ac9ba1c2df8fce5f",
          "line": 204,
          "endLine": 213,
          "size": 366,
          "async": false,
          "language": "javascript",
          "source": "isAsyncFunction(node) {\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n      return false;\r\n    }\r\n\r\n    // Check if node has 'async' keyword\r\n    // This is a heuristic check - Tree-sitter nodes don't always expose this directly\r\n    const source = node.text;\r\n    return /^\\s*async\\s+(function|[\\w]+\\s*=>|\\(.*\\)\\s*=>)/.test(source);\r\n  }"
        },
        "isGeneratorFunction": {
          "hash": "63239ce5258a9a475d7e3b03beb0a2d6",
          "line": 221,
          "endLine": 229,
          "size": 291,
          "async": false,
          "language": "javascript",
          "source": "isGeneratorFunction(node) {\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n      return false;\r\n    }\r\n\r\n    // Check if node has generator marker (*)\r\n    const source = node.text;\r\n    return /^\\s*function\\s*\\*/.test(source) || /\\*\\s*\\w+\\s*\\(/.test(source);\r\n  }"
        },
        "hashFunctionSource": {
          "hash": "c621bba34f565862e1708fed082a7f78",
          "line": 237,
          "endLine": 241,
          "size": 198,
          "async": false,
          "language": "javascript",
          "source": "hashFunctionSource(source) {\r\n    // Normalize source (remove leading/trailing whitespace)\r\n    const normalized = source.trim();\r\n    return createHash('md5').update(normalized).digest('hex');\r\n  }"
        },
        "extractFunctionsWithNodes": {
          "hash": "27b406b2cccbcbc782894001570c3207",
          "line": 247,
          "endLine": 254,
          "size": 213,
          "async": false,
          "language": "javascript",
          "source": "extractFunctionsWithNodes() {\r\n    const functions = this.extractFunctions();\r\n    return functions.map(metadata => ({\r\n      metadata,\r\n      node: metadata.node,\r\n      bodyNode: metadata.bodyNode\r\n    }));\r\n  }"
        },
        "extractSourceByLines": {
          "hash": "c99e8a10e6e2186545eafd3f8446efc7",
          "line": 262,
          "endLine": 265,
          "size": 155,
          "async": false,
          "language": "javascript",
          "source": "extractSourceByLines(startLine, endLine) {\r\n    const lines = this.sourceCode.split('\\n');\r\n    return lines.slice(startLine - 1, endLine).join('\\n');\r\n  }"
        },
        "createAdapter": {
          "hash": "b13ec9929d64f1afa7c4df21400cba3a",
          "line": 276,
          "endLine": 278,
          "size": 129,
          "async": false,
          "language": "javascript",
          "source": "function createAdapter(tree, language, sourceCode, filePath) {\r\n  return new ASTAdapter(tree, language, sourceCode, filePath);\r\n}"
        }
      }
    },
    "src/parser/gitignore-parser.js": {
      "hash": "9dfa95102526102df14834ebcc3f717f",
      "size": 4820,
      "lastModified": "2026-02-08T13:31:05.295Z",
      "functions": [
        "parseGitignore",
        "createMatcher",
        "patternToRegex",
        "createDefaultIgnoreChecker"
      ],
      "analysisTime": null,
      "functionHashes": {
        "parseGitignore": {
          "hash": "81922d4704f7271f7a9caa5f407ebe0a",
          "line": 65,
          "endLine": 85,
          "size": 518,
          "async": false,
          "language": "javascript",
          "source": "function parseGitignore(gitignorePath = '.gitignore') {\r\n  const patterns = [...DEFAULT_IGNORE_PATTERNS];\r\n\r\n  if (existsSync(gitignorePath)) {\r\n    const content = readFileSync(gitignorePath, 'utf-8');\r\n    const lines = content.split('\\n');\r\n\r\n    for (const line of lines) {\r\n      const trimmed = line.trim();\r\n\r\n      // Skip empty lines and comments\r\n      if (!trimmed || trimmed.startsWith('#')) {\r\n        continue;\r\n      }\r\n\r\n      patterns.push(trimmed);\r\n    }\r\n  }\r\n\r\n  return createMatcher(patterns);\r\n}"
        },
        "createMatcher": {
          "hash": "cb03216910ca44ffdc700cc0749841d0",
          "line": 90,
          "endLine": 150,
          "size": 1865,
          "async": false,
          "language": "javascript",
          "source": "function createMatcher(patterns) {\r\n  const rules = patterns.map(pattern => {\r\n    const negated = pattern.startsWith('!');\r\n    const cleanPattern = negated ? pattern.slice(1) : pattern;\r\n    const isDirectory = cleanPattern.endsWith('/');\r\n    const matchPattern = isDirectory ? cleanPattern.slice(0, -1) : cleanPattern;\r\n\r\n    return {\r\n      pattern: matchPattern,\r\n      negated,\r\n      isDirectory,\r\n      regex: patternToRegex(matchPattern)\r\n    };\r\n  });\r\n\r\n  /**\r\n   * Test if a path should be ignored\r\n   * @param {string} filePath - Path to test (relative or absolute)\r\n   * @param {boolean} isDirectory - Whether the path is a directory\r\n   * @returns {boolean} - true if the path should be ignored\r\n   */\r\n  return function isIgnored(filePath, isDirectory = false) {\r\n    // Normalize path to use forward slashes\r\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\r\n    const pathParts = normalizedPath.split('/').filter(p => p && p !== '.');\r\n\r\n    let ignored = false;\r\n\r\n    for (const rule of rules) {\r\n      // Skip directory-specific rules if testing a file\r\n      if (rule.isDirectory && !isDirectory) {\r\n        continue;\r\n      }\r\n\r\n      // Test against full path\r\n      if (rule.regex.test(normalizedPath)) {\r\n        ignored = !rule.negated;\r\n        continue;\r\n      }\r\n\r\n      // Test against any path segment (for patterns like \"node_modules\")\r\n      for (const part of pathParts) {\r\n        if (rule.regex.test(part)) {\r\n          ignored = !rule.negated;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Test against relative segments (for patterns like \"dist/build\")\r\n      for (let i = 0; i < pathParts.length; i++) {\r\n        const segment = pathParts.slice(i).join('/');\r\n        if (rule.regex.test(segment)) {\r\n          ignored = !rule.negated;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return ignored;\r\n  };\r\n}"
        },
        "patternToRegex": {
          "hash": "e6e01d433178ec57e1d351fa45a22c64",
          "line": 155,
          "endLine": 187,
          "size": 933,
          "async": false,
          "language": "javascript",
          "source": "function patternToRegex(pattern) {\r\n  let regex = pattern;\r\n\r\n  // Escape special regex characters except * and ?\r\n  regex = regex.replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&');\r\n\r\n  // Handle **/ (matches zero or more directories)\r\n  regex = regex.replace(/\\*\\*\\//g, '(?:.*\\/)?');\r\n\r\n  // Handle /** (matches all nested files/dirs)\r\n  regex = regex.replace(/\\/\\*\\*/g, '(?:\\/.*)?');\r\n\r\n  // Handle * (matches anything except /)\r\n  regex = regex.replace(/\\*/g, '[^/]*');\r\n\r\n  // Handle ? (matches single character)\r\n  regex = regex.replace(/\\?/g, '[^/]');\r\n\r\n  // Anchor the pattern\r\n  // If pattern doesn't start with /, it can match anywhere\r\n  if (!pattern.startsWith('/')) {\r\n    regex = '(?:^|/)' + regex;\r\n  } else {\r\n    regex = '^' + regex.slice(1);\r\n  }\r\n\r\n  // If pattern doesn't end with /, add end anchor or allow trailing path\r\n  if (!pattern.endsWith('*')) {\r\n    regex = regex + '(?:$|/)';\r\n  }\r\n\r\n  return new RegExp(regex);\r\n}"
        },
        "createDefaultIgnoreChecker": {
          "hash": "5fa1753333b2d341ce29a725b2169fb5",
          "line": 192,
          "endLine": 194,
          "size": 111,
          "async": false,
          "language": "javascript",
          "source": "function createDefaultIgnoreChecker(gitignorePath = '.gitignore') {\r\n  return parseGitignore(gitignorePath);\r\n}"
        }
      }
    },
    "src/parser/manifest-generator.js": {
      "hash": "95f1ccbbef2528ad70b65ca5ec19f9cf",
      "size": 9215,
      "lastModified": "2026-02-08T13:05:53.767Z",
      "functions": [
        "loadConfig",
        "computeFileHash",
        "getFileMetadata",
        "extractFileFunctions",
        "findJsFiles",
        "walk",
        "loadGraphData",
        "generateManifest",
        "saveManifest",
        "main"
      ],
      "analysisTime": null,
      "functionHashes": {
        "loadConfig": {
          "hash": "0c0590b9466c2c3ddeec8f6e2f31c61f",
          "line": 26,
          "endLine": 38,
          "size": 310,
          "async": false,
          "language": "javascript",
          "source": "function loadConfig() {\r\n  const configPath = './llm-context.config.json';\r\n\r\n  if (!existsSync(configPath)) {\r\n    // Default config\r\n    return {\r\n      granularity: 'file',\r\n      incremental: { enabled: true, hashAlgorithm: 'md5' }\r\n    };\r\n  }\r\n\r\n  return JSON.parse(readFileSync(configPath, 'utf-8'));\r\n}"
        },
        "computeFileHash": {
          "hash": "b62e98f7bf6d9f8483abb37a86b85f59",
          "line": 45,
          "endLine": 48,
          "size": 141,
          "async": false,
          "language": "javascript",
          "source": "function computeFileHash(filePath) {\r\n  const content = readFileSync(filePath);\r\n  return createHash('md5').update(content).digest('hex');\r\n}"
        },
        "getFileMetadata": {
          "hash": "bf688e494f0c96c3acf2ef82db6cc11f",
          "line": 55,
          "endLine": 61,
          "size": 162,
          "async": false,
          "language": "javascript",
          "source": "function getFileMetadata(filePath) {\r\n  const stats = statSync(filePath);\r\n  return {\r\n    size: stats.size,\r\n    lastModified: stats.mtime.toISOString()\r\n  };\r\n}"
        },
        "extractFileFunctions": {
          "hash": "2db6d771b9629316ed18d312818ffb28",
          "line": 69,
          "endLine": 112,
          "size": 1276,
          "async": true,
          "language": "javascript",
          "source": "async function extractFileFunctions(filePath, includeSource = false) {\r\n  const functionMap = {};\r\n\r\n  try {\r\n    const source = readFileSync(filePath, 'utf-8');\r\n\r\n    // Detect language and parse with Tree-sitter\r\n    const language = ParserFactory.detectLanguage(filePath);\r\n    if (!language) {\r\n      console.log(`    Warning: Unsupported file type: ${filePath}`);\r\n      return functionMap;\r\n    }\r\n\r\n    const { tree } = await ParserFactory.parseFile(filePath);\r\n    const adapter = createAdapter(tree, language, source, filePath);\r\n\r\n    // Extract all functions\r\n    const functions = adapter.extractFunctions();\r\n\r\n    // Build map\r\n    for (const metadata of functions) {\r\n      const funcEntry = {\r\n        hash: metadata.hash,\r\n        line: metadata.line,\r\n        endLine: metadata.endLine,\r\n        size: metadata.size,\r\n        async: metadata.isAsync,\r\n        language: language  // NEW: Include language\r\n      };\r\n\r\n      // Optionally include source for rename detection and diffs\r\n      if (includeSource) {\r\n        funcEntry.source = metadata.source;\r\n      }\r\n\r\n      functionMap[metadata.name] = funcEntry;\r\n    }\r\n\r\n  } catch (error) {\r\n    console.log(`    Warning: Could not parse ${filePath}: ${error.message}`);\r\n  }\r\n\r\n  return functionMap;\r\n}"
        },
        "findJsFiles": {
          "hash": "94f4559ea54b1420edb837a5ab3b4fb8",
          "line": 124,
          "endLine": 154,
          "size": 832,
          "async": false,
          "language": "javascript",
          "source": "function findJsFiles(dir = '.') {\r\n  const files = [];\r\n  const isIgnored = parseGitignore();\r\n\r\n  function walk(currentDir) {\r\n    const entries = readdirSync(currentDir, { withFileTypes: true });\r\n\r\n    for (const entry of entries) {\r\n      const fullPath = join(currentDir, entry.name);\r\n      const relativePath = relative('.', fullPath);\r\n      const isDirectory = entry.isDirectory();\r\n\r\n      // Skip if ignored by .gitignore or default patterns\r\n      if (isIgnored(relativePath, isDirectory)) {\r\n        continue;\r\n      }\r\n\r\n      if (isDirectory) {\r\n        walk(fullPath);\r\n      } else if (entry.isFile()) {\r\n        const ext = extname(entry.name).toLowerCase();\r\n        if (SUPPORTED_EXTENSIONS.includes(ext)) {\r\n          files.push(relativePath);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  walk(dir);\r\n  return files;\r\n}"
        },
        "walk": {
          "hash": "14fab8e0b1f6fe79d0a28f7d1e0e02df",
          "line": 128,
          "endLine": 150,
          "size": 697,
          "async": false,
          "language": "javascript",
          "source": "function walk(currentDir) {\r\n    const entries = readdirSync(currentDir, { withFileTypes: true });\r\n\r\n    for (const entry of entries) {\r\n      const fullPath = join(currentDir, entry.name);\r\n      const relativePath = relative('.', fullPath);\r\n      const isDirectory = entry.isDirectory();\r\n\r\n      // Skip if ignored by .gitignore or default patterns\r\n      if (isIgnored(relativePath, isDirectory)) {\r\n        continue;\r\n      }\r\n\r\n      if (isDirectory) {\r\n        walk(fullPath);\r\n      } else if (entry.isFile()) {\r\n        const ext = extname(entry.name).toLowerCase();\r\n        if (SUPPORTED_EXTENSIONS.includes(ext)) {\r\n          files.push(relativePath);\r\n        }\r\n      }\r\n    }\r\n  }"
        },
        "loadGraphData": {
          "hash": "a0429172b23c8f91f1f4d1031eee5eb1",
          "line": 160,
          "endLine": 183,
          "size": 632,
          "async": false,
          "language": "javascript",
          "source": "function loadGraphData() {\r\n  const graphPath = '.llm-context/graph.jsonl';\r\n  const fileToFunctions = new Map();\r\n\r\n  if (!existsSync(graphPath)) {\r\n    console.log('No existing graph.jsonl found - this will be the initial analysis');\r\n    return fileToFunctions;\r\n  }\r\n\r\n  const lines = readFileSync(graphPath, 'utf-8').split('\\n').filter(Boolean);\r\n\r\n  for (const line of lines) {\r\n    const func = JSON.parse(line);\r\n    const file = func.file;\r\n\r\n    if (!fileToFunctions.has(file)) {\r\n      fileToFunctions.set(file, []);\r\n    }\r\n\r\n    fileToFunctions.get(file).push(func.id || func.name);\r\n  }\r\n\r\n  return fileToFunctions;\r\n}"
        },
        "generateManifest": {
          "hash": "98c14ae683f2a69f54ed4755be4b701f",
          "line": 189,
          "endLine": 277,
          "size": 3033,
          "async": true,
          "language": "javascript",
          "source": "async function generateManifest() {\r\n  const config = loadConfig();\r\n  const granularity = config.granularity || 'file';\r\n\r\n  console.log(`[1] Configuration: granularity=${granularity}`);\r\n  console.log('[2] Discovering source files...');\r\n  const jsFiles = findJsFiles();\r\n  console.log(`    Found ${jsFiles.length} source files\\n`);\r\n\r\n  console.log('[3] Computing file hashes...');\r\n  const fileToFunctions = loadGraphData();\r\n  const files = {};\r\n  let totalSize = 0;\r\n\r\n  for (const filePath of jsFiles) {\r\n    try {\r\n      const hash = computeFileHash(filePath);\r\n      const metadata = getFileMetadata(filePath);\r\n      const graphFunctions = fileToFunctions.get(filePath) || [];\r\n\r\n      const fileEntry = {\r\n        hash,\r\n        size: metadata.size,\r\n        lastModified: metadata.lastModified,\r\n        functions: graphFunctions,\r\n        analysisTime: null\r\n      };\r\n\r\n      // Add function-level hashes if granularity is 'function'\r\n      if (granularity === 'function') {\r\n        const storeSource = config.incremental?.storeSource || false;\r\n        const functionMetadata = await extractFileFunctions(filePath, storeSource);\r\n        fileEntry.functionHashes = functionMetadata;\r\n\r\n        console.log(`    ${filePath}`);\r\n        console.log(`      File hash: ${hash.substring(0, 12)}...`);\r\n        console.log(`      Functions: ${Object.keys(functionMetadata).length}`);\r\n\r\n        // Show first few function hashes\r\n        const funcNames = Object.keys(functionMetadata).slice(0, 3);\r\n        for (const name of funcNames) {\r\n          const fHash = functionMetadata[name].hash.substring(0, 8);\r\n          console.log(`        - ${name} (${fHash}...)`);\r\n        }\r\n        if (Object.keys(functionMetadata).length > 3) {\r\n          console.log(`        ... and ${Object.keys(functionMetadata).length - 3} more`);\r\n        }\r\n      } else {\r\n        console.log(`    ${filePath}`);\r\n        console.log(`      Hash: ${hash.substring(0, 12)}...`);\r\n        console.log(`      Functions: ${graphFunctions.length > 0 ? graphFunctions.join(', ') : 'none yet'}`);\r\n      }\r\n\r\n      files[filePath] = fileEntry;\r\n      totalSize += metadata.size;\r\n\r\n    } catch (error) {\r\n      console.log(`    Warning: Could not process ${filePath}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  console.log(`\\n[4] Building manifest...`);\r\n\r\n  // Load global stats from graph if available\r\n  let globalStats = {\r\n    totalFunctions: 0,\r\n    totalCalls: 0,\r\n    totalFiles: jsFiles.length,\r\n    totalSize\r\n  };\r\n\r\n  if (existsSync('.llm-context/graph.jsonl')) {\r\n    const lines = readFileSync('.llm-context/graph.jsonl', 'utf-8').split('\\n').filter(Boolean);\r\n    const functions = lines.map(line => JSON.parse(line));\r\n\r\n    globalStats.totalFunctions = functions.length;\r\n    globalStats.totalCalls = functions.reduce((sum, f) => sum + (f.calls?.length || 0), 0);\r\n  }\r\n\r\n  const manifest = {\r\n    version: '2.0.0',\r\n    granularity,\r\n    generated: new Date().toISOString(),\r\n    files,\r\n    globalStats\r\n  };\r\n\r\n  return manifest;\r\n}"
        },
        "saveManifest": {
          "hash": "8611ff4803654892098f8f606ca5b566",
          "line": 283,
          "endLine": 295,
          "size": 637,
          "async": false,
          "language": "javascript",
          "source": "function saveManifest(manifest) {\r\n  const manifestPath = '.llm-context/manifest.json';\r\n  writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));\r\n  console.log(`\\n✓ Manifest saved to ${manifestPath}`);\r\n\r\n  // Print summary\r\n  console.log('\\n=== Manifest Summary ===');\r\n  console.log(`Files tracked: ${Object.keys(manifest.files).length}`);\r\n  console.log(`Total size: ${(manifest.globalStats.totalSize / 1024).toFixed(1)} KB`);\r\n  console.log(`Functions: ${manifest.globalStats.totalFunctions}`);\r\n  console.log(`Call relationships: ${manifest.globalStats.totalCalls}`);\r\n  console.log(`Generated: ${manifest.generated}`);\r\n}"
        },
        "main": {
          "hash": "02e7cc12be1785212a9c1d8be46c9c23",
          "line": 300,
          "endLine": 303,
          "size": 99,
          "async": true,
          "language": "javascript",
          "source": "async function main() {\r\n  const manifest = await generateManifest();\r\n  saveManifest(manifest);\r\n}"
        }
      }
    },
    "src/parser/parser-factory.js": {
      "hash": "73e79c3e292b0e1fb53237b6162b585c",
      "size": 5967,
      "lastModified": "2026-02-08T13:29:15.181Z",
      "functions": [
        "initializeParser",
        "createParser",
        "detectLanguage",
        "getSupportedLanguages",
        "isLanguageSupported",
        "parse",
        "parseFile",
        "clearCache"
      ],
      "analysisTime": null,
      "functionHashes": {
        "initializeParser": {
          "hash": "2e3b94f04205f8a148193f70b16da0c7",
          "line": 82,
          "endLine": 87,
          "size": 129,
          "async": true,
          "language": "javascript",
          "source": "async function initializeParser() {\r\n  if (!parserInitialized) {\r\n    await Parser.init();\r\n    parserInitialized = true;\r\n  }\r\n}"
        },
        "createParser": {
          "hash": "238fbeacc83af7a32d8f6d19e4203970",
          "line": 98,
          "endLine": 153,
          "size": 1726,
          "async": false,
          "language": "javascript",
          "source": "static async createParser(language) {\r\n    if (!language) {\r\n      throw new Error('Language is required');\r\n    }\r\n\r\n    // Return cached parser if available\r\n    if (parserCache.has(language)) {\r\n      return parserCache.get(language);\r\n    }\r\n\r\n    // Initialize Tree-sitter WASM\r\n    await initializeParser();\r\n\r\n    // Get grammar path\r\n    const grammarPath = GRAMMAR_PATHS[language];\r\n    if (!grammarPath) {\r\n      throw new Error(`Unsupported language: ${language}. Use getSupportedLanguages() to see available languages.`);\r\n    }\r\n\r\n    // Create parser instance\r\n    const parser = new Parser();\r\n\r\n    try {\r\n      // Load language grammar (WASM)\r\n      // Construct WASM filename from grammar path\r\n      let wasmFile;\r\n      if (language === 'tsx' || language === 'typescript') {\r\n        // TypeScript has separate tsx and typescript grammars\r\n        wasmFile = `tree-sitter-${language}.wasm`;\r\n      } else if (language === 'janet') {\r\n        // Janet uses tree-sitter-janet_simple.wasm\r\n        wasmFile = 'tree-sitter-janet_simple.wasm';\r\n      } else {\r\n        // For most languages: tree-sitter-javascript/tree-sitter-javascript.wasm\r\n        const packageName = grammarPath.split('/').pop();\r\n        wasmFile = `${packageName}.wasm`;\r\n      }\r\n\r\n      const wasmPath = join(\r\n        __dirname,\r\n        '../../node_modules',\r\n        grammarPath,\r\n        wasmFile\r\n      );\r\n\r\n      const languageGrammar = await Parser.Language.load(wasmPath);\r\n      parser.setLanguage(languageGrammar);\r\n\r\n      // Cache parser\r\n      parserCache.set(language, parser);\r\n\r\n      return parser;\r\n    } catch (error) {\r\n      throw new Error(`Failed to load grammar for ${language}: ${error.message}`);\r\n    }\r\n  }"
        },
        "detectLanguage": {
          "hash": "14e0e42db79e2e9ea5df6abb5a4d79b9",
          "line": 160,
          "endLine": 163,
          "size": 128,
          "async": false,
          "language": "javascript",
          "source": "static detectLanguage(filePath) {\r\n    const ext = extname(filePath).toLowerCase();\r\n    return EXTENSION_MAP[ext] || null;\r\n  }"
        },
        "getSupportedLanguages": {
          "hash": "c8785231f66e14090d05c8649c05e73d",
          "line": 169,
          "endLine": 171,
          "size": 77,
          "async": false,
          "language": "javascript",
          "source": "static getSupportedLanguages() {\r\n    return Object.keys(GRAMMAR_PATHS);\r\n  }"
        },
        "isLanguageSupported": {
          "hash": "1d97e2c3be3c8d9f99e5a8ace0a67409",
          "line": 178,
          "endLine": 180,
          "size": 82,
          "async": false,
          "language": "javascript",
          "source": "static isLanguageSupported(language) {\r\n    return language in GRAMMAR_PATHS;\r\n  }"
        },
        "parse": {
          "hash": "8d0a33372c74ecb9942f5083c8449465",
          "line": 188,
          "endLine": 191,
          "size": 140,
          "async": false,
          "language": "javascript",
          "source": "static async parse(sourceCode, language) {\r\n    const parser = await this.createParser(language);\r\n    return parser.parse(sourceCode);\r\n  }"
        },
        "parseFile": {
          "hash": "6ccccffb51d5699e109de50d91d5e309",
          "line": 198,
          "endLine": 208,
          "size": 344,
          "async": false,
          "language": "javascript",
          "source": "static async parseFile(filePath) {\r\n    const language = this.detectLanguage(filePath);\r\n    if (!language) {\r\n      throw new Error(`Cannot detect language for file: ${filePath}`);\r\n    }\r\n\r\n    const sourceCode = readFileSync(filePath, 'utf-8');\r\n    const tree = await this.parse(sourceCode, language);\r\n\r\n    return { tree, language };\r\n  }"
        },
        "clearCache": {
          "hash": "aea5a3a2d531b5aa5878d64bcc005193",
          "line": 213,
          "endLine": 215,
          "size": 52,
          "async": false,
          "language": "javascript",
          "source": "static clearCache() {\r\n    parserCache.clear();\r\n  }"
        }
      }
    },
    "src/parser/scip-parser.js": {
      "hash": "6873a5a3765ff840ea2ca4f19ae430e3",
      "size": 6178,
      "lastModified": "2026-02-08T13:29:17.183Z",
      "functions": [
        "parseScip"
      ],
      "analysisTime": null,
      "functionHashes": {
        "parseScip": {
          "hash": "4933995d11aa59e278fc22e8d5a173bd",
          "line": 12,
          "endLine": 196,
          "size": 5917,
          "async": true,
          "language": "javascript",
          "source": "async function parseScip() {\n  try {\n    // Load the protobuf schema\n    const root = await protobuf.load(protoFile);\n    const Index = root.lookupType('scip.Index');\n\n    // Read and decode the SCIP file\n    const buffer = readFileSync(scipFile);\n    const index = Index.decode(buffer);\n\n    const indexObj = Index.toObject(index, {\n      longs: String,\n      enums: String,\n      bytes: String,\n    });\n\n    console.log('=== SCIP Index Summary ===\\n');\n\n    const metadata = indexObj.metadata || {};\n    console.log('Metadata:');\n    console.log('  Tool:', metadata.toolInfo?.name || 'N/A', metadata.toolInfo?.version || '');\n    console.log('  Project Root:', metadata.projectRoot || 'N/A');\n\n    const documents = indexObj.documents || [];\n    console.log('\\nDocuments indexed:', documents.length);\n\n    // Group files by directory\n    const byDir = {};\n    documents.forEach(doc => {\n      const dir = doc.relativePath.split('/').slice(0, -1).join('/') || '.';\n      byDir[dir] = (byDir[dir] || 0) + 1;\n    });\n\n    console.log('\\nFiles by directory:');\n    Object.entries(byDir).slice(0, 10).forEach(([dir, count]) => {\n      console.log(`  ${dir}: ${count} files`);\n    });\n\n    // Analyze first few documents in detail\n    console.log('\\n=== Sample Documents (first 3) ===\\n');\n\n    documents.slice(0, 3).forEach((doc, idx) => {\n      console.log(`\\n[${idx + 1}] ${doc.relativePath}`);\n      console.log(`    Language: ${doc.language || 'unknown'}`);\n\n      const occurrences = doc.occurrences || [];\n      const symbols = doc.symbols || [];\n\n      console.log(`    Occurrences: ${occurrences.length}`);\n      console.log(`    Symbols defined: ${symbols.length}`);\n\n      // Show first few symbols\n      if (symbols.length > 0) {\n        console.log('\\n    Symbol Details:');\n        symbols.slice(0, 5).forEach(sym => {\n          const symStr = sym.symbol || '';\n          const kind = sym.kind || 0;\n          const docs = sym.documentation || [];\n          const sig = sym.signatureDocumentation?.text || '';\n\n          // Parse symbol to get just the name\n          const parts = symStr.split('/');\n          const name = parts[parts.length - 1]?.replace(/[.`]/g, '') || symStr;\n\n          const kindNames = {\n            1: 'Unknown',\n            6: 'Class',\n            8: 'Method',\n            9: 'Function',\n            10: 'Property',\n            12: 'Variable',\n          };\n\n          console.log(`      - ${name}`);\n          console.log(`        Kind: ${kindNames[kind] || kind}`);\n          if (sig) {\n            console.log(`        Sig: ${sig.substring(0, 60)}${sig.length > 60 ? '...' : ''}`);\n          }\n          if (docs.length > 0) {\n            const docText = docs[0];\n            console.log(`        Doc: ${docText.substring(0, 60)}${docText.length > 60 ? '...' : ''}`);\n          }\n        });\n      }\n\n      // Show sample occurrences (function calls/references)\n      if (occurrences.length > 0) {\n        console.log('\\n    Sample Occurrences (first 5):');\n        occurrences.slice(0, 5).forEach(occ => {\n          const range = occ.range || [];\n          const symbol = occ.symbol || '';\n          const roles = occ.symbolRoles || 0;\n\n          // Parse symbol to get readable name\n          const parts = symbol.split('/');\n          const name = parts[parts.length - 1]?.replace(/[.`]/g, '') || symbol;\n\n          const roleNames = {\n            1: 'Definition',\n            2: 'Import',\n            4: 'Reference',\n            8: 'WriteAccess',\n            16: 'ReadAccess',\n          };\n\n          console.log(`      - ${name}`);\n          console.log(`        Line: ${range[0] || 0}, Roles: ${roleNames[roles] || roles}`);\n        });\n      }\n    });\n\n    // Global statistics\n    console.log('\\n\\n=== Global Statistics ===\\n');\n\n    let totalOccurrences = 0;\n    let totalSymbols = 0;\n    let symbolsByKind = {};\n    let functionSymbols = [];\n\n    documents.forEach(doc => {\n      const symbols = doc.symbols || [];\n      const occurrences = doc.occurrences || [];\n\n      totalSymbols += symbols.length;\n      totalOccurrences += occurrences.length;\n\n      symbols.forEach(sym => {\n        const kind = sym.kind || 0;\n        symbolsByKind[kind] = (symbolsByKind[kind] || 0) + 1;\n\n        // Collect function symbols for later analysis\n        if (kind === 9 || kind === 8) { // Function or Method\n          functionSymbols.push({\n            name: sym.symbol,\n            file: doc.relativePath,\n            sig: sym.signatureDocumentation?.text || '',\n            doc: (sym.documentation || [])[0] || ''\n          });\n        }\n      });\n    });\n\n    console.log('Total Symbols:', totalSymbols);\n    console.log('Total Occurrences:', totalOccurrences);\n    console.log('\\nSymbols by Kind:');\n\n    const kindNames = {\n      1: 'Unknown',\n      2: 'Namespace',\n      3: 'Type',\n      6: 'Class',\n      8: 'Method',\n      9: 'Function',\n      10: 'Property',\n      12: 'Variable',\n      13: 'Constant',\n    };\n\n    Object.entries(symbolsByKind)\n      .sort((a, b) => b[1] - a[1])\n      .forEach(([kind, count]) => {\n        console.log(`  ${kindNames[kind] || kind}: ${count}`);\n      });\n\n    console.log('\\nFunctions/Methods found:', functionSymbols.length);\n    console.log('Sample functions:');\n    functionSymbols.slice(0, 10).forEach(fn => {\n      const name = fn.name.split('/').pop().replace(/[.`]/g, '');\n      console.log(`  ${name} (${fn.file})`);\n      if (fn.sig) {\n        console.log(`    Signature: ${fn.sig.substring(0, 70)}`);\n      }\n    });\n\n    // Save full data for transformer\n    console.log('\\n\\n=== Saving parsed data for transformer ===');\n    const fs = await import('fs');\n    fs.writeFileSync('.llm-context/scip-parsed.json', JSON.stringify(indexObj, null, 2));\n    console.log('Saved to .llm-context/scip-parsed.json');\n\n  } catch (error) {\n    console.error('Error parsing SCIP file:', error.message);\n    console.error(error.stack);\n  }\n}"
        }
      }
    },
    "src/parser/transformer.js": {
      "hash": "fd75b4a2567e0044a0f178464d941828",
      "size": 9079,
      "lastModified": "2025-11-09T04:20:42.000Z",
      "functions": [
        "FunctionDeclaration",
        "VariableDeclarator",
        "CallExpression"
      ],
      "analysisTime": null,
      "functionHashes": {
        "FunctionDeclaration": {
          "hash": "c15dc80d04ef5ff85927d84990b3819d",
          "line": 78,
          "endLine": 96,
          "size": 620,
          "async": false,
          "language": "javascript",
          "source": "FunctionDeclaration(path) {\n          const funcName = path.node.id?.name || 'anonymous';\n          const funcId = `${sourcePath}#${funcName}`;\n\n          functions.push({\n            id: funcId,\n            name: funcName,\n            type: 'function',\n            file: sourcePath,\n            line: path.node.loc?.start.line || 0,\n            params: path.node.params.map(p => p.name || '?').join(', '),\n            async: path.node.async,\n            exported: false,\n            path: path // Store for second pass\n          });\n\n          callGraph.set(funcId, []);\n          sideEffects.set(funcId, []);\n        }"
        },
        "VariableDeclarator": {
          "hash": "20a21447694f682ddaafe630ade16728",
          "line": 98,
          "endLine": 119,
          "size": 777,
          "async": false,
          "language": "javascript",
          "source": "VariableDeclarator(path) {\n          if (path.node.init?.type === 'ArrowFunctionExpression' ||\n              path.node.init?.type === 'FunctionExpression') {\n            const funcName = path.node.id?.name || 'anonymous';\n            const funcId = `${sourcePath}#${funcName}`;\n\n            functions.push({\n              id: funcId,\n              name: funcName,\n              type: 'function',\n              file: sourcePath,\n              line: path.node.loc?.start.line || 0,\n              params: path.node.init.params.map(p => p.name || '?').join(', '),\n              async: path.node.init.async,\n              exported: false,\n              path: path\n            });\n\n            callGraph.set(funcId, []);\n            sideEffects.set(funcId, []);\n          }\n        }"
        },
        "CallExpression": {
          "hash": "b264c3c1c0d0260316697a68ee4cdf35",
          "line": 129,
          "endLine": 176,
          "size": 1806,
          "async": false,
          "language": "javascript",
          "source": "CallExpression(path) {\n            const callee = path.node.callee;\n            let calledName = '';\n\n            if (callee.type === 'Identifier') {\n              calledName = callee.name;\n            } else if (callee.type === 'MemberExpression') {\n              const obj = callee.object.name || '';\n              const prop = callee.property.name || '';\n              calledName = obj ? `${obj}.${prop}` : prop;\n            }\n\n            if (calledName) {\n              const calls = callGraph.get(funcId) || [];\n              calls.push(calledName);\n              callGraph.set(funcId, calls);\n\n              // Detect side effects\n              const effects = sideEffects.get(funcId) || [];\n\n              // File I/O\n              if (/read|write|append|unlink|mkdir|rmdir|fs\\./i.test(calledName)) {\n                effects.push({ type: 'file_io', at: calledName });\n              }\n\n              // Network\n              if (/fetch|request|axios|http|socket/i.test(calledName)) {\n                effects.push({ type: 'network', at: calledName });\n              }\n\n              // Console/logging\n              if (/console\\.|log\\.|logger\\.|debug|info|warn|error/i.test(calledName)) {\n                effects.push({ type: 'logging', at: calledName });\n              }\n\n              // Database\n              if (/query|execute|find|findOne|save|insert|update|delete|collection|db\\./i.test(calledName)) {\n                effects.push({ type: 'database', at: calledName });\n              }\n\n              // DOM manipulation\n              if (/querySelector|getElementById|createElement|appendChild|innerHTML|textContent/i.test(calledName)) {\n                effects.push({ type: 'dom', at: calledName });\n              }\n\n              sideEffects.set(funcId, effects);\n            }\n          }"
        }
      }
    },
    "src/setup/claude-setup.js": {
      "hash": "5bfab57483073a3f9a17d44d7291dbf5",
      "size": 5773,
      "lastModified": "2026-02-08T13:46:28.328Z",
      "functions": [
        "setupClaudeIntegration",
        "generateClaudeMd"
      ],
      "analysisTime": null,
      "functionHashes": {
        "setupClaudeIntegration": {
          "hash": "5be0744f08b5af01a7a85f91cbc4ac3e",
          "line": 18,
          "endLine": 41,
          "size": 749,
          "async": false,
          "language": "javascript",
          "source": "function setupClaudeIntegration(options = {}) {\r\n  const { projectName = 'this project', force = false, cwd = process.cwd() } = options;\r\n\r\n  const claudeDir = join(cwd, '.claude');\r\n  const claudeMdPath = join(claudeDir, 'CLAUDE.md');\r\n\r\n  // Check if already exists\r\n  if (existsSync(claudeMdPath) && !force) {\r\n    console.log('   ℹ️  .claude/CLAUDE.md already exists (use --force to overwrite)');\r\n    return false;\r\n  }\r\n\r\n  // Create .claude directory\r\n  mkdirSync(claudeDir, { recursive: true });\r\n\r\n  // Generate CLAUDE.md content\r\n  const claudeMd = generateClaudeMd(projectName);\r\n\r\n  // Write file\r\n  writeFileSync(claudeMdPath, claudeMd);\r\n\r\n  console.log('   ✓ Generated .claude/CLAUDE.md (Claude Code integration)');\r\n  return true;\r\n}"
        },
        "generateClaudeMd": {
          "hash": "473a6ce3cff338016eb49ed9fcedd8ec",
          "line": 48,
          "endLine": 168,
          "size": 3508,
          "async": false,
          "language": "javascript",
          "source": "function generateClaudeMd(projectName) {\r\n  return `# ${projectName} - LLM Context Instructions\r\n\r\n## 🚨 MANDATORY: Query-First Exploration\r\n\r\n**This codebase has llm-context analysis available.**\r\n\r\n### BEFORE using Grep/Bash/Read for code exploration:\r\n\r\n1. **Check if \\`.llm-context/\\` exists** (it does in this project)\r\n2. **Use queries FIRST**:\r\n   \\`\\`\\`bash\r\n   llm-context query find-function <name>     # Find & describe function\r\n   llm-context query calls-to <name>          # Who calls this?\r\n   llm-context query trace <name>             # Full call tree\r\n   llm-context side-effects                   # Functions with I/O\r\n   llm-context entry-points                   # Entry points\r\n   \\`\\`\\`\r\n3. **Only use grep/read** if queries insufficient\r\n\r\n### Why This Matters\r\n\r\n**Grep/Bash limitations:**\r\n- ❌ Shows only text matches\r\n- ❌ Misses call relationships\r\n- ❌ Doesn't show side effects\r\n- ❌ No architectural context\r\n\r\n**Query advantages:**\r\n- ✅ Shows semantic relationships\r\n- ✅ Includes call graphs\r\n- ✅ Detects side effects (file_io, network, database)\r\n- ✅ Identifies entry points\r\n- ✅ 80-95% fewer tokens\r\n\r\n### Examples\r\n\r\n**❌ Anti-pattern (what NOT to do):**\r\n\\`\\`\\`bash\r\n# DON'T: Use grep when queries exist\r\ngrep -r \"someFunction\" --include=\"*.js\"\r\n\\`\\`\\`\r\n\r\n**✅ Correct pattern:**\r\n\\`\\`\\`bash\r\n# DO: Use queries first\r\nllm-context query find-function someFunction\r\n# Shows: signature, calls, side effects, patterns, line number\r\n\r\n# Then if needed:\r\nllm-context query calls-to someFunction\r\n# Shows: which functions call it\r\n\r\n# Only read source for implementation details:\r\ncat file.js | sed -n '42,100p'\r\n\\`\\`\\`\r\n\r\n## Development Workflow\r\n\r\n### Understanding Codebase (First Time)\r\n\\`\\`\\`bash\r\n# 1. Read progressive disclosure\r\ncat .llm-context/summaries/L0-system.md  # System overview\r\ncat .llm-context/summaries/L1-domains.json  # Domain boundaries\r\nllm-context stats  # Statistics\r\n\r\n# 2. Explore specific areas\r\nllm-context entry-points  # Where does execution start?\r\nllm-context side-effects  # What does I/O?\r\n\r\n# 3. Deep dive with queries\r\nllm-context query trace <entry-point>  # Understand flow\r\n\\`\\`\\`\r\n\r\n### After Code Changes\r\n\\`\\`\\`bash\r\n# Incremental analysis (99% faster)\r\nllm-context analyze\r\n\r\n# Check what changed\r\nllm-context check-changes\r\n\\`\\`\\`\r\n\r\n### Debugging\r\n\\`\\`\\`bash\r\n# Find function and understand context\r\nllm-context query find-function <buggy-func>\r\nllm-context query calls-to <buggy-func>  # Who calls it?\r\nllm-context query trace <buggy-func>     # Full call path\r\n\r\n# Check for side effects\r\nllm-context side-effects | grep <buggy-func>\r\n\\`\\`\\`\r\n\r\n## Common Tasks\r\n\r\n| Task | Command |\r\n|------|---------|\r\n| Analyze codebase | \\`llm-context analyze\\` |\r\n| Find function | \\`llm-context query find-function <name>\\` |\r\n| Find callers | \\`llm-context query calls-to <name>\\` |\r\n| Trace calls | \\`llm-context query trace <name>\\` |\r\n| Side effects | \\`llm-context side-effects\\` |\r\n| Statistics | \\`llm-context stats\\` |\r\n| Entry points | \\`llm-context entry-points\\` |\r\n\r\n## Success Indicators\r\n\r\nYou're using this tool correctly when:\r\n1. ✅ You read L0 summary before exploring code\r\n2. ✅ You use queries instead of grep for function lookups\r\n3. ✅ You mention side effects when discussing functions\r\n4. ✅ You run incremental analysis after changes\r\n5. ✅ Your token usage is 50-95% lower than raw file reading\r\n\r\n---\r\n\r\n*This file was auto-generated by llm-context tools.*\r\n*Learn more: https://github.com/devame/llm-context-tools*\r\n`;\r\n}"
        }
      }
    },
    "src/setup/prime.js": {
      "hash": "79018d7e0036afe3e3a3ff90c581045c",
      "size": 5840,
      "lastModified": "2026-01-11T10:45:22.755Z",
      "functions": [
        "checkInitialized",
        "loadSystemSummary",
        "loadStatistics",
        "findEntryPoints",
        "generatePrimeOutput",
        "main"
      ],
      "analysisTime": null,
      "functionHashes": {
        "checkInitialized": {
          "hash": "58326b4c6e7ffa839946dd1a9950915e",
          "line": 21,
          "endLine": 29,
          "size": 295,
          "async": false,
          "language": "javascript",
          "source": "function checkInitialized() {\r\n  const llmContextDir = join(process.cwd(), '.llm-context');\r\n  if (!existsSync(llmContextDir)) {\r\n    console.log('📊 LLM Context Tools: Not initialized in this project');\r\n    console.log('   Run: llm-context analyze');\r\n    return false;\r\n  }\r\n  return true;\r\n}"
        },
        "loadSystemSummary": {
          "hash": "da8e580afc16ae90ae878ae96605063e",
          "line": 34,
          "endLine": 40,
          "size": 226,
          "async": false,
          "language": "javascript",
          "source": "function loadSystemSummary() {\r\n  const summaryPath = join(process.cwd(), '.llm-context', 'summaries', 'L0-system.md');\r\n  if (!existsSync(summaryPath)) {\r\n    return null;\r\n  }\r\n  return readFileSync(summaryPath, 'utf-8');\r\n}"
        },
        "loadStatistics": {
          "hash": "8c08a00dc12ca1d7f8193472257f7af2",
          "line": 45,
          "endLine": 86,
          "size": 1053,
          "async": false,
          "language": "javascript",
          "source": "function loadStatistics() {\r\n  const graphPath = join(process.cwd(), '.llm-context', 'graph.jsonl');\r\n  if (!existsSync(graphPath)) {\r\n    return null;\r\n  }\r\n\r\n  const lines = readFileSync(graphPath, 'utf-8').trim().split('\\n');\r\n  const entries = lines.map(line => JSON.parse(line));\r\n\r\n  const stats = {\r\n    totalFunctions: entries.length,\r\n    languages: new Set(),\r\n    files: new Set(),\r\n    async: 0,\r\n    sideEffects: {\r\n      file_io: 0,\r\n      network: 0,\r\n      database: 0,\r\n      logging: 0,\r\n      dom: 0\r\n    }\r\n  };\r\n\r\n  for (const entry of entries) {\r\n    if (entry.language) stats.languages.add(entry.language);\r\n    if (entry.file) stats.files.add(entry.file);\r\n    if (entry.async) stats.async++;\r\n    if (entry.effects) {\r\n      for (const effect of entry.effects) {\r\n        if (stats.sideEffects.hasOwnProperty(effect)) {\r\n          stats.sideEffects[effect]++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  stats.languages = Array.from(stats.languages);\r\n  stats.totalFiles = stats.files.size;\r\n  delete stats.files;\r\n\r\n  return stats;\r\n}"
        },
        "findEntryPoints": {
          "hash": "a6e4a6732076daaa5e08779ac5baff97",
          "line": 91,
          "endLine": 126,
          "size": 1024,
          "async": false,
          "language": "javascript",
          "source": "function findEntryPoints() {\r\n  const graphPath = join(process.cwd(), '.llm-context', 'graph.jsonl');\r\n  if (!existsSync(graphPath)) {\r\n    return [];\r\n  }\r\n\r\n  const lines = readFileSync(graphPath, 'utf-8').trim().split('\\n');\r\n  const entries = lines.map(line => JSON.parse(line));\r\n\r\n  // Build caller map\r\n  const callers = new Map();\r\n  for (const entry of entries) {\r\n    if (!callers.has(entry.id)) {\r\n      callers.set(entry.id, 0);\r\n    }\r\n    if (entry.calls) {\r\n      for (const call of entry.calls) {\r\n        callers.set(call, (callers.get(call) || 0) + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Find entry points (has side effects, not called by others)\r\n  const entryPoints = entries.filter(entry => {\r\n    const hasSideEffects = entry.effects && entry.effects.length > 0;\r\n    const notCalled = (callers.get(entry.id) || 0) === 0;\r\n    return hasSideEffects && notCalled;\r\n  });\r\n\r\n  return entryPoints.slice(0, 10).map(e => ({\r\n    name: e.id,\r\n    file: e.file,\r\n    line: e.line,\r\n    effects: e.effects\r\n  }));\r\n}"
        },
        "generatePrimeOutput": {
          "hash": "6b58c7659af25b6d7f3961b340b76aab",
          "line": 131,
          "endLine": 185,
          "size": 2114,
          "async": false,
          "language": "javascript",
          "source": "function generatePrimeOutput() {\r\n  console.log('\\n╔═══════════════════════════════════════════════════════════════╗');\r\n  console.log('║                 LLM Context Tools - Primed                    ║');\r\n  console.log('╚═══════════════════════════════════════════════════════════════╝\\n');\r\n\r\n  // Load L0 summary\r\n  const systemSummary = loadSystemSummary();\r\n  if (systemSummary) {\r\n    console.log('## System Overview\\n');\r\n    console.log(systemSummary);\r\n    console.log('\\n---\\n');\r\n  }\r\n\r\n  // Load statistics\r\n  const stats = loadStatistics();\r\n  if (stats) {\r\n    console.log('## Statistics\\n');\r\n    console.log(`**Total Functions:** ${stats.totalFunctions}`);\r\n    console.log(`**Files Analyzed:** ${stats.totalFiles}`);\r\n    console.log(`**Languages:** ${stats.languages.join(', ')}`);\r\n    console.log(`**Async Functions:** ${stats.async}`);\r\n    console.log('\\n**Side Effects:**');\r\n    for (const [effect, count] of Object.entries(stats.sideEffects)) {\r\n      if (count > 0) {\r\n        console.log(`  - ${effect}: ${count} functions`);\r\n      }\r\n    }\r\n    console.log('\\n---\\n');\r\n  }\r\n\r\n  // Find entry points\r\n  const entryPoints = findEntryPoints();\r\n  if (entryPoints.length > 0) {\r\n    console.log('## Entry Points (Top 10)\\n');\r\n    for (const ep of entryPoints) {\r\n      console.log(`**${ep.name}** (${ep.file}:${ep.line})`);\r\n      console.log(`  Effects: ${ep.effects.join(', ')}`);\r\n      console.log();\r\n    }\r\n    console.log('---\\n');\r\n  }\r\n\r\n  // Usage instructions\r\n  console.log('## Quick Commands\\n');\r\n  console.log('```bash');\r\n  console.log('llm-context query find-function <name>  # Find function');\r\n  console.log('llm-context query calls-to <name>       # Who calls this?');\r\n  console.log('llm-context query trace <name>          # Call tree');\r\n  console.log('llm-context stats                       # Full statistics');\r\n  console.log('llm-context entry-points                # All entry points');\r\n  console.log('llm-context side-effects                # Side effects report');\r\n  console.log('```\\n');\r\n\r\n  console.log('📚 Full documentation: .claude/CLAUDE.md\\n');\r\n}"
        },
        "main": {
          "hash": "cadb2be27299261bbaa79cb28bd1271d",
          "line": 190,
          "endLine": 196,
          "size": 96,
          "async": false,
          "language": "javascript",
          "source": "function main() {\r\n  if (!checkInitialized()) {\r\n    return;\r\n  }\r\n\r\n  generatePrimeOutput();\r\n}"
        }
      }
    },
    "src/setup/setup-claude.js": {
      "hash": "aae545beb7f4785618769687d761d2cf",
      "size": 6049,
      "lastModified": "2026-01-11T10:45:22.755Z",
      "functions": [
        "checkInstallation",
        "installHooks",
        "removeHooks",
        "main"
      ],
      "analysisTime": null,
      "functionHashes": {
        "checkInstallation": {
          "hash": "25c5d8b3915e51e09d430ff62b7814ab",
          "line": 48,
          "endLine": 77,
          "size": 1141,
          "async": false,
          "language": "javascript",
          "source": "function checkInstallation() {\r\n  const sessionStartExists = existsSync(SESSION_START_HOOK);\r\n  const preCompactExists = existsSync(PRE_COMPACT_HOOK);\r\n\r\n  console.log('\\\\n=== llm-context-tools Claude Code Integration ===\\\\n');\r\n\r\n  if (sessionStartExists && preCompactExists) {\r\n    console.log('✅ Hooks installed correctly');\r\n    console.log('   SessionStart:', SESSION_START_HOOK);\r\n    console.log('   PreCompact:', PRE_COMPACT_HOOK);\r\n\r\n    // Check if they contain our content\r\n    const sessionContent = readFileSync(SESSION_START_HOOK, 'utf-8');\r\n    const compactContent = readFileSync(PRE_COMPACT_HOOK, 'utf-8');\r\n\r\n    if (sessionContent.includes('llm-context prime') &&\r\n        compactContent.includes('llm-context analyze')) {\r\n      console.log('\\\\n✅ Hook contents verified');\r\n      return true;\r\n    } else {\r\n      console.log('\\\\n⚠️  Hook files exist but have different content');\r\n      console.log('   Run: llm-context setup-claude --force to overwrite');\r\n      return false;\r\n    }\r\n  } else {\r\n    console.log('❌ Hooks not installed');\r\n    console.log('   Run: llm-context setup-claude');\r\n    return false;\r\n  }\r\n}"
        },
        "installHooks": {
          "hash": "504759c400218962069d718bd41b8262",
          "line": 82,
          "endLine": 127,
          "size": 1802,
          "async": false,
          "language": "javascript",
          "source": "function installHooks(force = false) {\r\n  console.log('\\\\n=== Installing Claude Code Hooks ===\\\\n');\r\n\r\n  // Create hooks directory if needed\r\n  if (!existsSync(HOOKS_DIR)) {\r\n    console.log('Creating hooks directory:', HOOKS_DIR);\r\n    mkdirSync(HOOKS_DIR, { recursive: true });\r\n  }\r\n\r\n  // Check if hooks already exist\r\n  if ((existsSync(SESSION_START_HOOK) || existsSync(PRE_COMPACT_HOOK)) && !force) {\r\n    console.log('⚠️  Hooks already exist. Options:');\r\n    console.log('   1. Run with --force to overwrite');\r\n    console.log('   2. Run with --check to verify installation');\r\n    console.log('   3. Manually merge with existing hooks');\r\n    console.log('\\\\nExisting hooks:');\r\n    if (existsSync(SESSION_START_HOOK)) {\r\n      console.log('   -', SESSION_START_HOOK);\r\n    }\r\n    if (existsSync(PRE_COMPACT_HOOK)) {\r\n      console.log('   -', PRE_COMPACT_HOOK);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Install SessionStart hook\r\n  console.log('Installing SessionStart hook...');\r\n  writeFileSync(SESSION_START_HOOK, SESSION_START_CONTENT, { mode: 0o755 });\r\n  console.log('✅', SESSION_START_HOOK);\r\n\r\n  // Install PreCompact hook\r\n  console.log('Installing PreCompact hook...');\r\n  writeFileSync(PRE_COMPACT_HOOK, PRE_COMPACT_CONTENT, { mode: 0o755 });\r\n  console.log('✅', PRE_COMPACT_HOOK);\r\n\r\n  console.log('\\\\n✅ Claude Code integration installed!\\\\n');\r\n  console.log('What happens now:');\r\n  console.log('  • SessionStart: Injects .llm-context/ summary at session start');\r\n  console.log('  • PreCompact: Runs incremental analysis before compaction');\r\n  console.log('\\\\nNext steps:');\r\n  console.log('  1. Run: llm-context analyze (in your project)');\r\n  console.log('  2. Restart Claude Code');\r\n  console.log('  3. Context will auto-inject on session start!\\\\n');\r\n\r\n  return true;\r\n}"
        },
        "removeHooks": {
          "hash": "706971ccc17cbb4828053e404aa54e43",
          "line": 132,
          "endLine": 166,
          "size": 1123,
          "async": false,
          "language": "javascript",
          "source": "function removeHooks() {\r\n  console.log('\\\\n=== Removing Claude Code Hooks ===\\\\n');\r\n\r\n  let removed = false;\r\n\r\n  if (existsSync(SESSION_START_HOOK)) {\r\n    const content = readFileSync(SESSION_START_HOOK, 'utf-8');\r\n    if (content.includes('llm-context prime')) {\r\n      unlinkSync(SESSION_START_HOOK);\r\n      console.log('✅ Removed:', SESSION_START_HOOK);\r\n      removed = true;\r\n    } else {\r\n      console.log('⚠️  SessionStart hook exists but is not from llm-context-tools');\r\n      console.log('   Skipping removal (manual cleanup required)');\r\n    }\r\n  }\r\n\r\n  if (existsSync(PRE_COMPACT_HOOK)) {\r\n    const content = readFileSync(PRE_COMPACT_HOOK, 'utf-8');\r\n    if (content.includes('llm-context analyze')) {\r\n      unlinkSync(PRE_COMPACT_HOOK);\r\n      console.log('✅ Removed:', PRE_COMPACT_HOOK);\r\n      removed = true;\r\n    } else {\r\n      console.log('⚠️  PreCompact hook exists but is not from llm-context-tools');\r\n      console.log('   Skipping removal (manual cleanup required)');\r\n    }\r\n  }\r\n\r\n  if (!removed) {\r\n    console.log('No llm-context-tools hooks found to remove');\r\n  }\r\n\r\n  console.log();\r\n}"
        },
        "main": {
          "hash": "c672d50644a9bf7f72bb2f4c9a069ae3",
          "line": 171,
          "endLine": 184,
          "size": 339,
          "async": false,
          "language": "javascript",
          "source": "function main() {\r\n  const args = process.argv.slice(2);\r\n  const hasCheck = args.includes('--check');\r\n  const hasRemove = args.includes('--remove');\r\n  const hasForce = args.includes('--force');\r\n\r\n  if (hasCheck) {\r\n    checkInstallation();\r\n  } else if (hasRemove) {\r\n    removeHooks();\r\n  } else {\r\n    installHooks(hasForce);\r\n  }\r\n}"
        }
      }
    },
    "src/utils/function-source-extractor.js": {
      "hash": "23baae78c3f55d92987c5763c0c6fb00",
      "size": 4877,
      "lastModified": "2026-01-11T10:45:22.681Z",
      "functions": [
        "extractFunctionSource",
        "hashFunctionSource",
        "generateFunctionId",
        "extractFunctionMetadata",
        "computeSimilarity",
        "detectRename"
      ],
      "analysisTime": null,
      "functionHashes": {
        "extractFunctionSource": {
          "hash": "20309a4b5674e1c2741cb2c0246d933f",
          "line": 17,
          "endLine": 43,
          "size": 764,
          "async": false,
          "language": "javascript",
          "source": "function extractFunctionSource(path, sourceCode) {\r\n  const { start, end } = path.node.loc;\r\n\r\n  if (!start || !end) {\r\n    return '';\r\n  }\r\n\r\n  const lines = sourceCode.split('\\n');\r\n\r\n  // Extract lines from start.line to end.line (1-indexed)\r\n  const funcLines = lines.slice(start.line - 1, end.line);\r\n\r\n  // Handle single-line functions\r\n  if (funcLines.length === 1) {\r\n    return funcLines[0].substring(start.column, end.column);\r\n  }\r\n\r\n  // Multi-line functions\r\n  // First line: from start.column to end\r\n  funcLines[0] = funcLines[0].substring(start.column);\r\n\r\n  // Last line: from beginning to end.column\r\n  const lastIdx = funcLines.length - 1;\r\n  funcLines[lastIdx] = funcLines[lastIdx].substring(0, end.column);\r\n\r\n  return funcLines.join('\\n');\r\n}"
        },
        "hashFunctionSource": {
          "hash": "9d77aa3035854269625a8ea95e925ca8",
          "line": 50,
          "endLine": 57,
          "size": 269,
          "async": false,
          "language": "javascript",
          "source": "function hashFunctionSource(source) {\r\n  // Normalize whitespace to avoid spurious changes from reformatting\r\n  const normalized = source\r\n    .replace(/\\s+/g, ' ')  // Collapse whitespace\r\n    .trim();\r\n\r\n  return createHash('md5').update(normalized).digest('hex');\r\n}"
        },
        "generateFunctionId": {
          "hash": "ffdb2c7d12885c0a48f1f029d9c9becc",
          "line": 66,
          "endLine": 73,
          "size": 233,
          "async": false,
          "language": "javascript",
          "source": "function generateFunctionId(filePath, funcName, line) {\r\n  // For anonymous functions, use line number\r\n  if (!funcName || funcName === 'anonymous') {\r\n    return `${filePath}#L${line}`;\r\n  }\r\n\r\n  return `${filePath}#${funcName}`;\r\n}"
        },
        "extractFunctionMetadata": {
          "hash": "662f1280e5ed111ea99431955e40fd68",
          "line": 82,
          "endLine": 115,
          "size": 864,
          "async": false,
          "language": "javascript",
          "source": "function extractFunctionMetadata(path, sourceCode, filePath) {\r\n  const node = path.node;\r\n\r\n  // Get function name\r\n  let funcName = 'anonymous';\r\n  if (node.id?.name) {\r\n    funcName = node.id.name;\r\n  } else if (path.parent?.type === 'VariableDeclarator' && path.parent.id?.name) {\r\n    funcName = path.parent.id.name;\r\n  }\r\n\r\n  // Extract source\r\n  const source = extractFunctionSource(path, sourceCode);\r\n  const hash = hashFunctionSource(source);\r\n\r\n  // Get location\r\n  const line = node.loc?.start.line || 0;\r\n  const endLine = node.loc?.end.line || 0;\r\n\r\n  // Generate unique ID\r\n  const funcId = generateFunctionId(filePath, funcName, line);\r\n\r\n  return {\r\n    id: funcId,\r\n    name: funcName,\r\n    line,\r\n    endLine,\r\n    source,\r\n    hash,\r\n    size: source.length,\r\n    isAsync: node.async || false,\r\n    isGenerator: node.generator || false\r\n  };\r\n}"
        },
        "computeSimilarity": {
          "hash": "b1df5a3b4539f873e7fb7c959037c8f0",
          "line": 123,
          "endLine": 142,
          "size": 598,
          "async": false,
          "language": "javascript",
          "source": "function computeSimilarity(source1, source2) {\r\n  // Simple similarity: compare normalized versions\r\n  const norm1 = source1.replace(/\\s+/g, ' ').trim();\r\n  const norm2 = source2.replace(/\\s+/g, ' ').trim();\r\n\r\n  if (norm1 === norm2) return 1.0;\r\n\r\n  // Levenshtein distance would be better, but this is simple\r\n  const maxLen = Math.max(norm1.length, norm2.length);\r\n  if (maxLen === 0) return 1.0;\r\n\r\n  let matches = 0;\r\n  const minLen = Math.min(norm1.length, norm2.length);\r\n\r\n  for (let i = 0; i < minLen; i++) {\r\n    if (norm1[i] === norm2[i]) matches++;\r\n  }\r\n\r\n  return matches / maxLen;\r\n}"
        },
        "detectRename": {
          "hash": "711df06e0d54a562d5efa3a5fce6cfaa",
          "line": 151,
          "endLine": 169,
          "size": 455,
          "async": false,
          "language": "javascript",
          "source": "function detectRename(deletedFunc, addedFuncs, threshold = 0.9) {\r\n  let bestMatch = null;\r\n  let bestScore = threshold;\r\n\r\n  for (const addedFunc of addedFuncs) {\r\n    const score = computeSimilarity(deletedFunc.source, addedFunc.source);\r\n\r\n    if (score > bestScore) {\r\n      bestScore = score;\r\n      bestMatch = {\r\n        from: deletedFunc.name,\r\n        to: addedFunc.name,\r\n        similarity: score\r\n      };\r\n    }\r\n  }\r\n\r\n  return bestMatch;\r\n}"
        }
      }
    },
    "src/utils/grep.js": {
      "hash": "bb2aa618c78b05a7de1123248cc39368",
      "size": 5750,
      "lastModified": "2026-02-08T13:06:24.992Z",
      "functions": [
        "grep",
        "parseGrepArgs",
        "searchFiles",
        "findJavaScriptFiles",
        "matchesPattern",
        "displayResults"
      ],
      "analysisTime": null,
      "functionHashes": {
        "grep": {
          "hash": "69de4e69e03e23bc0c7391f8ffd60531",
          "line": 14,
          "endLine": 26,
          "size": 312,
          "async": true,
          "language": "javascript",
          "source": "async function grep(args) {\n  const options = parseGrepArgs(args);\n\n  if (!options.pattern) {\n    console.error('❌ Error: Pattern required');\n    console.error('Usage: llm-context grep <pattern> [options]');\n    process.exit(1);\n  }\n\n  const results = searchFiles(options);\n\n  displayResults(results, options);\n}"
        },
        "parseGrepArgs": {
          "hash": "9b919e32f138803c7184f21a3bef8267",
          "line": 31,
          "endLine": 91,
          "size": 1241,
          "async": false,
          "language": "javascript",
          "source": "function parseGrepArgs(args) {\n  const options = {\n    pattern: null,\n    contextBefore: 0,\n    contextAfter: 0,\n    caseInsensitive: false,\n    showLineNumbers: true,\n    filesPattern: null,\n    maxResults: 100\n  };\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n\n    if (!arg.startsWith('-')) {\n      if (!options.pattern) {\n        options.pattern = arg;\n      }\n      continue;\n    }\n\n    switch (arg) {\n      case '-i':\n      case '--ignore-case':\n        options.caseInsensitive = true;\n        break;\n\n      case '-n':\n      case '--line-number':\n        options.showLineNumbers = true;\n        break;\n\n      case '-C':\n      case '--context':\n        const context = parseInt(args[++i]);\n        options.contextBefore = context;\n        options.contextAfter = context;\n        break;\n\n      case '-B':\n      case '--before-context':\n        options.contextBefore = parseInt(args[++i]);\n        break;\n\n      case '-A':\n      case '--after-context':\n        options.contextAfter = parseInt(args[++i]);\n        break;\n\n      case '--files':\n        options.filesPattern = args[++i];\n        break;\n\n      case '--max':\n        options.maxResults = parseInt(args[++i]);\n        break;\n    }\n  }\n\n  return options;\n}"
        },
        "searchFiles": {
          "hash": "1786feea2bdfb4d783659d8439f98574",
          "line": 96,
          "endLine": 146,
          "size": 1260,
          "async": false,
          "language": "javascript",
          "source": "function searchFiles(options) {\n  const results = [];\n  const files = findJavaScriptFiles('.', options.filesPattern);\n\n  const regex = new RegExp(\n    options.pattern,\n    options.caseInsensitive ? 'gi' : 'g'\n  );\n\n  for (const file of files) {\n    try {\n      const content = readFileSync(file, 'utf-8');\n      const lines = content.split('\\n');\n\n      lines.forEach((line, index) => {\n        if (regex.test(line)) {\n          // Get context lines\n          const contextLines = [];\n\n          for (let i = Math.max(0, index - options.contextBefore);\n               i <= Math.min(lines.length - 1, index + options.contextAfter);\n               i++) {\n            contextLines.push({\n              lineNumber: i + 1,\n              content: lines[i],\n              isMatch: i === index\n            });\n          }\n\n          results.push({\n            file: relative('.', file),\n            lineNumber: index + 1,\n            line: line.trim(),\n            context: contextLines\n          });\n\n          if (results.length >= options.maxResults) {\n            return results;\n          }\n        }\n      });\n\n      // Reset regex for next file\n      regex.lastIndex = 0;\n    } catch (err) {\n      // Skip files that can't be read\n    }\n  }\n\n  return results;\n}"
        },
        "findJavaScriptFiles": {
          "hash": "a8614ffa4a68923159a48008d3e30172",
          "line": 151,
          "endLine": 175,
          "size": 627,
          "async": false,
          "language": "javascript",
          "source": "function findJavaScriptFiles(dir, pattern) {\n  const files = [];\n  const entries = readdirSync(dir);\n\n  for (const entry of entries) {\n    const fullPath = join(dir, entry);\n\n    // Skip node_modules and hidden directories\n    if (entry === 'node_modules' || entry.startsWith('.')) {\n      continue;\n    }\n\n    const stat = statSync(fullPath);\n\n    if (stat.isDirectory()) {\n      files.push(...findJavaScriptFiles(fullPath, pattern));\n    } else if (entry.endsWith('.js') || entry.endsWith('.mjs')) {\n      if (!pattern || matchesPattern(fullPath, pattern)) {\n        files.push(fullPath);\n      }\n    }\n  }\n\n  return files;\n}"
        },
        "matchesPattern": {
          "hash": "3ab64903b5775d9597876287a06bf96a",
          "line": 180,
          "endLine": 192,
          "size": 260,
          "async": false,
          "language": "javascript",
          "source": "function matchesPattern(file, pattern) {\n  if (!pattern) return true;\n\n  // Simple glob-like matching\n  const regex = new RegExp(\n    pattern\n      .replace(/\\./g, '\\\\.')\n      .replace(/\\*/g, '.*')\n      .replace(/\\?/g, '.')\n  );\n\n  return regex.test(file);\n}"
        },
        "displayResults": {
          "hash": "c9c6f41973c74592cc8889cc158131d0",
          "line": 197,
          "endLine": 242,
          "size": 1407,
          "async": false,
          "language": "javascript",
          "source": "function displayResults(results, options) {\n  if (results.length === 0) {\n    console.log('No matches found.');\n    return;\n  }\n\n  console.log(`\\n🔍 Found ${results.length} match${results.length === 1 ? '' : 'es'}:\\n`);\n\n  let lastFile = null;\n\n  for (const result of results) {\n    // Show file header if different from last\n    if (result.file !== lastFile) {\n      if (lastFile !== null) console.log(''); // Blank line between files\n      console.log(`\\x1b[1m${result.file}\\x1b[0m`);\n      lastFile = result.file;\n    }\n\n    // Show context\n    if (options.contextBefore > 0 || options.contextAfter > 0) {\n      for (const ctx of result.context) {\n        const lineNum = options.showLineNumbers\n          ? `\\x1b[36m${String(ctx.lineNumber).padStart(4)}\\x1b[0m: `\n          : '';\n\n        if (ctx.isMatch) {\n          // Highlight match line\n          console.log(`${lineNum}\\x1b[33m${ctx.content}\\x1b[0m`);\n        } else {\n          console.log(`${lineNum}${ctx.content}`);\n        }\n      }\n      console.log(''); // Blank line after context\n    } else {\n      // Just show match line\n      const lineNum = options.showLineNumbers\n        ? `\\x1b[36m${result.lineNumber}\\x1b[0m: `\n        : '';\n      console.log(`  ${lineNum}${result.line}`);\n    }\n  }\n\n  if (results.length >= options.maxResults) {\n    console.log(`\\n⚠️  Showing first ${options.maxResults} results. Use --max to see more.`);\n  }\n}"
        }
      }
    },
    "src/utils/language-queries.js": {
      "hash": "f590699a78965ebcfffafc47cd5b4929",
      "size": 11257,
      "lastModified": "2026-02-08T13:05:53.758Z",
      "functions": [
        "getQueries",
        "getFunctionQuery",
        "getCallQuery",
        "getImportQuery"
      ],
      "analysisTime": null,
      "functionHashes": {
        "getQueries": {
          "hash": "653b4fb55bb8bfb2099ac5cf55e31e30",
          "line": 465,
          "endLine": 470,
          "size": 185,
          "async": false,
          "language": "javascript",
          "source": "function getQueries(language) {\r\n  if (!LANGUAGE_QUERIES[language]) {\r\n    throw new Error(`No queries defined for language: ${language}`);\r\n  }\r\n  return LANGUAGE_QUERIES[language];\r\n}"
        },
        "getFunctionQuery": {
          "hash": "0b6fab76d6c2a6da519994512270fdc5",
          "line": 477,
          "endLine": 480,
          "size": 110,
          "async": false,
          "language": "javascript",
          "source": "function getFunctionQuery(language) {\r\n  const queries = getQueries(language);\r\n  return queries.functions;\r\n}"
        },
        "getCallQuery": {
          "hash": "fc60d0f909a6492a59b8448325e76ba9",
          "line": 487,
          "endLine": 490,
          "size": 102,
          "async": false,
          "language": "javascript",
          "source": "function getCallQuery(language) {\r\n  const queries = getQueries(language);\r\n  return queries.calls;\r\n}"
        },
        "getImportQuery": {
          "hash": "71b1d2fe550d6fd60497dde46090dd36",
          "line": 497,
          "endLine": 500,
          "size": 106,
          "async": false,
          "language": "javascript",
          "source": "function getImportQuery(language) {\r\n  const queries = getQueries(language);\r\n  return queries.imports;\r\n}"
        }
      }
    },
    "src/utils/prompt-helper.js": {
      "hash": "9e321550c0f16dc13159a89813004767",
      "size": 1927,
      "lastModified": "2026-02-08T13:05:53.775Z",
      "functions": [
        "promptYesNo",
        "promptContinue",
        "promptChoice"
      ],
      "analysisTime": null,
      "functionHashes": {
        "promptYesNo": {
          "hash": "4bfa0e3ab7c837f79f8e73de9b1cfccb",
          "line": 12,
          "endLine": 25,
          "size": 372,
          "async": false,
          "language": "javascript",
          "source": "function promptYesNo(question) {\r\n  const rl = createInterface({\r\n    input: process.stdin,\r\n    output: process.stdout\r\n  });\r\n\r\n  return new Promise((resolve) => {\r\n    rl.question(`${question} (y/n): `, (answer) => {\r\n      rl.close();\r\n      const normalized = answer.trim().toLowerCase();\r\n      resolve(normalized === 'y' || normalized === 'yes');\r\n    });\r\n  });\r\n}"
        },
        "promptContinue": {
          "hash": "a8f6385f35c7d6880dd164f48bee7a94",
          "line": 32,
          "endLine": 44,
          "size": 288,
          "async": false,
          "language": "javascript",
          "source": "function promptContinue(message = 'Press Enter to continue...') {\r\n  const rl = createInterface({\r\n    input: process.stdin,\r\n    output: process.stdout\r\n  });\r\n\r\n  return new Promise((resolve) => {\r\n    rl.question(message, () => {\r\n      rl.close();\r\n      resolve();\r\n    });\r\n  });\r\n}"
        },
        "promptChoice": {
          "hash": "75fe1cdab7e413a843c9ff0fd1c2316a",
          "line": 52,
          "endLine": 75,
          "size": 649,
          "async": false,
          "language": "javascript",
          "source": "function promptChoice(question, choices) {\r\n  const rl = createInterface({\r\n    input: process.stdin,\r\n    output: process.stdout\r\n  });\r\n\r\n  return new Promise((resolve) => {\r\n    console.log(question);\r\n    choices.forEach((choice, index) => {\r\n      console.log(`  ${index + 1}. ${choice}`);\r\n    });\r\n\r\n    rl.question('\\nSelect option (1-' + choices.length + '): ', (answer) => {\r\n      rl.close();\r\n      const num = parseInt(answer, 10);\r\n      if (num >= 1 && num <= choices.length) {\r\n        resolve(num - 1);\r\n      } else {\r\n        console.log('Invalid choice, selecting first option.');\r\n        resolve(0);\r\n      }\r\n    });\r\n  });\r\n}"
        }
      }
    },
    "src/utils/query.js": {
      "hash": "3fea4777a4709ce6c17e8bdd4228c30b",
      "size": 7270,
      "lastModified": "2026-02-08T13:05:55.898Z",
      "functions": [
        "search",
        "query",
        "traceCalls"
      ],
      "analysisTime": null,
      "functionHashes": {
        "search": {
          "hash": "1381e70cda4d6b90cf5428f28cacc69a",
          "line": 51,
          "endLine": 79,
          "size": 793,
          "async": false,
          "language": "javascript",
          "source": "function search(term) {\r\n  const results = [];\r\n  const termLower = term.toLowerCase();\r\n\r\n  functions.forEach(func => {\r\n    let score = 0;\r\n    const name = func.name || func.id;\r\n    const nameLower = name.toLowerCase();\r\n    const fileLower = func.file.toLowerCase();\r\n\r\n    // 1. Exact Name Match (Highest Priority)\r\n    if (nameLower === termLower) score += 100;\r\n\r\n    // 2. Name Contains Term\r\n    else if (nameLower.includes(termLower)) score += 50;\r\n\r\n    // 3. Tag Match\r\n    if (func.tags && func.tags.some(t => t.toLowerCase().includes(termLower))) score += 30;\r\n\r\n    // 4. File Path Match\r\n    if (fileLower.includes(termLower)) score += 10;\r\n\r\n    if (score > 0) {\r\n      results.push({ ...func, score });\r\n    }\r\n  });\r\n\r\n  return results.sort((a, b) => b.score - a.score);\r\n}"
        },
        "query": {
          "hash": "3e14a98aca830a778e374512b7392a12",
          "line": 83,
          "endLine": 146,
          "size": 2151,
          "async": false,
          "language": "javascript",
          "source": "function query(cmd, arg) {\r\n  // Smart Entry Point: If cmd is not a known command, treat as search\r\n  const knownCommands = [\r\n    'find-function', 'functions-in-file', 'calls-to', 'called-by',\r\n    'side-effects', 'entry-points', 'trace', 'stats', 'help'\r\n  ];\r\n\r\n  if (!knownCommands.includes(cmd)) {\r\n    // Treat 'cmd' as the search term, and 'arg' as extra search terms if any\r\n    const searchTerm = arg ? `${cmd} ${arg}` : cmd;\r\n    return search(searchTerm);\r\n  }\r\n\r\n  switch (cmd) {\r\n    case 'search':\r\n      return search(arg);\r\n\r\n    case 'find-function':\r\n      const exactMatches = Array.from(byName.get(arg) || []);\r\n      if (exactMatches.length > 0) return exactMatches;\r\n      // Fallback to search if no exact match\r\n      return search(arg);\r\n\r\n    case 'functions-in-file':\r\n      return byFile.get(arg) || [];\r\n\r\n    case 'calls-to':\r\n      return Array.from(calledByIndex.get(arg) || []);\r\n\r\n    case 'called-by':\r\n      const func = functions.find(f => (f.name || f.id) === arg);\r\n      return func ? func.calls : [];\r\n\r\n    case 'side-effects':\r\n      return functions.filter(f => f.effects.length > 0);\r\n\r\n    case 'entry-points':\r\n      // Functions called by few others (likely entry points)\r\n      return functions.filter(f => {\r\n        const name = f.name || f.id;\r\n        const callers = calledByIndex.get(name) || new Set();\r\n        return callers.size === 0 || f.name?.includes('main') || f.name?.includes('init');\r\n      });\r\n\r\n    case 'trace':\r\n      // Trace call path from function\r\n      return traceCalls(arg, 3);\r\n\r\n    case 'stats':\r\n      return {\r\n        totalFunctions: functions.length,\r\n        filesAnalyzed: byFile.size,\r\n        totalCalls: functions.reduce((sum, f) => sum + f.calls.length, 0),\r\n        withSideEffects: functions.filter(f => f.effects.length > 0).length,\r\n        effectTypes: [...new Set(functions.flatMap(f => f.effects))],\r\n        tags: [...new Set(functions.flatMap(f => f.tags || []))],\r\n        taggedFunctions: functions.filter(f => f.tags && f.tags.length > 0).length\r\n      };\r\n\r\n    case 'help':\r\n    default:\r\n      return { error: 'Unknown query command' };\r\n  }\r\n}"
        },
        "traceCalls": {
          "hash": "26b7fa749cf54a7421a46a506addd82a",
          "line": 148,
          "endLine": 163,
          "size": 462,
          "async": false,
          "language": "javascript",
          "source": "function traceCalls(funcName, depth = 3, visited = new Set()) {\r\n  if (depth === 0 || visited.has(funcName)) return [];\r\n\r\n  visited.add(funcName);\r\n\r\n  const func = functions.find(f => (f.name || f.id) === funcName);\r\n  if (!func) return [];\r\n\r\n  return {\r\n    function: funcName,\r\n    file: func.file,\r\n    line: func.line,\r\n    tags: func.tags,\r\n    calls: func.calls.slice(0, 10).map(called => traceCalls(called, depth - 1, visited)).filter(Boolean)\r\n  };\r\n}"
        }
      }
    },
    "src/utils/summarizer.js": {
      "hash": "990665808eb90cda16fab23038eff062",
      "size": 6667,
      "lastModified": "2025-11-09T04:20:42.000Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {}
    },
    "src/utils/summary-updater.js": {
      "hash": "67b0b3abab7c7fdedce788f013d3e5c8",
      "size": 10683,
      "lastModified": "2026-01-09T05:17:51.983Z",
      "functions": [
        "loadGraph",
        "generateL0",
        "generateL1",
        "generateL2",
        "updateSummaries"
      ],
      "analysisTime": null,
      "functionHashes": {
        "loadGraph": {
          "hash": "bcb51b89991c01b869d2bc94f85bba71",
          "line": 22,
          "endLine": 31,
          "size": 300,
          "async": false,
          "language": "javascript",
          "source": "function loadGraph() {\r\n  const graphPath = '.llm-context/graph.jsonl';\r\n  if (!existsSync(graphPath)) {\r\n    console.log('⚠ No graph.jsonl found');\r\n    return [];\r\n  }\r\n\r\n  const lines = readFileSync(graphPath, 'utf-8').split('\\n').filter(Boolean);\r\n  return lines.map(line => JSON.parse(line));\r\n}"
        },
        "generateL0": {
          "hash": "8abefb3869d7c7f3bf70027c60535085",
          "line": 36,
          "endLine": 128,
          "size": 3086,
          "async": false,
          "language": "javascript",
          "source": "function generateL0(functions) {\r\n  console.log('[1] Generating L0 (system overview)...');\r\n\r\n  // Group by file\r\n  const byFile = {};\r\n  functions.forEach(func => {\r\n    if (!byFile[func.file]) byFile[func.file] = [];\r\n    byFile[func.file].push(func);\r\n  });\r\n\r\n  // Group by domain (directory)\r\n  const byDomain = {};\r\n  Object.keys(byFile).forEach(file => {\r\n    const dir = dirname(file) || 'root';\r\n    if (!byDomain[dir]) byDomain[dir] = {};\r\n\r\n    const module = file.split('/').pop().replace('.js', '');\r\n    byDomain[dir][module] = byFile[file];\r\n  });\r\n\r\n  const totalFuncs = functions.length;\r\n  const totalCalls = functions.reduce((sum, f) => sum + f.calls.length, 0);\r\n  const effectTypes = new Set();\r\n  functions.forEach(f => f.effects.forEach(e => effectTypes.add(e)));\r\n\r\n  const entryPoints = functions.filter(f =>\r\n    f.name && (\r\n      f.name.includes('main') ||\r\n      f.name.includes('init') ||\r\n      f.name.includes('eval')\r\n    )\r\n  );\r\n\r\n  const L0 = `# LLM Context Tools - System Overview\r\n\r\n**Type**: Code analysis system for LLM-optimized context generation\r\n**Purpose**: Generate compact, semantically-rich code representations for LLM consumption\r\n**Architecture**: JavaScript modules with incremental update support\r\n\r\n## ⚡ Quick Queries (USE THESE before grep/read)\r\n\r\n**To understand this codebase, try these queries FIRST:**\r\n\r\n\\`\\`\\`bash\r\n# Find any function\r\nllm-context query find-function <name>\r\n\r\n# Understand dependencies\r\nllm-context query calls-to <name>      # Who calls this?\r\nllm-context query trace <name>         # Full call tree\r\n\r\n# Discover patterns\r\nllm-context entry-points               # ${entryPoints.length} entry points\r\nllm-context side-effects               # Functions with I/O\r\n\r\n# Statistics\r\nllm-context stats                      # Full statistics\r\n\\`\\`\\`\r\n\r\n**Why queries > grep:**\r\n- ✅ Show call relationships (grep can't)\r\n- ✅ Detect side effects (grep misses these)\r\n- ✅ Trace call trees (grep shows only text matches)\r\n- ✅ 80-95% fewer tokens needed\r\n\r\n## Statistics\r\n- **Files**: ${Object.keys(byFile).length} modules\r\n- **Functions**: ${totalFuncs} total\r\n- **Call relationships**: ${totalCalls}\r\n- **Side effects**: ${Array.from(effectTypes).join(', ') || 'none'}\r\n\r\n## Key Components\r\n${Object.keys(byDomain).map(domain => {\r\n  const modules = Object.keys(byDomain[domain]);\r\n  return `- **${domain}**: ${modules.join(', ')}`;\r\n}).join('\\n')}\r\n\r\n## Entry Points\r\n${entryPoints.length > 0 ? entryPoints.slice(0, 5).map(f => `- \\`${f.name}\\` (${f.file}:${f.line})`).join('\\n') : '- None detected'}\r\n\r\n## Architecture Pattern\r\n- **Manifest System**: Tracks file hashes for change detection\r\n- **Incremental Analysis**: Re-analyze only changed files\r\n- **Graph Management**: JSONL format for efficient updates\r\n- **Query Interface**: Fast lookups on function call graphs\r\n`;\r\n\r\n  mkdirSync('.llm-context/summaries', { recursive: true });\r\n  writeFileSync('.llm-context/summaries/L0-system.md', L0);\r\n  console.log(`    ✓ L0-system.md (${L0.length} chars, ~${Math.ceil(L0.length / 4)} tokens)`);\r\n\r\n  return L0;\r\n}"
        },
        "generateL1": {
          "hash": "448d0ebb34e8927dadcbf496d07fee4e",
          "line": 133,
          "endLine": 216,
          "size": 2685,
          "async": false,
          "language": "javascript",
          "source": "function generateL1(functions, changedFiles = null) {\r\n  console.log('[2] Generating L1 (domain summaries)...');\r\n\r\n  // Group by file\r\n  const byFile = {};\r\n  functions.forEach(func => {\r\n    if (!byFile[func.file]) byFile[func.file] = [];\r\n    byFile[func.file].push(func);\r\n  });\r\n\r\n  // Group by domain\r\n  const byDomain = {};\r\n  Object.keys(byFile).forEach(file => {\r\n    const dir = dirname(file) || 'root';\r\n    const module = file.split('/').pop().replace('.js', '');\r\n\r\n    if (!byDomain[dir]) byDomain[dir] = {};\r\n    byDomain[dir][module] = byFile[file];\r\n  });\r\n\r\n  // Load existing L1 if available\r\n  let existingL1 = [];\r\n  if (existsSync('.llm-context/summaries/L1-domains.json')) {\r\n    existingL1 = JSON.parse(readFileSync('.llm-context/summaries/L1-domains.json', 'utf-8'));\r\n  }\r\n\r\n  // Determine which domains were affected\r\n  const affectedDomains = new Set();\r\n  if (changedFiles) {\r\n    changedFiles.forEach(file => {\r\n      const dir = dirname(file) || 'root';\r\n      affectedDomains.add(dir);\r\n    });\r\n  } else {\r\n    // If no changed files specified, regenerate all\r\n    Object.keys(byDomain).forEach(dir => affectedDomains.add(dir));\r\n  }\r\n\r\n  console.log(`    Affected domains: ${Array.from(affectedDomains).join(', ')}`);\r\n\r\n  // Build L1 summaries\r\n  const L1Summaries = [];\r\n\r\n  // Keep existing summaries for unchanged domains\r\n  if (changedFiles) {\r\n    existingL1.forEach(summary => {\r\n      if (!affectedDomains.has(summary.domain)) {\r\n        L1Summaries.push(summary);\r\n        console.log(`    ↻ Kept: ${summary.domain} (unchanged)`);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Generate summaries for affected domains\r\n  Object.entries(byDomain).forEach(([domain, modules]) => {\r\n    if (!affectedDomains.has(domain) && changedFiles) return;\r\n\r\n    const domainFuncs = Object.values(modules).flat();\r\n    const funcCount = domainFuncs.length;\r\n    const moduleList = Object.keys(modules);\r\n\r\n    const domainEffects = new Set();\r\n    domainFuncs.forEach(f => f.effects.forEach(e => domainEffects.add(e)));\r\n\r\n    const summary = {\r\n      domain,\r\n      modules: moduleList,\r\n      functionCount: funcCount,\r\n      effects: Array.from(domainEffects),\r\n      keyFunctions: domainFuncs\r\n        .filter(f => f.calls.length > 3 || f.effects.length > 0)\r\n        .slice(0, 5)\r\n        .map(f => ({ name: f.name, file: f.file, line: f.line }))\r\n    };\r\n\r\n    L1Summaries.push(summary);\r\n    console.log(`    ✓ Updated: ${domain} (${funcCount} functions)`);\r\n  });\r\n\r\n  writeFileSync('.llm-context/summaries/L1-domains.json', JSON.stringify(L1Summaries, null, 2));\r\n  console.log(`    ✓ L1-domains.json (${L1Summaries.length} domains)`);\r\n\r\n  return L1Summaries;\r\n}"
        },
        "generateL2": {
          "hash": "3cb9d10a3e9e4b2db133037e996c3764",
          "line": 221,
          "endLine": 286,
          "size": 2110,
          "async": false,
          "language": "javascript",
          "source": "function generateL2(functions, changedFiles = null) {\r\n  console.log('[3] Generating L2 (module summaries)...');\r\n\r\n  // Group by file\r\n  const byFile = {};\r\n  functions.forEach(func => {\r\n    if (!byFile[func.file]) byFile[func.file] = [];\r\n    byFile[func.file].push(func);\r\n  });\r\n\r\n  // Load existing L2 if available\r\n  let existingL2 = [];\r\n  if (existsSync('.llm-context/summaries/L2-modules.json')) {\r\n    existingL2 = JSON.parse(readFileSync('.llm-context/summaries/L2-modules.json', 'utf-8'));\r\n  }\r\n\r\n  // Determine which files were affected\r\n  const affectedFiles = changedFiles ? new Set(changedFiles) : new Set(Object.keys(byFile));\r\n\r\n  console.log(`    Affected modules: ${affectedFiles.size}`);\r\n\r\n  const L2Summaries = [];\r\n\r\n  // Keep existing summaries for unchanged files\r\n  if (changedFiles) {\r\n    existingL2.forEach(summary => {\r\n      if (!affectedFiles.has(summary.file)) {\r\n        L2Summaries.push(summary);\r\n        console.log(`    ↻ Kept: ${summary.module} (unchanged)`);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Generate summaries for affected files\r\n  Object.entries(byFile).forEach(([file, funcs]) => {\r\n    if (!affectedFiles.has(file) && changedFiles) return;\r\n\r\n    const module = file.split('/').pop().replace('.js', '');\r\n    const exports = funcs.filter(f => f.calls.length > 5);\r\n    const effects = new Set();\r\n    funcs.forEach(f => f.effects.forEach(e => effects.add(e)));\r\n\r\n    const summary = {\r\n      file,\r\n      module,\r\n      functionCount: funcs.length,\r\n      exports: exports.map(f => f.name),\r\n      effects: Array.from(effects),\r\n      entryPoints: funcs\r\n        .filter(f => f.name && (\r\n          f.name.includes('main') ||\r\n          f.name.includes('process') ||\r\n          f.name.includes('init')\r\n        ))\r\n        .map(f => f.name)\r\n    };\r\n\r\n    L2Summaries.push(summary);\r\n    console.log(`    ✓ Updated: ${module} (${funcs.length} functions)`);\r\n  });\r\n\r\n  writeFileSync('.llm-context/summaries/L2-modules.json', JSON.stringify(L2Summaries, null, 2));\r\n  console.log(`    ✓ L2-modules.json (${L2Summaries.length} modules)`);\r\n\r\n  return L2Summaries;\r\n}"
        },
        "updateSummaries": {
          "hash": "2eba752cde81b2c5bbc654ddfedfeb05",
          "line": 292,
          "endLine": 325,
          "size": 1184,
          "async": false,
          "language": "javascript",
          "source": "function updateSummaries(changedFiles = null) {\r\n  const functions = loadGraph();\r\n\r\n  if (functions.length === 0) {\r\n    console.log('⚠ No functions in graph - nothing to summarize');\r\n    return;\r\n  }\r\n\r\n  console.log(`Loaded ${functions.length} functions from graph\\n`);\r\n\r\n  if (changedFiles && changedFiles.length > 0) {\r\n    console.log(`Incremental mode: ${changedFiles.length} files changed`);\r\n    console.log(`Changed files: ${changedFiles.join(', ')}\\n`);\r\n  } else {\r\n    console.log('Full regeneration mode\\n');\r\n  }\r\n\r\n  const L0 = generateL0(functions);\r\n  const L1 = generateL1(functions, changedFiles);\r\n  const L2 = generateL2(functions, changedFiles);\r\n\r\n  console.log('\\n=== Summary Update Complete ===');\r\n  console.log('Generated:');\r\n  console.log('  - L0-system.md');\r\n  console.log('  - L1-domains.json');\r\n  console.log('  - L2-modules.json');\r\n\r\n  if (changedFiles && changedFiles.length > 0) {\r\n    const domainsUpdated = new Set(changedFiles.map(f => dirname(f) || 'root')).size;\r\n    console.log(`\\nEfficiency:`);\r\n    console.log(`  - Domains regenerated: ${domainsUpdated}`);\r\n    console.log(`  - Modules regenerated: ${changedFiles.length}`);\r\n  }\r\n}"
        }
      }
    },
    "tsconfig.json": {
      "hash": "cc9c2f336a6aae16b5fc3cf8de16ceb7",
      "size": 295,
      "lastModified": "2026-01-11T10:45:22.771Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {}
    }
  },
  "globalStats": {
    "totalFunctions": 268,
    "totalCalls": 1277,
    "totalFiles": 34,
    "totalSize": 297881
  }
}