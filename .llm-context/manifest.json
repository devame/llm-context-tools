{
  "version": "2.0.0",
  "granularity": "function",
  "generated": "2026-01-11T06:04:45.290Z",
  "files": {
    "analyze.js": {
      "hash": "b038fbe60a05ad3a456a6228701e3e5e",
      "size": 4330,
      "lastModified": "2026-01-09T05:35:09.165Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {}
    },
    "ast-adapter.js": {
      "hash": "913072c80dba7e7cee448dd5d448a40f",
      "size": 8514,
      "lastModified": "2026-01-11T05:43:54.798Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {
        "constructor": {
          "hash": "764c8b37c63279fa428871490f4b1575",
          "line": 22,
          "endLine": 29,
          "size": 300,
          "async": false,
          "language": "javascript",
          "source": "constructor(tree, language, sourceCode, filePath) {\r\n    this.tree = tree;\r\n    this.language = language;\r\n    this.sourceCode = sourceCode;\r\n    this.filePath = filePath;\r\n    this.rootNode = tree.rootNode;\r\n    this.languageObj = tree.getLanguage();  // Tree-sitter Language object for queries\r\n  }"
        },
        "extractFunctions": {
          "hash": "ec7021244ec6a3660b74fa44dc7138b9",
          "line": 35,
          "endLine": 60,
          "size": 731,
          "async": false,
          "language": "javascript",
          "source": "extractFunctions() {\r\n    const functionQuery = getFunctionQuery(this.language);\r\n    if (!functionQuery || functionQuery.trim() === '') {\r\n      // Language doesn't have functions (e.g., JSON)\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const query = this.languageObj.query(functionQuery);\r\n      const matches = query.matches(this.rootNode);\r\n\r\n      const functions = [];\r\n\r\n      for (const match of matches) {\r\n        const metadata = this.extractFunctionMetadata(match);\r\n        if (metadata) {\r\n          functions.push(metadata);\r\n        }\r\n      }\r\n\r\n      return functions;\r\n    } catch (error) {\r\n      console.warn(`Failed to extract functions for ${this.language}: ${error.message}`);\r\n      return [];\r\n    }\r\n  }"
        },
        "extractFunctionMetadata": {
          "hash": "cb3db3d5a1d5149b508ee1982b40f3a0",
          "line": 68,
          "endLine": 126,
          "size": 1796,
          "async": false,
          "language": "javascript",
          "source": "extractFunctionMetadata(match) {\r\n    const captures = {};\r\n\r\n    // Organize captures by name\r\n    for (const capture of match.captures) {\r\n      captures[capture.name] = capture.node;\r\n    }\r\n\r\n    const functionNode = captures.function;\r\n    if (!functionNode) {\r\n      return null;\r\n    }\r\n\r\n    // Extract function name\r\n    const nameNode = captures.name;\r\n    const funcName = nameNode ? nameNode.text : 'anonymous';\r\n\r\n    // Extract parameters\r\n    const paramsNode = captures.params;\r\n    const params = paramsNode ? paramsNode.text : '';\r\n\r\n    // Extract function body\r\n    const bodyNode = captures.body || functionNode;\r\n\r\n    // Get location information\r\n    const startLine = functionNode.startPosition.row + 1;  // Tree-sitter uses 0-based rows\r\n    const endLine = functionNode.endPosition.row + 1;\r\n    const startCol = functionNode.startPosition.column;\r\n    const endCol = functionNode.endPosition.column;\r\n\r\n    // Extract source code\r\n    const source = functionNode.text;\r\n\r\n    // Compute hash\r\n    const hash = this.hashFunctionSource(source);\r\n\r\n    // Check for async/generator markers (JavaScript/TypeScript specific)\r\n    const isAsync = this.isAsyncFunction(functionNode);\r\n    const isGenerator = this.isGeneratorFunction(functionNode);\r\n\r\n    // Generate unique ID\r\n    const funcId = `${this.filePath}#${funcName}`;\r\n\r\n    return {\r\n      id: funcId,\r\n      name: funcName,\r\n      line: startLine,\r\n      endLine: endLine,\r\n      source: source,\r\n      hash: hash,\r\n      size: source.length,\r\n      params: params,\r\n      isAsync: isAsync,\r\n      isGenerator: isGenerator,\r\n      language: this.language,\r\n      node: functionNode,  // Keep reference for further analysis\r\n      bodyNode: bodyNode   // Keep body reference for call graph extraction\r\n    };\r\n  }"
        },
        "extractCallGraph": {
          "hash": "3c708b8795e689aa6ee412eeac7d5c77",
          "line": 133,
          "endLine": 162,
          "size": 763,
          "async": false,
          "language": "javascript",
          "source": "extractCallGraph(functionMetadata) {\r\n    if (!functionMetadata.bodyNode) {\r\n      return [];\r\n    }\r\n\r\n    const callQuery = getCallQuery(this.language);\r\n    if (!callQuery || callQuery.trim() === '') {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const query = this.languageObj.query(callQuery);\r\n      const matches = query.matches(functionMetadata.bodyNode);\r\n\r\n      const calls = new Set();\r\n\r\n      for (const match of matches) {\r\n        for (const capture of match.captures) {\r\n          if (capture.name === 'call') {\r\n            calls.add(capture.node.text);\r\n          }\r\n        }\r\n      }\r\n\r\n      return Array.from(calls);\r\n    } catch (error) {\r\n      console.warn(`Failed to extract call graph: ${error.message}`);\r\n      return [];\r\n    }\r\n  }"
        },
        "extractImports": {
          "hash": "b232c94d8fd67a0d7a1fd774182c3f4e",
          "line": 168,
          "endLine": 196,
          "size": 841,
          "async": false,
          "language": "javascript",
          "source": "extractImports() {\r\n    const importQuery = getImportQuery(this.language);\r\n    if (!importQuery || importQuery.trim() === '') {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const query = this.languageObj.query(importQuery);\r\n      const matches = query.matches(this.rootNode);\r\n\r\n      const imports = new Set();\r\n\r\n      for (const match of matches) {\r\n        for (const capture of match.captures) {\r\n          if (capture.name === 'source') {\r\n            // Remove quotes from string literals\r\n            let importPath = capture.node.text;\r\n            importPath = importPath.replace(/^['\"]|['\"]$/g, '');\r\n            imports.add(importPath);\r\n          }\r\n        }\r\n      }\r\n\r\n      return Array.from(imports);\r\n    } catch (error) {\r\n      console.warn(`Failed to extract imports: ${error.message}`);\r\n      return [];\r\n    }\r\n  }"
        },
        "isAsyncFunction": {
          "hash": "0abd30e7d89b56f1ac9ba1c2df8fce5f",
          "line": 204,
          "endLine": 213,
          "size": 366,
          "async": false,
          "language": "javascript",
          "source": "isAsyncFunction(node) {\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n      return false;\r\n    }\r\n\r\n    // Check if node has 'async' keyword\r\n    // This is a heuristic check - Tree-sitter nodes don't always expose this directly\r\n    const source = node.text;\r\n    return /^\\s*async\\s+(function|[\\w]+\\s*=>|\\(.*\\)\\s*=>)/.test(source);\r\n  }"
        },
        "isGeneratorFunction": {
          "hash": "63239ce5258a9a475d7e3b03beb0a2d6",
          "line": 221,
          "endLine": 229,
          "size": 291,
          "async": false,
          "language": "javascript",
          "source": "isGeneratorFunction(node) {\r\n    if (!['javascript', 'typescript', 'tsx'].includes(this.language)) {\r\n      return false;\r\n    }\r\n\r\n    // Check if node has generator marker (*)\r\n    const source = node.text;\r\n    return /^\\s*function\\s*\\*/.test(source) || /\\*\\s*\\w+\\s*\\(/.test(source);\r\n  }"
        },
        "hashFunctionSource": {
          "hash": "c621bba34f565862e1708fed082a7f78",
          "line": 237,
          "endLine": 241,
          "size": 198,
          "async": false,
          "language": "javascript",
          "source": "hashFunctionSource(source) {\r\n    // Normalize source (remove leading/trailing whitespace)\r\n    const normalized = source.trim();\r\n    return createHash('md5').update(normalized).digest('hex');\r\n  }"
        },
        "extractFunctionsWithNodes": {
          "hash": "27b406b2cccbcbc782894001570c3207",
          "line": 247,
          "endLine": 254,
          "size": 213,
          "async": false,
          "language": "javascript",
          "source": "extractFunctionsWithNodes() {\r\n    const functions = this.extractFunctions();\r\n    return functions.map(metadata => ({\r\n      metadata,\r\n      node: metadata.node,\r\n      bodyNode: metadata.bodyNode\r\n    }));\r\n  }"
        },
        "extractSourceByLines": {
          "hash": "c99e8a10e6e2186545eafd3f8446efc7",
          "line": 262,
          "endLine": 265,
          "size": 155,
          "async": false,
          "language": "javascript",
          "source": "extractSourceByLines(startLine, endLine) {\r\n    const lines = this.sourceCode.split('\\n');\r\n    return lines.slice(startLine - 1, endLine).join('\\n');\r\n  }"
        },
        "createAdapter": {
          "hash": "b13ec9929d64f1afa7c4df21400cba3a",
          "line": 276,
          "endLine": 278,
          "size": 129,
          "async": false,
          "language": "javascript",
          "source": "function createAdapter(tree, language, sourceCode, filePath) {\r\n  return new ASTAdapter(tree, language, sourceCode, filePath);\r\n}"
        }
      }
    },
    "bin/llm-context.js": {
      "hash": "d3385d7e23f11ae62886e11dacd126c5",
      "size": 6966,
      "lastModified": "2026-01-09T05:35:54.772Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {
        "runScript": {
          "hash": "b0825201fbbebf4ceb266c27456a10e6",
          "line": 23,
          "endLine": 40,
          "size": 468,
          "async": false,
          "language": "javascript",
          "source": "function runScript(scriptPath, extraArgs = []) {\r\n  const fullPath = join(rootDir, scriptPath);\r\n\r\n  if (!existsSync(fullPath)) {\r\n    console.error(`Error: Script not found: ${scriptPath}`);\r\n    process.exit(1);\r\n  }\r\n\r\n  try {\r\n    const allArgs = [...extraArgs, ...commandArgs].join(' ');\r\n    execSync(`node \"${fullPath}\" ${allArgs}`, {\r\n      stdio: 'inherit',\r\n      cwd: process.cwd()\r\n    });\r\n  } catch (error) {\r\n    process.exit(error.status || 1);\r\n  }\r\n}"
        }
      }
    },
    "change-detector.js": {
      "hash": "b8796ed5c3d57fff2390b0e3e60594a6",
      "size": 5929,
      "lastModified": "2025-12-02T06:19:35.953Z",
      "functions": [
        "findJsFiles",
        "walk",
        "loadManifest",
        "printSummary",
        "main",
        "hashFile",
        "detectChanges"
      ],
      "analysisTime": null,
      "functionHashes": {
        "hashFile": {
          "hash": "71c5b221aa6e627ab1a7e7f345955f5b",
          "line": 23,
          "endLine": 27,
          "size": 156,
          "async": false,
          "language": "javascript",
          "source": "function hashFile(filePath) {\r\n  const content = readFileSync(filePath);\r\n  const hash = createHash('md5').update(content).digest('hex');\r\n  return hash;\r\n}"
        },
        "findJsFiles": {
          "hash": "5dfd8a040dad0f5839e142b52453d552",
          "line": 35,
          "endLine": 59,
          "size": 672,
          "async": false,
          "language": "javascript",
          "source": "function findJsFiles(dir = '.', ignore = ['node_modules', '.git', '.llm-context']) {\r\n  const files = [];\r\n\r\n  function walk(currentDir) {\r\n    const entries = readdirSync(currentDir, { withFileTypes: true });\r\n\r\n    for (const entry of entries) {\r\n      const fullPath = join(currentDir, entry.name);\r\n      const relativePath = relative('.', fullPath);\r\n\r\n      if (ignore.some(pattern => relativePath.includes(pattern))) {\r\n        continue;\r\n      }\r\n\r\n      if (entry.isDirectory()) {\r\n        walk(fullPath);\r\n      } else if (entry.isFile() && entry.name.endsWith('.js')) {\r\n        files.push(relativePath);\r\n      }\r\n    }\r\n  }\r\n\r\n  walk(dir);\r\n  return files;\r\n}"
        },
        "walk": {
          "hash": "947d3e839c5cd633a60835f9038c0a9d",
          "line": 38,
          "endLine": 55,
          "size": 525,
          "async": false,
          "language": "javascript",
          "source": "function walk(currentDir) {\r\n    const entries = readdirSync(currentDir, { withFileTypes: true });\r\n\r\n    for (const entry of entries) {\r\n      const fullPath = join(currentDir, entry.name);\r\n      const relativePath = relative('.', fullPath);\r\n\r\n      if (ignore.some(pattern => relativePath.includes(pattern))) {\r\n        continue;\r\n      }\r\n\r\n      if (entry.isDirectory()) {\r\n        walk(fullPath);\r\n      } else if (entry.isFile() && entry.name.endsWith('.js')) {\r\n        files.push(relativePath);\r\n      }\r\n    }\r\n  }"
        },
        "loadManifest": {
          "hash": "daa8b59edff474f097b624ad4a9ffc45",
          "line": 65,
          "endLine": 74,
          "size": 284,
          "async": false,
          "language": "javascript",
          "source": "function loadManifest() {\r\n  const manifestPath = '.llm-context/manifest.json';\r\n\r\n  if (!existsSync(manifestPath)) {\r\n    console.log('‚ö† No manifest.json found - run manifest-generator.js first');\r\n    return null;\r\n  }\r\n\r\n  return JSON.parse(readFileSync(manifestPath, 'utf-8'));\r\n}"
        },
        "detectChanges": {
          "hash": "4dd42b42a9b3f93df5e6e60bce7d2851",
          "line": 80,
          "endLine": 153,
          "size": 2019,
          "async": false,
          "language": "javascript",
          "source": "function detectChanges() {\r\n  console.log('[1] Loading manifest...');\r\n  const manifest = loadManifest();\r\n\r\n  if (!manifest) {\r\n    return {\r\n      added: [],\r\n      modified: [],\r\n      deleted: [],\r\n      unchanged: [],\r\n      needsFullAnalysis: true\r\n    };\r\n  }\r\n\r\n  console.log(`    Last analysis: ${manifest.generated}`);\r\n  console.log(`    Files tracked: ${Object.keys(manifest.files).length}\\n`);\r\n\r\n  console.log('[2] Discovering current files...');\r\n  const currentFiles = findJsFiles();\r\n  console.log(`    Found ${currentFiles.length} JavaScript files\\n`);\r\n\r\n  console.log('[3] Computing changes...');\r\n\r\n  const manifestFiles = new Set(Object.keys(manifest.files));\r\n  const currentFilesSet = new Set(currentFiles);\r\n\r\n  const added = [];\r\n  const modified = [];\r\n  const deleted = [];\r\n  const unchanged = [];\r\n\r\n  // Check for new and modified files\r\n  for (const filePath of currentFiles) {\r\n    if (!manifestFiles.has(filePath)) {\r\n      // New file\r\n      added.push(filePath);\r\n      console.log(`    + ${filePath} (NEW)`);\r\n    } else {\r\n      // Existing file - check hash\r\n      const currentHash = hashFile(filePath);\r\n      const manifestHash = manifest.files[filePath].hash;\r\n\r\n      if (currentHash !== manifestHash) {\r\n        modified.push(filePath);\r\n        console.log(`    M ${filePath} (MODIFIED)`);\r\n        console.log(`      Old: ${manifestHash.substring(0, 12)}...`);\r\n        console.log(`      New: ${currentHash.substring(0, 12)}...`);\r\n      } else {\r\n        unchanged.push(filePath);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check for deleted files\r\n  for (const filePath of manifestFiles) {\r\n    if (!currentFilesSet.has(filePath)) {\r\n      deleted.push(filePath);\r\n      console.log(`    - ${filePath} (DELETED)`);\r\n    }\r\n  }\r\n\r\n  if (added.length === 0 && modified.length === 0 && deleted.length === 0) {\r\n    console.log('    ‚úì No changes detected');\r\n  }\r\n\r\n  return {\r\n    added,\r\n    modified,\r\n    deleted,\r\n    unchanged,\r\n    needsFullAnalysis: false,\r\n    manifest\r\n  };\r\n}"
        },
        "printSummary": {
          "hash": "0418a6235631b007d157dfbd0b687b49",
          "line": 159,
          "endLine": 191,
          "size": 1333,
          "async": false,
          "language": "javascript",
          "source": "function printSummary(report) {\r\n  console.log('\\n=== Change Summary ===');\r\n\r\n  if (report.needsFullAnalysis) {\r\n    console.log('Status: Full analysis needed (no existing manifest)');\r\n    return;\r\n  }\r\n\r\n  const total = report.added.length + report.modified.length + report.deleted.length;\r\n\r\n  console.log(`Total files: ${report.added.length + report.modified.length + report.unchanged.length}`);\r\n  console.log(`Changes detected: ${total}`);\r\n  console.log(`  Added: ${report.added.length}`);\r\n  console.log(`  Modified: ${report.modified.length}`);\r\n  console.log(`  Deleted: ${report.deleted.length}`);\r\n  console.log(`  Unchanged: ${report.unchanged.length}`);\r\n\r\n  if (total === 0) {\r\n    console.log('\\n‚úì All files up to date - no re-analysis needed!');\r\n  } else {\r\n    const percentChanged = ((total / (total + report.unchanged.length)) * 100).toFixed(1);\r\n    console.log(`\\nRe-analysis needed for ${total} files (${percentChanged}% of codebase)`);\r\n\r\n    // Estimate time savings\r\n    const unchangedCount = report.unchanged.length;\r\n    if (unchangedCount > 0) {\r\n      console.log(`\\nEstimated savings:`);\r\n      console.log(`  Files skipped: ${unchangedCount}`);\r\n      console.log(`  Approximate time saved: ${(unchangedCount * 0.5).toFixed(1)}s`);\r\n      console.log(`  (Assuming ~500ms per file)`);\r\n    }\r\n  }\r\n}"
        },
        "main": {
          "hash": "4f9eb79d178d556a82c3fc56d520eb7d",
          "line": 196,
          "endLine": 200,
          "size": 98,
          "async": false,
          "language": "javascript",
          "source": "function main() {\r\n  const report = detectChanges();\r\n  printSummary(report);\r\n  return report;\r\n}"
        }
      }
    },
    "claude-setup.js": {
      "hash": "842459cd5f63a09856235e5e0178472c",
      "size": 5762,
      "lastModified": "2026-01-09T05:34:48.075Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {
        "setupClaudeIntegration": {
          "hash": "ad84d2ddd62c13f77b806d9055946d15",
          "line": 18,
          "endLine": 41,
          "size": 738,
          "async": false,
          "language": "javascript",
          "source": "function setupClaudeIntegration(options = {}) {\r\n  const { projectName = 'this project', force = false } = options;\r\n\r\n  const claudeDir = join(process.cwd(), '.claude');\r\n  const claudeMdPath = join(claudeDir, 'CLAUDE.md');\r\n\r\n  // Check if already exists\r\n  if (existsSync(claudeMdPath) && !force) {\r\n    console.log('   ‚ÑπÔ∏è  .claude/CLAUDE.md already exists (use --force to overwrite)');\r\n    return false;\r\n  }\r\n\r\n  // Create .claude directory\r\n  mkdirSync(claudeDir, { recursive: true });\r\n\r\n  // Generate CLAUDE.md content\r\n  const claudeMd = generateClaudeMd(projectName);\r\n\r\n  // Write file\r\n  writeFileSync(claudeMdPath, claudeMd);\r\n\r\n  console.log('   ‚úì Generated .claude/CLAUDE.md (Claude Code integration)');\r\n  return true;\r\n}"
        },
        "generateClaudeMd": {
          "hash": "473a6ce3cff338016eb49ed9fcedd8ec",
          "line": 48,
          "endLine": 168,
          "size": 3508,
          "async": false,
          "language": "javascript",
          "source": "function generateClaudeMd(projectName) {\r\n  return `# ${projectName} - LLM Context Instructions\r\n\r\n## üö® MANDATORY: Query-First Exploration\r\n\r\n**This codebase has llm-context analysis available.**\r\n\r\n### BEFORE using Grep/Bash/Read for code exploration:\r\n\r\n1. **Check if \\`.llm-context/\\` exists** (it does in this project)\r\n2. **Use queries FIRST**:\r\n   \\`\\`\\`bash\r\n   llm-context query find-function <name>     # Find & describe function\r\n   llm-context query calls-to <name>          # Who calls this?\r\n   llm-context query trace <name>             # Full call tree\r\n   llm-context side-effects                   # Functions with I/O\r\n   llm-context entry-points                   # Entry points\r\n   \\`\\`\\`\r\n3. **Only use grep/read** if queries insufficient\r\n\r\n### Why This Matters\r\n\r\n**Grep/Bash limitations:**\r\n- ‚ùå Shows only text matches\r\n- ‚ùå Misses call relationships\r\n- ‚ùå Doesn't show side effects\r\n- ‚ùå No architectural context\r\n\r\n**Query advantages:**\r\n- ‚úÖ Shows semantic relationships\r\n- ‚úÖ Includes call graphs\r\n- ‚úÖ Detects side effects (file_io, network, database)\r\n- ‚úÖ Identifies entry points\r\n- ‚úÖ 80-95% fewer tokens\r\n\r\n### Examples\r\n\r\n**‚ùå Anti-pattern (what NOT to do):**\r\n\\`\\`\\`bash\r\n# DON'T: Use grep when queries exist\r\ngrep -r \"someFunction\" --include=\"*.js\"\r\n\\`\\`\\`\r\n\r\n**‚úÖ Correct pattern:**\r\n\\`\\`\\`bash\r\n# DO: Use queries first\r\nllm-context query find-function someFunction\r\n# Shows: signature, calls, side effects, patterns, line number\r\n\r\n# Then if needed:\r\nllm-context query calls-to someFunction\r\n# Shows: which functions call it\r\n\r\n# Only read source for implementation details:\r\ncat file.js | sed -n '42,100p'\r\n\\`\\`\\`\r\n\r\n## Development Workflow\r\n\r\n### Understanding Codebase (First Time)\r\n\\`\\`\\`bash\r\n# 1. Read progressive disclosure\r\ncat .llm-context/summaries/L0-system.md  # System overview\r\ncat .llm-context/summaries/L1-domains.json  # Domain boundaries\r\nllm-context stats  # Statistics\r\n\r\n# 2. Explore specific areas\r\nllm-context entry-points  # Where does execution start?\r\nllm-context side-effects  # What does I/O?\r\n\r\n# 3. Deep dive with queries\r\nllm-context query trace <entry-point>  # Understand flow\r\n\\`\\`\\`\r\n\r\n### After Code Changes\r\n\\`\\`\\`bash\r\n# Incremental analysis (99% faster)\r\nllm-context analyze\r\n\r\n# Check what changed\r\nllm-context check-changes\r\n\\`\\`\\`\r\n\r\n### Debugging\r\n\\`\\`\\`bash\r\n# Find function and understand context\r\nllm-context query find-function <buggy-func>\r\nllm-context query calls-to <buggy-func>  # Who calls it?\r\nllm-context query trace <buggy-func>     # Full call path\r\n\r\n# Check for side effects\r\nllm-context side-effects | grep <buggy-func>\r\n\\`\\`\\`\r\n\r\n## Common Tasks\r\n\r\n| Task | Command |\r\n|------|---------|\r\n| Analyze codebase | \\`llm-context analyze\\` |\r\n| Find function | \\`llm-context query find-function <name>\\` |\r\n| Find callers | \\`llm-context query calls-to <name>\\` |\r\n| Trace calls | \\`llm-context query trace <name>\\` |\r\n| Side effects | \\`llm-context side-effects\\` |\r\n| Statistics | \\`llm-context stats\\` |\r\n| Entry points | \\`llm-context entry-points\\` |\r\n\r\n## Success Indicators\r\n\r\nYou're using this tool correctly when:\r\n1. ‚úÖ You read L0 summary before exploring code\r\n2. ‚úÖ You use queries instead of grep for function lookups\r\n3. ‚úÖ You mention side effects when discussing functions\r\n4. ‚úÖ You run incremental analysis after changes\r\n5. ‚úÖ Your token usage is 50-95% lower than raw file reading\r\n\r\n---\r\n\r\n*This file was auto-generated by llm-context tools.*\r\n*Learn more: https://github.com/devame/llm-context-tools*\r\n`;\r\n}"
        }
      }
    },
    "dependency-analyzer.js": {
      "hash": "ba4d56e44a040a06c18f3bdc18d18c13",
      "size": 10937,
      "lastModified": "2025-12-02T06:19:35.953Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {
        "loadConfig": {
          "hash": "e5d4ee6d6d71f6ddde52267611e3fe8c",
          "line": 17,
          "endLine": 25,
          "size": 233,
          "async": false,
          "language": "javascript",
          "source": "function loadConfig() {\r\n  const configPath = './llm-context.config.json';\r\n\r\n  if (!existsSync(configPath)) {\r\n    return { analysis: { trackDependencies: false } };\r\n  }\r\n\r\n  return JSON.parse(readFileSync(configPath, 'utf-8'));\r\n}"
        },
        "loadGraph": {
          "hash": "3531f2f406780d18bdf509653c26c2d0",
          "line": 31,
          "endLine": 40,
          "size": 258,
          "async": false,
          "language": "javascript",
          "source": "function loadGraph() {\r\n  const graphPath = '.llm-context/graph.jsonl';\r\n\r\n  if (!existsSync(graphPath)) {\r\n    return [];\r\n  }\r\n\r\n  const lines = readFileSync(graphPath, 'utf-8').split('\\n').filter(Boolean);\r\n  return lines.map(line => JSON.parse(line));\r\n}"
        },
        "buildDependencyGraph": {
          "hash": "11a863d178c19d264d4cc73fa1c761d6",
          "line": 47,
          "endLine": 79,
          "size": 1033,
          "async": false,
          "language": "javascript",
          "source": "function buildDependencyGraph(functions) {\r\n  const dependencies = new Map(); // function -> functions it depends on\r\n  const dependents = new Map();   // function -> functions that depend on it\r\n  const functionMap = new Map();  // name -> full entry\r\n\r\n  // Index functions by name\r\n  for (const func of functions) {\r\n    const name = func.name || func.id;\r\n    functionMap.set(name, func);\r\n    dependencies.set(name, new Set());\r\n    dependents.set(name, new Set());\r\n  }\r\n\r\n  // Build dependency relationships\r\n  for (const func of functions) {\r\n    const name = func.name || func.id;\r\n    const calls = func.calls || [];\r\n\r\n    for (const calledName of calls) {\r\n      // Only track dependencies to functions we know about\r\n      if (functionMap.has(calledName)) {\r\n        dependencies.get(name).add(calledName);\r\n        dependents.get(calledName).add(name);\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    dependencies,  // what each function depends on\r\n    dependents,    // what depends on each function\r\n    functionMap\r\n  };\r\n}"
        },
        "computeImpactSet": {
          "hash": "d970394d0508399237a83d917abce5cb",
          "line": 88,
          "endLine": 116,
          "size": 718,
          "async": false,
          "language": "javascript",
          "source": "function computeImpactSet(functionName, dependents, maxDepth = 10) {\r\n  const impacted = new Set();\r\n  const queue = [[functionName, 0]]; // [name, depth]\r\n  const visited = new Set();\r\n\r\n  while (queue.length > 0) {\r\n    const [current, depth] = queue.shift();\r\n\r\n    if (visited.has(current) || depth > maxDepth) {\r\n      continue;\r\n    }\r\n\r\n    visited.add(current);\r\n\r\n    if (current !== functionName) {\r\n      impacted.add(current);\r\n    }\r\n\r\n    // Add all functions that depend on current\r\n    const deps = dependents.get(current) || new Set();\r\n    for (const dependent of deps) {\r\n      if (!visited.has(dependent)) {\r\n        queue.push([dependent, depth + 1]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return impacted;\r\n}"
        },
        "findEntryPoints": {
          "hash": "e24fc5fa7bc1d1407db6368133d3d03b",
          "line": 124,
          "endLine": 140,
          "size": 459,
          "async": false,
          "language": "javascript",
          "source": "function findEntryPoints(dependents, maxCallers = 2) {\r\n  const entryPoints = [];\r\n\r\n  for (const [funcName, callers] of dependents) {\r\n    if (callers.size <= maxCallers ||\r\n        funcName.includes('main') ||\r\n        funcName.includes('init') ||\r\n        funcName.includes('start')) {\r\n      entryPoints.push({\r\n        name: funcName,\r\n        callers: callers.size\r\n      });\r\n    }\r\n  }\r\n\r\n  return entryPoints.sort((a, b) => a.callers - b.callers);\r\n}"
        },
        "findLeafFunctions": {
          "hash": "cfa0a3660a275ca1e2a849c2aab98da2",
          "line": 147,
          "endLine": 157,
          "size": 209,
          "async": false,
          "language": "javascript",
          "source": "function findLeafFunctions(dependencies) {\r\n  const leaves = [];\r\n\r\n  for (const [funcName, deps] of dependencies) {\r\n    if (deps.size === 0) {\r\n      leaves.push(funcName);\r\n    }\r\n  }\r\n\r\n  return leaves;\r\n}"
        },
        "detectCycles": {
          "hash": "2f030a306346c4be54fa1c228db2f034",
          "line": 164,
          "endLine": 203,
          "size": 892,
          "async": false,
          "language": "javascript",
          "source": "function detectCycles(dependencies) {\r\n  const cycles = [];\r\n  const visited = new Set();\r\n  const recursionStack = new Set();\r\n  const path = [];\r\n\r\n  function dfs(node) {\r\n    visited.add(node);\r\n    recursionStack.add(node);\r\n    path.push(node);\r\n\r\n    const deps = dependencies.get(node) || new Set();\r\n\r\n    for (const dep of deps) {\r\n      if (!visited.has(dep)) {\r\n        if (dfs(dep)) {\r\n          return true;\r\n        }\r\n      } else if (recursionStack.has(dep)) {\r\n        // Found cycle\r\n        const cycleStart = path.indexOf(dep);\r\n        const cycle = path.slice(cycleStart);\r\n        cycle.push(dep); // Close the cycle\r\n        cycles.push(cycle);\r\n      }\r\n    }\r\n\r\n    path.pop();\r\n    recursionStack.delete(node);\r\n    return false;\r\n  }\r\n\r\n  for (const node of dependencies.keys()) {\r\n    if (!visited.has(node)) {\r\n      dfs(node);\r\n    }\r\n  }\r\n\r\n  return cycles;\r\n}"
        },
        "dfs": {
          "hash": "e814f6f119c16230bf1f09c7bca596c9",
          "line": 214,
          "endLine": 233,
          "size": 429,
          "async": false,
          "language": "javascript",
          "source": "function dfs(node, depth) {\r\n    if (visited.has(node)) {\r\n      return 0; // Avoid cycles\r\n    }\r\n\r\n    visited.add(node);\r\n\r\n    const deps = dependencies.get(node) || new Set();\r\n    if (deps.size === 0) {\r\n      return depth;\r\n    }\r\n\r\n    let maxDepth = depth;\r\n    for (const dep of deps) {\r\n      const childDepth = dfs(dep, depth + 1);\r\n      maxDepth = Math.max(maxDepth, childDepth);\r\n    }\r\n\r\n    return maxDepth;\r\n  }"
        },
        "computeDependencyDepth": {
          "hash": "0ba439aa57155b92e2157b1bc2df6979",
          "line": 211,
          "endLine": 236,
          "size": 563,
          "async": false,
          "language": "javascript",
          "source": "function computeDependencyDepth(functionName, dependencies) {\r\n  const visited = new Set();\r\n\r\n  function dfs(node, depth) {\r\n    if (visited.has(node)) {\r\n      return 0; // Avoid cycles\r\n    }\r\n\r\n    visited.add(node);\r\n\r\n    const deps = dependencies.get(node) || new Set();\r\n    if (deps.size === 0) {\r\n      return depth;\r\n    }\r\n\r\n    let maxDepth = depth;\r\n    for (const dep of deps) {\r\n      const childDepth = dfs(dep, depth + 1);\r\n      maxDepth = Math.max(maxDepth, childDepth);\r\n    }\r\n\r\n    return maxDepth;\r\n  }\r\n\r\n  return dfs(functionName, 0);\r\n}"
        },
        "analyzeDependencies": {
          "hash": "1e272bd8c3e40494a53658fc85cfcff8",
          "line": 241,
          "endLine": 324,
          "size": 2837,
          "async": false,
          "language": "javascript",
          "source": "function analyzeDependencies() {\r\n  console.log('=== Dependency Analyzer ===\\n');\r\n\r\n  const config = loadConfig();\r\n  const trackDeps = config.analysis?.trackDependencies || false;\r\n\r\n  if (!trackDeps) {\r\n    console.log('Dependency tracking disabled in config');\r\n    console.log('Set analysis.trackDependencies = true to enable');\r\n    return null;\r\n  }\r\n\r\n  const functions = loadGraph();\r\n  console.log(`[1] Loaded ${functions.length} functions from graph\\n`);\r\n\r\n  const { dependencies, dependents, functionMap } = buildDependencyGraph(functions);\r\n  console.log(`[2] Built dependency graph`);\r\n  console.log(`    Total dependencies: ${Array.from(dependencies.values()).reduce((sum, deps) => sum + deps.size, 0)}\\n`);\r\n\r\n  // Find entry points\r\n  const entryPoints = findEntryPoints(dependents);\r\n  console.log(`[3] Entry points (${entryPoints.length}):`);\r\n  for (const ep of entryPoints.slice(0, 10)) {\r\n    console.log(`    - ${ep.name} (${ep.callers} callers)`);\r\n  }\r\n  if (entryPoints.length > 10) {\r\n    console.log(`    ... and ${entryPoints.length - 10} more`);\r\n  }\r\n\r\n  // Find leaf functions\r\n  const leaves = findLeafFunctions(dependencies);\r\n  console.log(`\\n[4] Leaf functions (${leaves.length}):`);\r\n  console.log(`    ${leaves.slice(0, 20).join(', ')}`);\r\n  if (leaves.length > 20) {\r\n    console.log(`    ... and ${leaves.length - 20} more`);\r\n  }\r\n\r\n  // Detect cycles\r\n  const cycles = detectCycles(dependencies);\r\n  if (cycles.length > 0) {\r\n    console.log(`\\n[5] ‚ö† Dependency cycles detected (${cycles.length}):`);\r\n    for (const cycle of cycles.slice(0, 5)) {\r\n      console.log(`    ${cycle.join(' ‚Üí ')}`);\r\n    }\r\n    if (cycles.length > 5) {\r\n      console.log(`    ... and ${cycles.length - 5} more`);\r\n    }\r\n  } else {\r\n    console.log(`\\n[5] ‚úì No dependency cycles detected`);\r\n  }\r\n\r\n  // Save dependency graph\r\n  const depGraph = {\r\n    version: '1.0.0',\r\n    generated: new Date().toISOString(),\r\n    stats: {\r\n      totalFunctions: functions.length,\r\n      totalDependencies: Array.from(dependencies.values()).reduce((sum, deps) => sum + deps.size, 0),\r\n      entryPoints: entryPoints.length,\r\n      leafFunctions: leaves.length,\r\n      cycles: cycles.length\r\n    },\r\n    entryPoints,\r\n    leaves,\r\n    cycles,\r\n    dependencies: Object.fromEntries(\r\n      Array.from(dependencies.entries()).map(([name, deps]) => [\r\n        name,\r\n        Array.from(deps)\r\n      ])\r\n    ),\r\n    dependents: Object.fromEntries(\r\n      Array.from(dependents.entries()).map(([name, deps]) => [\r\n        name,\r\n        Array.from(deps)\r\n      ])\r\n    )\r\n  };\r\n\r\n  writeFileSync('.llm-context/dependencies.json', JSON.stringify(depGraph, null, 2));\r\n  console.log(`\\n‚úì Dependency graph saved to .llm-context/dependencies.json`);\r\n\r\n  return { dependencies, dependents, functionMap, cycles, entryPoints, leaves };\r\n}"
        },
        "analyzeImpact": {
          "hash": "7d22ad21caa23506795578408f263b6b",
          "line": 331,
          "endLine": 377,
          "size": 1571,
          "async": false,
          "language": "javascript",
          "source": "function analyzeImpact(changedFunctions) {\r\n  const functions = loadGraph();\r\n  const { dependencies, dependents, functionMap } = buildDependencyGraph(functions);\r\n\r\n  const config = loadConfig();\r\n  const maxDepth = config.analysis?.maxCallDepth || 10;\r\n\r\n  const impactReport = {\r\n    changedFunctions,\r\n    totalImpacted: new Set(),\r\n    perFunctionImpact: {}\r\n  };\r\n\r\n  console.log('\\n=== Impact Analysis ===\\n');\r\n\r\n  for (const funcName of changedFunctions) {\r\n    const impacted = computeImpactSet(funcName, dependents, maxDepth);\r\n\r\n    impactReport.perFunctionImpact[funcName] = {\r\n      directCallers: Array.from(dependents.get(funcName) || new Set()),\r\n      totalImpacted: impacted.size,\r\n      impactedFunctions: Array.from(impacted)\r\n    };\r\n\r\n    // Add to total impacted set\r\n    for (const imp of impacted) {\r\n      impactReport.totalImpacted.add(imp);\r\n    }\r\n\r\n    console.log(`${funcName}:`);\r\n    console.log(`  Direct callers: ${impactReport.perFunctionImpact[funcName].directCallers.length}`);\r\n    console.log(`  Total impacted: ${impacted.size}`);\r\n\r\n    if (impacted.size > 0 && impacted.size <= 10) {\r\n      console.log(`  Affected functions: ${Array.from(impacted).join(', ')}`);\r\n    } else if (impacted.size > 10) {\r\n      console.log(`  Affected functions: ${Array.from(impacted).slice(0, 10).join(', ')}...`);\r\n    }\r\n\r\n    console.log('');\r\n  }\r\n\r\n  impactReport.totalImpacted = Array.from(impactReport.totalImpacted);\r\n  console.log(`Total unique functions impacted: ${impactReport.totalImpacted.length}\\n`);\r\n\r\n  return impactReport;\r\n}"
        }
      }
    },
    "function-change-detector.js": {
      "hash": "40df00767b5fb3cb4880d60231a56ea6",
      "size": 9067,
      "lastModified": "2026-01-11T04:29:46.892Z",
      "functions": [
        "loadConfig",
        "extractCurrentFunctions",
        "detectFunctionChanges",
        "detectAllFunctionChanges",
        "printFunctionChangeSummary"
      ],
      "analysisTime": null,
      "functionHashes": {
        "loadConfig": {
          "hash": "1cb52fe4e91e7b7016bc44fa014e40a1",
          "line": 17,
          "endLine": 25,
          "size": 214,
          "async": false,
          "language": "javascript",
          "source": "function loadConfig() {\r\n  const configPath = './llm-context.config.json';\r\n\r\n  if (!existsSync(configPath)) {\r\n    return { granularity: 'file' };\r\n  }\r\n\r\n  return JSON.parse(readFileSync(configPath, 'utf-8'));\r\n}"
        },
        "extractCurrentFunctions": {
          "hash": "f6981426b1f3ec107a415334f3035b82",
          "line": 32,
          "endLine": 61,
          "size": 861,
          "async": true,
          "language": "javascript",
          "source": "async function extractCurrentFunctions(filePath) {\r\n  const functionMap = new Map();\r\n\r\n  try {\r\n    const source = readFileSync(filePath, 'utf-8');\r\n\r\n    // Detect language and parse with Tree-sitter\r\n    const language = ParserFactory.detectLanguage(filePath);\r\n    if (!language) {\r\n      console.log(`    Warning: Unsupported file type: ${filePath}`);\r\n      return functionMap;\r\n    }\r\n\r\n    const { tree } = await ParserFactory.parseFile(filePath);\r\n    const adapter = createAdapter(tree, language, source, filePath);\r\n\r\n    // Extract all functions\r\n    const functions = adapter.extractFunctions();\r\n\r\n    // Build map\r\n    for (const metadata of functions) {\r\n      functionMap.set(metadata.name, metadata);\r\n    }\r\n\r\n  } catch (error) {\r\n    console.log(`    Warning: Could not parse ${filePath}: ${error.message}`);\r\n  }\r\n\r\n  return functionMap;\r\n}"
        },
        "detectFunctionChanges": {
          "hash": "c46905bc79424df5f2666f199bc2d49f",
          "line": 69,
          "endLine": 184,
          "size": 3616,
          "async": true,
          "language": "javascript",
          "source": "async function detectFunctionChanges(filePath, manifest) {\r\n  const changes = {\r\n    filePath,\r\n    added: [],\r\n    modified: [],\r\n    deleted: [],\r\n    unchanged: [],\r\n    renames: []\r\n  };\r\n\r\n  // Get current functions\r\n  const currentFunctions = await extractCurrentFunctions(filePath);\r\n\r\n  // Get manifest functions\r\n  const fileEntry = manifest.files[filePath];\r\n  if (!fileEntry || !fileEntry.functionHashes) {\r\n    // No previous function data - all current functions are \"added\"\r\n    for (const [name, metadata] of currentFunctions) {\r\n      changes.added.push({\r\n        name,\r\n        hash: metadata.hash,\r\n        line: metadata.line,\r\n        size: metadata.size\r\n      });\r\n    }\r\n    return changes;\r\n  }\r\n\r\n  const manifestFunctions = fileEntry.functionHashes;\r\n\r\n  // Compare current vs manifest\r\n  for (const [name, metadata] of currentFunctions) {\r\n    const manifestFunc = manifestFunctions[name];\r\n\r\n    if (!manifestFunc) {\r\n      // New function\r\n      changes.added.push({\r\n        name,\r\n        hash: metadata.hash,\r\n        line: metadata.line,\r\n        size: metadata.size\r\n      });\r\n    } else if (manifestFunc.hash !== metadata.hash) {\r\n      // Modified function\r\n      changes.modified.push({\r\n        name,\r\n        oldHash: manifestFunc.hash,\r\n        newHash: metadata.hash,\r\n        oldLine: manifestFunc.line,\r\n        newLine: metadata.line,\r\n        sizeDelta: metadata.size - manifestFunc.size\r\n      });\r\n    } else {\r\n      // Unchanged function\r\n      changes.unchanged.push(name);\r\n    }\r\n  }\r\n\r\n  // Find deleted functions\r\n  for (const name in manifestFunctions) {\r\n    if (!currentFunctions.has(name)) {\r\n      changes.deleted.push({\r\n        name,\r\n        hash: manifestFunctions[name].hash,\r\n        line: manifestFunctions[name].line\r\n      });\r\n    }\r\n  }\r\n\r\n  // Detect potential renames (deleted + added with similar code)\r\n  if (changes.deleted.length > 0 && changes.added.length > 0) {\r\n    const config = loadConfig();\r\n    const detectRenames = config.incremental?.detectRenames || false;\r\n\r\n    if (detectRenames && fileEntry.functionHashes) {\r\n      // Check if we have source stored for similarity comparison\r\n      const hasStoredSource = Object.values(fileEntry.functionHashes).some(f => f.source);\r\n\r\n      if (hasStoredSource) {\r\n        const { computeSimilarity } = await import('./function-source-extractor.js');\r\n        const threshold = config.incremental?.similarityThreshold || 0.85;\r\n\r\n        for (const deletedFunc of changes.deleted) {\r\n          const oldSource = manifestFunctions[deletedFunc.name]?.source;\r\n\r\n          if (!oldSource) continue;\r\n\r\n          // Compare with each added function\r\n          for (const addedFunc of changes.added) {\r\n            const newMetadata = currentFunctions.get(addedFunc.name);\r\n            if (!newMetadata || !newMetadata.source) continue;\r\n\r\n            const similarity = computeSimilarity(oldSource, newMetadata.source);\r\n\r\n            if (similarity >= threshold) {\r\n              changes.renames.push({\r\n                from: deletedFunc.name,\r\n                to: addedFunc.name,\r\n                similarity: similarity.toFixed(3),\r\n                oldLine: deletedFunc.line,\r\n                newLine: addedFunc.line\r\n              });\r\n\r\n              // Remove from deleted and added since it's a rename\r\n              changes.deleted = changes.deleted.filter(f => f.name !== deletedFunc.name);\r\n              changes.added = changes.added.filter(f => f.name !== addedFunc.name);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return changes;\r\n}"
        },
        "detectAllFunctionChanges": {
          "hash": "7077924c66f53ee8920322db32bd6eff",
          "line": 192,
          "endLine": 208,
          "size": 527,
          "async": true,
          "language": "javascript",
          "source": "async function detectAllFunctionChanges(changedFiles, manifest) {\r\n  const allChanges = new Map();\r\n\r\n  for (const filePath of changedFiles) {\r\n    const changes = await detectFunctionChanges(filePath, manifest);\r\n\r\n    // Only include files with actual function changes\r\n    if (changes.added.length > 0 ||\r\n        changes.modified.length > 0 ||\r\n        changes.deleted.length > 0 ||\r\n        (changes.renames && changes.renames.length > 0)) {\r\n      allChanges.set(filePath, changes);\r\n    }\r\n  }\r\n\r\n  return allChanges;\r\n}"
        },
        "printFunctionChangeSummary": {
          "hash": "ceca671dcce52e77deb47a15f8f011b9",
          "line": 214,
          "endLine": 283,
          "size": 2599,
          "async": false,
          "language": "javascript",
          "source": "function printFunctionChangeSummary(functionChanges) {\r\n  let totalAdded = 0;\r\n  let totalModified = 0;\r\n  let totalDeleted = 0;\r\n  let totalRenamed = 0;\r\n  let totalUnchanged = 0;\r\n\r\n  console.log('\\n=== Function-Level Changes ===\\n');\r\n\r\n  for (const [filePath, changes] of functionChanges) {\r\n    console.log(`${filePath}:`);\r\n\r\n    if (changes.renames && changes.renames.length > 0) {\r\n      console.log(`  Renamed (${changes.renames.length}):`);\r\n      for (const rename of changes.renames) {\r\n        console.log(`    ‚âà ${rename.from} ‚Üí ${rename.to} (${(rename.similarity * 100).toFixed(1)}% similar, line ${rename.oldLine}‚Üí${rename.newLine})`);\r\n      }\r\n      totalRenamed += changes.renames.length;\r\n    }\r\n\r\n    if (changes.added.length > 0) {\r\n      console.log(`  Added (${changes.added.length}):`);\r\n      for (const func of changes.added) {\r\n        console.log(`    + ${func.name} (line ${func.line}, ${func.size} bytes)`);\r\n      }\r\n      totalAdded += changes.added.length;\r\n    }\r\n\r\n    if (changes.modified.length > 0) {\r\n      console.log(`  Modified (${changes.modified.length}):`);\r\n      for (const func of changes.modified) {\r\n        const delta = func.sizeDelta >= 0 ? `+${func.sizeDelta}` : `${func.sizeDelta}`;\r\n        console.log(`    ~ ${func.name} (line ${func.oldLine}‚Üí${func.newLine}, ${delta} bytes)`);\r\n      }\r\n      totalModified += changes.modified.length;\r\n    }\r\n\r\n    if (changes.deleted.length > 0) {\r\n      console.log(`  Deleted (${changes.deleted.length}):`);\r\n      for (const func of changes.deleted) {\r\n        console.log(`    - ${func.name} (was line ${func.line})`);\r\n      }\r\n      totalDeleted += changes.deleted.length;\r\n    }\r\n\r\n    if (changes.unchanged.length > 0) {\r\n      console.log(`  Unchanged: ${changes.unchanged.length} functions`);\r\n      totalUnchanged += changes.unchanged.length;\r\n    }\r\n\r\n    console.log('');\r\n  }\r\n\r\n  console.log('=== Summary ===');\r\n  if (totalRenamed > 0) {\r\n    console.log(`Total functions renamed: ${totalRenamed}`);\r\n  }\r\n  console.log(`Total functions added: ${totalAdded}`);\r\n  console.log(`Total functions modified: ${totalModified}`);\r\n  console.log(`Total functions deleted: ${totalDeleted}`);\r\n  console.log(`Total functions unchanged: ${totalUnchanged}`);\r\n\r\n  const totalChanged = totalAdded + totalModified + totalDeleted + totalRenamed;\r\n  const totalFunctions = totalChanged + totalUnchanged;\r\n  const percentUnchanged = totalFunctions > 0\r\n    ? ((totalUnchanged / totalFunctions) * 100).toFixed(1)\r\n    : 0;\r\n\r\n  console.log(`\\n‚úì Efficiency: ${percentUnchanged}% of functions skipped!`);\r\n}"
        }
      }
    },
    "function-source-extractor.js": {
      "hash": "23baae78c3f55d92987c5763c0c6fb00",
      "size": 4877,
      "lastModified": "2025-12-02T06:19:35.964Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {
        "extractFunctionSource": {
          "hash": "20309a4b5674e1c2741cb2c0246d933f",
          "line": 17,
          "endLine": 43,
          "size": 764,
          "async": false,
          "language": "javascript",
          "source": "function extractFunctionSource(path, sourceCode) {\r\n  const { start, end } = path.node.loc;\r\n\r\n  if (!start || !end) {\r\n    return '';\r\n  }\r\n\r\n  const lines = sourceCode.split('\\n');\r\n\r\n  // Extract lines from start.line to end.line (1-indexed)\r\n  const funcLines = lines.slice(start.line - 1, end.line);\r\n\r\n  // Handle single-line functions\r\n  if (funcLines.length === 1) {\r\n    return funcLines[0].substring(start.column, end.column);\r\n  }\r\n\r\n  // Multi-line functions\r\n  // First line: from start.column to end\r\n  funcLines[0] = funcLines[0].substring(start.column);\r\n\r\n  // Last line: from beginning to end.column\r\n  const lastIdx = funcLines.length - 1;\r\n  funcLines[lastIdx] = funcLines[lastIdx].substring(0, end.column);\r\n\r\n  return funcLines.join('\\n');\r\n}"
        },
        "hashFunctionSource": {
          "hash": "9d77aa3035854269625a8ea95e925ca8",
          "line": 50,
          "endLine": 57,
          "size": 269,
          "async": false,
          "language": "javascript",
          "source": "function hashFunctionSource(source) {\r\n  // Normalize whitespace to avoid spurious changes from reformatting\r\n  const normalized = source\r\n    .replace(/\\s+/g, ' ')  // Collapse whitespace\r\n    .trim();\r\n\r\n  return createHash('md5').update(normalized).digest('hex');\r\n}"
        },
        "generateFunctionId": {
          "hash": "ffdb2c7d12885c0a48f1f029d9c9becc",
          "line": 66,
          "endLine": 73,
          "size": 233,
          "async": false,
          "language": "javascript",
          "source": "function generateFunctionId(filePath, funcName, line) {\r\n  // For anonymous functions, use line number\r\n  if (!funcName || funcName === 'anonymous') {\r\n    return `${filePath}#L${line}`;\r\n  }\r\n\r\n  return `${filePath}#${funcName}`;\r\n}"
        },
        "extractFunctionMetadata": {
          "hash": "662f1280e5ed111ea99431955e40fd68",
          "line": 82,
          "endLine": 115,
          "size": 864,
          "async": false,
          "language": "javascript",
          "source": "function extractFunctionMetadata(path, sourceCode, filePath) {\r\n  const node = path.node;\r\n\r\n  // Get function name\r\n  let funcName = 'anonymous';\r\n  if (node.id?.name) {\r\n    funcName = node.id.name;\r\n  } else if (path.parent?.type === 'VariableDeclarator' && path.parent.id?.name) {\r\n    funcName = path.parent.id.name;\r\n  }\r\n\r\n  // Extract source\r\n  const source = extractFunctionSource(path, sourceCode);\r\n  const hash = hashFunctionSource(source);\r\n\r\n  // Get location\r\n  const line = node.loc?.start.line || 0;\r\n  const endLine = node.loc?.end.line || 0;\r\n\r\n  // Generate unique ID\r\n  const funcId = generateFunctionId(filePath, funcName, line);\r\n\r\n  return {\r\n    id: funcId,\r\n    name: funcName,\r\n    line,\r\n    endLine,\r\n    source,\r\n    hash,\r\n    size: source.length,\r\n    isAsync: node.async || false,\r\n    isGenerator: node.generator || false\r\n  };\r\n}"
        },
        "computeSimilarity": {
          "hash": "b1df5a3b4539f873e7fb7c959037c8f0",
          "line": 123,
          "endLine": 142,
          "size": 598,
          "async": false,
          "language": "javascript",
          "source": "function computeSimilarity(source1, source2) {\r\n  // Simple similarity: compare normalized versions\r\n  const norm1 = source1.replace(/\\s+/g, ' ').trim();\r\n  const norm2 = source2.replace(/\\s+/g, ' ').trim();\r\n\r\n  if (norm1 === norm2) return 1.0;\r\n\r\n  // Levenshtein distance would be better, but this is simple\r\n  const maxLen = Math.max(norm1.length, norm2.length);\r\n  if (maxLen === 0) return 1.0;\r\n\r\n  let matches = 0;\r\n  const minLen = Math.min(norm1.length, norm2.length);\r\n\r\n  for (let i = 0; i < minLen; i++) {\r\n    if (norm1[i] === norm2[i]) matches++;\r\n  }\r\n\r\n  return matches / maxLen;\r\n}"
        },
        "detectRename": {
          "hash": "711df06e0d54a562d5efa3a5fce6cfaa",
          "line": 151,
          "endLine": 169,
          "size": 455,
          "async": false,
          "language": "javascript",
          "source": "function detectRename(deletedFunc, addedFuncs, threshold = 0.9) {\r\n  let bestMatch = null;\r\n  let bestScore = threshold;\r\n\r\n  for (const addedFunc of addedFuncs) {\r\n    const score = computeSimilarity(deletedFunc.source, addedFunc.source);\r\n\r\n    if (score > bestScore) {\r\n      bestScore = score;\r\n      bestMatch = {\r\n        from: deletedFunc.name,\r\n        to: addedFunc.name,\r\n        similarity: score\r\n      };\r\n    }\r\n  }\r\n\r\n  return bestMatch;\r\n}"
        }
      }
    },
    "incremental-analyzer.js": {
      "hash": "c2e1c38d01e7d20c7e7448ed70dd2af3",
      "size": 18880,
      "lastModified": "2026-01-11T04:28:37.982Z",
      "functions": [
        "computeFileHash",
        "getFileMetadata",
        "analyzeSingleFile",
        "loadGraph",
        "updateGraph",
        "updateManifest",
        "main",
        "analyzeSpecificFunctions"
      ],
      "analysisTime": null,
      "functionHashes": {
        "loadConfig": {
          "hash": "1cb52fe4e91e7b7016bc44fa014e40a1",
          "line": 27,
          "endLine": 35,
          "size": 214,
          "async": false,
          "language": "javascript",
          "source": "function loadConfig() {\r\n  const configPath = './llm-context.config.json';\r\n\r\n  if (!existsSync(configPath)) {\r\n    return { granularity: 'file' };\r\n  }\r\n\r\n  return JSON.parse(readFileSync(configPath, 'utf-8'));\r\n}"
        },
        "computeFileHash": {
          "hash": "b62e98f7bf6d9f8483abb37a86b85f59",
          "line": 40,
          "endLine": 43,
          "size": 141,
          "async": false,
          "language": "javascript",
          "source": "function computeFileHash(filePath) {\r\n  const content = readFileSync(filePath);\r\n  return createHash('md5').update(content).digest('hex');\r\n}"
        },
        "getFileMetadata": {
          "hash": "bf688e494f0c96c3acf2ef82db6cc11f",
          "line": 48,
          "endLine": 54,
          "size": 162,
          "async": false,
          "language": "javascript",
          "source": "function getFileMetadata(filePath) {\r\n  const stats = statSync(filePath);\r\n  return {\r\n    size: stats.size,\r\n    lastModified: stats.mtime.toISOString()\r\n  };\r\n}"
        },
        "analyzeSpecificFunctions": {
          "hash": "777293efcee1f47acfb1f9854ff7f55e",
          "line": 62,
          "endLine": 161,
          "size": 3496,
          "async": true,
          "language": "javascript",
          "source": "async function analyzeSpecificFunctions(sourcePath, targetFunctions = null) {\r\n  const startTime = Date.now();\r\n  const source = readFileSync(sourcePath, 'utf-8');\r\n\r\n  // Detect language and parse with Tree-sitter\r\n  const language = ParserFactory.detectLanguage(sourcePath);\r\n  if (!language) {\r\n    console.warn(`Unsupported file type: ${sourcePath}`);\r\n    return { entries: [], analysisTime: 0, totalFunctions: 0, analyzedFunctions: 0 };\r\n  }\r\n\r\n  const { tree } = await ParserFactory.parseFile(sourcePath);\r\n  const adapter = createAdapter(tree, language, source, sourcePath);\r\n\r\n  // Extract all functions\r\n  const allFunctions = adapter.extractFunctionsWithNodes();\r\n\r\n  // Filter to target functions if specified\r\n  const functionsToAnalyze = targetFunctions\r\n    ? allFunctions.filter(f => targetFunctions.includes(f.metadata.name))\r\n    : allFunctions;\r\n\r\n  // Extract imports for side effect analysis\r\n  const imports = adapter.extractImports();\r\n  const sideEffectAnalyzer = createAnalyzer(language, imports);\r\n\r\n  // Analyze each function\r\n  const results = [];\r\n\r\n  for (const { metadata } of functionsToAnalyze) {\r\n    // Extract call graph\r\n    const calls = adapter.extractCallGraph(metadata);\r\n    const uniqueCalls = [...new Set(calls)].filter(c => c !== metadata.name);\r\n\r\n    // Analyze side effects (AST-based, not regex!)\r\n    const effectsWithConfidence = sideEffectAnalyzer.analyze(uniqueCalls, metadata.source);\r\n    const uniqueEffects = [...new Set(effectsWithConfidence.map(e => e.type))];\r\n\r\n    // Detect code patterns\r\n    const patterns = [];\r\n\r\n    // Parsing patterns\r\n    if (uniqueCalls.some(c => c === 'parse' || c.includes('parse'))) {\r\n      patterns.push({\r\n        type: 'parsing',\r\n        tool: uniqueCalls.find(c => c.includes('tree-sitter') || c.includes('parser')) ? 'tree-sitter' : 'unknown',\r\n        description: 'Parses source code into AST'\r\n      });\r\n    }\r\n\r\n    // Hash/crypto patterns\r\n    if (uniqueCalls.some(c => /hash|md5|sha|digest|crypto/i.test(c))) {\r\n      patterns.push({\r\n        type: 'hashing',\r\n        method: uniqueCalls.find(c => /md5|sha/i.test(c)) || 'hash',\r\n        description: 'Computes file/content hash for change detection'\r\n      });\r\n    }\r\n\r\n    // Side effect detection patterns (now AST-based!)\r\n    if (effectsWithConfidence.length > 0) {\r\n      patterns.push({\r\n        type: 'side-effect-detection',\r\n        method: 'ast-analysis',\r\n        description: 'Detects side effects via AST analysis with import tracking'\r\n      });\r\n    }\r\n\r\n    // Graph manipulation\r\n    if (uniqueCalls.some(c => /map|filter|reduce|forEach/i.test(c)) &&\r\n        uniqueCalls.some(c => /graph|entries|functions/i.test(c))) {\r\n      patterns.push({\r\n        type: 'graph-transformation',\r\n        description: 'Transforms or filters call graph data'\r\n      });\r\n    }\r\n\r\n    results.push({\r\n      id: metadata.name,\r\n      type: 'function',\r\n      file: sourcePath,\r\n      line: metadata.line,\r\n      sig: `(${metadata.isAsync ? 'async ' : ''}${metadata.params || ''})`,\r\n      async: metadata.isAsync,\r\n      calls: uniqueCalls.slice(0, 10),\r\n      effects: uniqueEffects,\r\n      patterns: patterns.length > 0 ? patterns : undefined,\r\n      scipDoc: '',\r\n      functionHash: metadata.hash,\r\n      language: language  // NEW: Include language\r\n    });\r\n  }\r\n\r\n  return {\r\n    entries: results,\r\n    analysisTime: Date.now() - startTime,\r\n    totalFunctions: allFunctions.length,\r\n    analyzedFunctions: results.length\r\n  };\r\n}"
        },
        "analyzeSingleFile": {
          "hash": "ff3682f93a737e737728a56ce8932bb4",
          "line": 168,
          "endLine": 224,
          "size": 2094,
          "async": true,
          "language": "javascript",
          "source": "async function analyzeSingleFile(sourcePath) {\r\n  const startTime = Date.now();\r\n\r\n  try {\r\n    const source = readFileSync(sourcePath, 'utf-8');\r\n\r\n    // Detect language and parse with Tree-sitter\r\n    const language = ParserFactory.detectLanguage(sourcePath);\r\n    if (!language) {\r\n      console.warn(`Unsupported file type: ${sourcePath}`);\r\n      return { entries: [], analysisTime: Date.now() - startTime };\r\n    }\r\n\r\n    const { tree } = await ParserFactory.parseFile(sourcePath);\r\n    const adapter = createAdapter(tree, language, source, sourcePath);\r\n\r\n    // Extract all functions\r\n    const allFunctions = adapter.extractFunctionsWithNodes();\r\n\r\n    // Extract imports for side effect analysis\r\n    const imports = adapter.extractImports();\r\n    const sideEffectAnalyzer = createAnalyzer(language, imports);\r\n\r\n    // Build output\r\n    const result = allFunctions.map(({ metadata }) => {\r\n      // Extract call graph\r\n      const calls = adapter.extractCallGraph(metadata);\r\n      const uniqueCalls = [...new Set(calls)].filter(c => c !== metadata.name);\r\n\r\n      // Analyze side effects (AST-based!)\r\n      const effectsWithConfidence = sideEffectAnalyzer.analyze(uniqueCalls, metadata.source);\r\n      const uniqueEffects = [...new Set(effectsWithConfidence.map(e => e.type))];\r\n\r\n      return {\r\n        id: metadata.name,\r\n        type: 'function',\r\n        file: sourcePath,\r\n        line: metadata.line,\r\n        sig: `(${metadata.isAsync ? 'async ' : ''}${metadata.params || ''})`,\r\n        async: metadata.isAsync || false,\r\n        calls: uniqueCalls.slice(0, 10),\r\n        effects: uniqueEffects,\r\n        scipDoc: '',\r\n        language: language  // NEW: Include language\r\n      };\r\n    });\r\n\r\n    const analysisTime = Date.now() - startTime;\r\n    console.log(`      Analysis complete: ${allFunctions.length} functions, ${analysisTime}ms`);\r\n\r\n    return { entries: result, analysisTime };\r\n\r\n  } catch (error) {\r\n    console.log(`      Warning: Could not parse ${sourcePath}: ${error.message}`);\r\n    return { entries: [], analysisTime: Date.now() - startTime };\r\n  }\r\n}"
        },
        "loadGraph": {
          "hash": "3531f2f406780d18bdf509653c26c2d0",
          "line": 229,
          "endLine": 238,
          "size": 258,
          "async": false,
          "language": "javascript",
          "source": "function loadGraph() {\r\n  const graphPath = '.llm-context/graph.jsonl';\r\n\r\n  if (!existsSync(graphPath)) {\r\n    return [];\r\n  }\r\n\r\n  const lines = readFileSync(graphPath, 'utf-8').split('\\n').filter(Boolean);\r\n  return lines.map(line => JSON.parse(line));\r\n}"
        },
        "updateGraphFunctionLevel": {
          "hash": "78787eaad5298619bfdc5be9fb4121fb",
          "line": 243,
          "endLine": 280,
          "size": 1413,
          "async": false,
          "language": "javascript",
          "source": "function updateGraphFunctionLevel(functionChanges, newEntries) {\r\n  console.log('\\n[4] Updating graph.jsonl (function-level)...');\r\n\r\n  const existingEntries = loadGraph();\r\n  console.log(`    Current entries: ${existingEntries.length}`);\r\n\r\n  // Build a set of (file, function) pairs to remove\r\n  const toRemove = new Set();\r\n\r\n  for (const [filePath, changes] of functionChanges) {\r\n    // Remove modified and deleted functions\r\n    for (const func of [...changes.modified, ...changes.deleted]) {\r\n      toRemove.add(`${filePath}#${func.name}`);\r\n    }\r\n  }\r\n\r\n  // Keep entries that aren't in the remove set\r\n  const keptEntries = existingEntries.filter(entry => {\r\n    const key = `${entry.file}#${entry.id}`;\r\n    return !toRemove.has(key);\r\n  });\r\n\r\n  console.log(`    Entries kept (unchanged functions): ${keptEntries.length}`);\r\n  console.log(`    Entries removed (changed/deleted functions): ${existingEntries.length - keptEntries.length}`);\r\n\r\n  // Add new entries\r\n  const updatedGraph = [...keptEntries, ...newEntries];\r\n  console.log(`    New entries added: ${newEntries.length}`);\r\n  console.log(`    Total entries: ${updatedGraph.length}`);\r\n\r\n  // Write updated graph\r\n  const jsonlContent = updatedGraph.map(node => JSON.stringify(node)).join('\\n');\r\n  writeFileSync('.llm-context/graph.jsonl', jsonlContent);\r\n\r\n  console.log('    ‚úì Graph updated (function-level)');\r\n\r\n  return updatedGraph;\r\n}"
        },
        "updateGraph": {
          "hash": "764c9f860df61c5d3f236db1e7bad832",
          "line": 285,
          "endLine": 312,
          "size": 1116,
          "async": false,
          "language": "javascript",
          "source": "function updateGraph(changedFiles, newEntries) {\r\n  console.log('\\n[4] Updating graph.jsonl (file-level)...');\r\n\r\n  // Load existing graph\r\n  const existingEntries = loadGraph();\r\n  console.log(`    Current entries: ${existingEntries.length}`);\r\n\r\n  // Create set of changed files for fast lookup\r\n  const changedSet = new Set(changedFiles);\r\n\r\n  // Keep only entries from unchanged files\r\n  const keptEntries = existingEntries.filter(entry => !changedSet.has(entry.file));\r\n  console.log(`    Entries kept (unchanged files): ${keptEntries.length}`);\r\n  console.log(`    Entries removed (changed files): ${existingEntries.length - keptEntries.length}`);\r\n\r\n  // Add all new entries\r\n  const updatedGraph = [...keptEntries, ...newEntries];\r\n  console.log(`    New entries added: ${newEntries.length}`);\r\n  console.log(`    Total entries: ${updatedGraph.length}`);\r\n\r\n  // Write updated graph\r\n  const jsonlContent = updatedGraph.map(node => JSON.stringify(node)).join('\\n');\r\n  writeFileSync('.llm-context/graph.jsonl', jsonlContent);\r\n\r\n  console.log('    ‚úì Graph updated (file-level)');\r\n\r\n  return updatedGraph;\r\n}"
        },
        "updateManifest": {
          "hash": "9ceec15308b79fd70e99ba797e097820",
          "line": 317,
          "endLine": 359,
          "size": 1437,
          "async": false,
          "language": "javascript",
          "source": "function updateManifest(changeReport, analysisResults) {\r\n  console.log('\\n[5] Updating manifest.json...');\r\n\r\n  const manifest = changeReport.manifest;\r\n\r\n  // Remove deleted files\r\n  for (const filePath of changeReport.deleted) {\r\n    delete manifest.files[filePath];\r\n    console.log(`    - Removed: ${filePath}`);\r\n  }\r\n\r\n  // Update changed and new files\r\n  const allChangedFiles = [...changeReport.added, ...changeReport.modified];\r\n\r\n  for (const filePath of allChangedFiles) {\r\n    const hash = computeFileHash(filePath);\r\n    const metadata = getFileMetadata(filePath);\r\n    const result = analysisResults.get(filePath);\r\n\r\n    manifest.files[filePath] = {\r\n      hash,\r\n      size: metadata.size,\r\n      lastModified: metadata.lastModified,\r\n      functions: result ? result.entries.map(e => e.id) : [],\r\n      analysisTime: result ? result.analysisTime : null\r\n    };\r\n\r\n    console.log(`    ‚úì Updated: ${filePath}`);\r\n  }\r\n\r\n  // Update global stats\r\n  const graph = loadGraph();\r\n  manifest.globalStats.totalFunctions = graph.length;\r\n  manifest.globalStats.totalCalls = graph.reduce((sum, f) => sum + (f.calls?.length || 0), 0);\r\n  manifest.globalStats.totalFiles = Object.keys(manifest.files).length;\r\n  manifest.generated = new Date().toISOString();\r\n\r\n  // Save manifest\r\n  writeFileSync('.llm-context/manifest.json', JSON.stringify(manifest, null, 2));\r\n  console.log('    ‚úì Manifest updated');\r\n\r\n  return manifest;\r\n}"
        },
        "mainFunctionLevel": {
          "hash": "c96d4a70a02aa7598691f3ccaca45cd7",
          "line": 364,
          "endLine": 479,
          "size": 4225,
          "async": true,
          "language": "javascript",
          "source": "async function mainFunctionLevel() {\r\n  console.log('[1] Detecting file-level changes...');\r\n  const changeReport = detectChanges();\r\n\r\n  if (changeReport.needsFullAnalysis) {\r\n    console.log('\\n‚ö† No manifest found - run full analysis first');\r\n    return;\r\n  }\r\n\r\n  const changedFiles = [...changeReport.added, ...changeReport.modified];\r\n\r\n  if (changedFiles.length === 0) {\r\n    console.log('\\n‚úì No changes detected - all files up to date!');\r\n    return;\r\n  }\r\n\r\n  console.log(`\\n[2] Detecting function-level changes in ${changedFiles.length} files...`);\r\n  const functionChanges = await detectAllFunctionChanges(changedFiles, changeReport.manifest);\r\n\r\n  if (functionChanges.size === 0) {\r\n    console.log('\\n‚úì No function-level changes detected!');\r\n    return;\r\n  }\r\n\r\n  printFunctionChangeSummary(functionChanges);\r\n\r\n  // Impact analysis (if enabled)\r\n  const config = loadConfig();\r\n  if (config.analysis?.trackDependencies) {\r\n    const changedFunctionNames = [];\r\n    for (const [filePath, changes] of functionChanges) {\r\n      changedFunctionNames.push(...changes.modified.map(f => f.name));\r\n      changedFunctionNames.push(...changes.added.map(f => f.name));\r\n      if (changes.renames) {\r\n        changedFunctionNames.push(...changes.renames.map(r => r.to));\r\n      }\r\n    }\r\n\r\n    if (changedFunctionNames.length > 0) {\r\n      try {\r\n        analyzeImpact(changedFunctionNames);\r\n      } catch (error) {\r\n        console.log(`\\nWarning: Impact analysis failed: ${error.message}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  console.log('\\n[3] Re-analyzing changed/added functions...');\r\n\r\n  const allNewEntries = [];\r\n  const analysisResults = new Map();\r\n\r\n  for (const [filePath, changes] of functionChanges) {\r\n    // Get names of functions to analyze (modified + added)\r\n    const targetFunctions = [\r\n      ...changes.modified.map(f => f.name),\r\n      ...changes.added.map(f => f.name)\r\n    ];\r\n\r\n    if (targetFunctions.length === 0) {\r\n      continue;\r\n    }\r\n\r\n    console.log(`    ${filePath}: analyzing ${targetFunctions.length} functions`);\r\n\r\n    try {\r\n      const result = await analyzeSpecificFunctions(filePath, targetFunctions);\r\n      analysisResults.set(filePath, result);\r\n      allNewEntries.push(...result.entries);\r\n\r\n      console.log(`      Found: ${result.entries.length} entries, ${result.analysisTime}ms`);\r\n      console.log(`      Skipped: ${result.totalFunctions - result.analyzedFunctions} unchanged functions`);\r\n    } catch (error) {\r\n      console.log(`      Error: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Update graph (function-level)\r\n  const updatedGraph = updateGraphFunctionLevel(functionChanges, allNewEntries);\r\n\r\n  // Update manifest (note: still need to update function hashes)\r\n  console.log('\\n[5] Updating manifest.json...');\r\n  const manifest = changeReport.manifest;\r\n  const storeSource = config.incremental?.storeSource || false;\r\n\r\n  for (const filePath of changedFiles) {\r\n    const hash = computeFileHash(filePath);\r\n    const metadata = getFileMetadata(filePath);\r\n\r\n    // Re-extract all function hashes for changed files\r\n    const { extractFileFunctions } = await import('./manifest-generator.js');\r\n    const functionHashes = extractFileFunctions(filePath, storeSource);\r\n\r\n    if (manifest.files[filePath]) {\r\n      manifest.files[filePath].hash = hash;\r\n      manifest.files[filePath].size = metadata.size;\r\n      manifest.files[filePath].lastModified = metadata.lastModified;\r\n      manifest.files[filePath].functionHashes = functionHashes;\r\n    }\r\n\r\n    console.log(`    ‚úì Updated: ${filePath}`);\r\n  }\r\n\r\n  // Update global stats\r\n  manifest.globalStats.totalFunctions = updatedGraph.length;\r\n  manifest.globalStats.totalCalls = updatedGraph.reduce((sum, f) => sum + (f.calls?.length || 0), 0);\r\n  manifest.generated = new Date().toISOString();\r\n\r\n  writeFileSync('.llm-context/manifest.json', JSON.stringify(manifest, null, 2));\r\n  console.log('    ‚úì Manifest updated');\r\n\r\n  console.log('\\n=== Incremental Analysis Complete (Function-Level) ===');\r\n  console.log(`Functions re-analyzed: ${allNewEntries.length}`);\r\n  console.log(`Total functions in graph: ${updatedGraph.length}`);\r\n  console.log(`Total calls tracked: ${manifest.globalStats.totalCalls}`);\r\n}"
        },
        "mainFileLevel": {
          "hash": "85577e0b371c9a4c05036b94d439ad07",
          "line": 484,
          "endLine": 534,
          "size": 2038,
          "async": true,
          "language": "javascript",
          "source": "async function mainFileLevel() {\r\n  console.log('[1] Detecting changes...');\r\n  const changeReport = detectChanges();\r\n\r\n  if (changeReport.needsFullAnalysis) {\r\n    console.log('\\n‚ö† No manifest found - run full analysis first:');\r\n    console.log('  1. node manifest-generator.js');\r\n    console.log('  2. Ensure graph.jsonl exists');\r\n    console.log('  3. Run this script again');\r\n    return;\r\n  }\r\n\r\n  const changedFiles = [...changeReport.added, ...changeReport.modified];\r\n\r\n  if (changedFiles.length === 0) {\r\n    console.log('\\n‚úì No changes detected - all files up to date!');\r\n    return;\r\n  }\r\n\r\n  console.log(`\\n[2] Re-analyzing ${changedFiles.length} changed files...`);\r\n\r\n  const analysisResults = new Map();\r\n  const allNewEntries = [];\r\n\r\n  for (const filePath of changedFiles) {\r\n    console.log(`    Analyzing: ${filePath}`);\r\n    const result = await analyzeSingleFile(filePath);\r\n    analysisResults.set(filePath, result);\r\n    allNewEntries.push(...result.entries);\r\n  }\r\n\r\n  console.log(`\\n[3] Summary of re-analysis:`);\r\n  console.log(`    Files analyzed: ${changedFiles.length}`);\r\n  console.log(`    Functions found: ${allNewEntries.length}`);\r\n  console.log(`    Total time: ${Array.from(analysisResults.values()).reduce((sum, r) => sum + r.analysisTime, 0)}ms`);\r\n\r\n  // Update graph\r\n  const updatedGraph = updateGraph(changedFiles, allNewEntries);\r\n\r\n  // Update manifest\r\n  const updatedManifest = updateManifest(changeReport, analysisResults);\r\n\r\n  console.log('\\n=== Incremental Analysis Complete (File-Level) ===');\r\n  console.log(`Files re-analyzed: ${changedFiles.length}`);\r\n  console.log(`Files skipped: ${changeReport.unchanged.length}`);\r\n  console.log(`Total functions in graph: ${updatedGraph.length}`);\r\n  console.log(`Total calls tracked: ${updatedManifest.globalStats.totalCalls}`);\r\n\r\n  const percentSkipped = ((changeReport.unchanged.length / (changedFiles.length + changeReport.unchanged.length)) * 100).toFixed(1);\r\n  console.log(`\\n‚úì Efficiency: ${percentSkipped}% of files skipped!`);\r\n}"
        },
        "main": {
          "hash": "da4ebf58e105a1514f265375c1504154",
          "line": 539,
          "endLine": 550,
          "size": 283,
          "async": true,
          "language": "javascript",
          "source": "async function main() {\r\n  const config = loadConfig();\r\n  const granularity = config.granularity || 'file';\r\n\r\n  console.log(`Granularity mode: ${granularity}\\n`);\r\n\r\n  if (granularity === 'function') {\r\n    await mainFunctionLevel();\r\n  } else {\r\n    await mainFileLevel();\r\n  }\r\n}"
        }
      }
    },
    "language-queries.js": {
      "hash": "fa616ce6612f6dc6b166b2298139b4a1",
      "size": 9091,
      "lastModified": "2026-01-11T06:04:22.516Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {
        "getQueries": {
          "hash": "653b4fb55bb8bfb2099ac5cf55e31e30",
          "line": 359,
          "endLine": 364,
          "size": 185,
          "async": false,
          "language": "javascript",
          "source": "function getQueries(language) {\r\n  if (!LANGUAGE_QUERIES[language]) {\r\n    throw new Error(`No queries defined for language: ${language}`);\r\n  }\r\n  return LANGUAGE_QUERIES[language];\r\n}"
        },
        "getFunctionQuery": {
          "hash": "0b6fab76d6c2a6da519994512270fdc5",
          "line": 371,
          "endLine": 374,
          "size": 110,
          "async": false,
          "language": "javascript",
          "source": "function getFunctionQuery(language) {\r\n  const queries = getQueries(language);\r\n  return queries.functions;\r\n}"
        },
        "getCallQuery": {
          "hash": "fc60d0f909a6492a59b8448325e76ba9",
          "line": 381,
          "endLine": 384,
          "size": 102,
          "async": false,
          "language": "javascript",
          "source": "function getCallQuery(language) {\r\n  const queries = getQueries(language);\r\n  return queries.calls;\r\n}"
        },
        "getImportQuery": {
          "hash": "71b1d2fe550d6fd60497dde46090dd36",
          "line": 391,
          "endLine": 394,
          "size": 106,
          "async": false,
          "language": "javascript",
          "source": "function getImportQuery(language) {\r\n  const queries = getQueries(language);\r\n  return queries.imports;\r\n}"
        }
      }
    },
    "manifest-generator.js": {
      "hash": "835f457efd0448d4eb1aebafb698bbe3",
      "size": 8812,
      "lastModified": "2026-01-11T04:31:13.915Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {
        "loadConfig": {
          "hash": "0c0590b9466c2c3ddeec8f6e2f31c61f",
          "line": 25,
          "endLine": 37,
          "size": 310,
          "async": false,
          "language": "javascript",
          "source": "function loadConfig() {\r\n  const configPath = './llm-context.config.json';\r\n\r\n  if (!existsSync(configPath)) {\r\n    // Default config\r\n    return {\r\n      granularity: 'file',\r\n      incremental: { enabled: true, hashAlgorithm: 'md5' }\r\n    };\r\n  }\r\n\r\n  return JSON.parse(readFileSync(configPath, 'utf-8'));\r\n}"
        },
        "computeFileHash": {
          "hash": "b62e98f7bf6d9f8483abb37a86b85f59",
          "line": 44,
          "endLine": 47,
          "size": 141,
          "async": false,
          "language": "javascript",
          "source": "function computeFileHash(filePath) {\r\n  const content = readFileSync(filePath);\r\n  return createHash('md5').update(content).digest('hex');\r\n}"
        },
        "getFileMetadata": {
          "hash": "bf688e494f0c96c3acf2ef82db6cc11f",
          "line": 54,
          "endLine": 60,
          "size": 162,
          "async": false,
          "language": "javascript",
          "source": "function getFileMetadata(filePath) {\r\n  const stats = statSync(filePath);\r\n  return {\r\n    size: stats.size,\r\n    lastModified: stats.mtime.toISOString()\r\n  };\r\n}"
        },
        "extractFileFunctions": {
          "hash": "2db6d771b9629316ed18d312818ffb28",
          "line": 68,
          "endLine": 111,
          "size": 1276,
          "async": true,
          "language": "javascript",
          "source": "async function extractFileFunctions(filePath, includeSource = false) {\r\n  const functionMap = {};\r\n\r\n  try {\r\n    const source = readFileSync(filePath, 'utf-8');\r\n\r\n    // Detect language and parse with Tree-sitter\r\n    const language = ParserFactory.detectLanguage(filePath);\r\n    if (!language) {\r\n      console.log(`    Warning: Unsupported file type: ${filePath}`);\r\n      return functionMap;\r\n    }\r\n\r\n    const { tree } = await ParserFactory.parseFile(filePath);\r\n    const adapter = createAdapter(tree, language, source, filePath);\r\n\r\n    // Extract all functions\r\n    const functions = adapter.extractFunctions();\r\n\r\n    // Build map\r\n    for (const metadata of functions) {\r\n      const funcEntry = {\r\n        hash: metadata.hash,\r\n        line: metadata.line,\r\n        endLine: metadata.endLine,\r\n        size: metadata.size,\r\n        async: metadata.isAsync,\r\n        language: language  // NEW: Include language\r\n      };\r\n\r\n      // Optionally include source for rename detection and diffs\r\n      if (includeSource) {\r\n        funcEntry.source = metadata.source;\r\n      }\r\n\r\n      functionMap[metadata.name] = funcEntry;\r\n    }\r\n\r\n  } catch (error) {\r\n    console.log(`    Warning: Could not parse ${filePath}: ${error.message}`);\r\n  }\r\n\r\n  return functionMap;\r\n}"
        },
        "findJsFiles": {
          "hash": "9f00c839e035484b74b76abefbafdd83",
          "line": 119,
          "endLine": 144,
          "size": 707,
          "async": false,
          "language": "javascript",
          "source": "function findJsFiles(dir = '.', ignore = ['node_modules', '.git', '.llm-context']) {\r\n  const files = [];\r\n\r\n  function walk(currentDir) {\r\n    const entries = readdirSync(currentDir, { withFileTypes: true });\r\n\r\n    for (const entry of entries) {\r\n      const fullPath = join(currentDir, entry.name);\r\n      const relativePath = relative('.', fullPath);\r\n\r\n      // Skip ignored directories\r\n      if (ignore.some(pattern => relativePath.includes(pattern))) {\r\n        continue;\r\n      }\r\n\r\n      if (entry.isDirectory()) {\r\n        walk(fullPath);\r\n      } else if (entry.isFile() && entry.name.endsWith('.js')) {\r\n        files.push(relativePath);\r\n      }\r\n    }\r\n  }\r\n\r\n  walk(dir);\r\n  return files;\r\n}"
        },
        "walk": {
          "hash": "3e0daaa553c9ffc8741a8d6ae3260eb1",
          "line": 122,
          "endLine": 140,
          "size": 560,
          "async": false,
          "language": "javascript",
          "source": "function walk(currentDir) {\r\n    const entries = readdirSync(currentDir, { withFileTypes: true });\r\n\r\n    for (const entry of entries) {\r\n      const fullPath = join(currentDir, entry.name);\r\n      const relativePath = relative('.', fullPath);\r\n\r\n      // Skip ignored directories\r\n      if (ignore.some(pattern => relativePath.includes(pattern))) {\r\n        continue;\r\n      }\r\n\r\n      if (entry.isDirectory()) {\r\n        walk(fullPath);\r\n      } else if (entry.isFile() && entry.name.endsWith('.js')) {\r\n        files.push(relativePath);\r\n      }\r\n    }\r\n  }"
        },
        "loadGraphData": {
          "hash": "a0429172b23c8f91f1f4d1031eee5eb1",
          "line": 150,
          "endLine": 173,
          "size": 632,
          "async": false,
          "language": "javascript",
          "source": "function loadGraphData() {\r\n  const graphPath = '.llm-context/graph.jsonl';\r\n  const fileToFunctions = new Map();\r\n\r\n  if (!existsSync(graphPath)) {\r\n    console.log('No existing graph.jsonl found - this will be the initial analysis');\r\n    return fileToFunctions;\r\n  }\r\n\r\n  const lines = readFileSync(graphPath, 'utf-8').split('\\n').filter(Boolean);\r\n\r\n  for (const line of lines) {\r\n    const func = JSON.parse(line);\r\n    const file = func.file;\r\n\r\n    if (!fileToFunctions.has(file)) {\r\n      fileToFunctions.set(file, []);\r\n    }\r\n\r\n    fileToFunctions.get(file).push(func.id || func.name);\r\n  }\r\n\r\n  return fileToFunctions;\r\n}"
        },
        "generateManifest": {
          "hash": "a67b5cb0ae6927d6f21373fd8157f242",
          "line": 179,
          "endLine": 267,
          "size": 3041,
          "async": true,
          "language": "javascript",
          "source": "async function generateManifest() {\r\n  const config = loadConfig();\r\n  const granularity = config.granularity || 'file';\r\n\r\n  console.log(`[1] Configuration: granularity=${granularity}`);\r\n  console.log('[2] Discovering JavaScript files...');\r\n  const jsFiles = findJsFiles();\r\n  console.log(`    Found ${jsFiles.length} JavaScript files\\n`);\r\n\r\n  console.log('[3] Computing file hashes...');\r\n  const fileToFunctions = loadGraphData();\r\n  const files = {};\r\n  let totalSize = 0;\r\n\r\n  for (const filePath of jsFiles) {\r\n    try {\r\n      const hash = computeFileHash(filePath);\r\n      const metadata = getFileMetadata(filePath);\r\n      const graphFunctions = fileToFunctions.get(filePath) || [];\r\n\r\n      const fileEntry = {\r\n        hash,\r\n        size: metadata.size,\r\n        lastModified: metadata.lastModified,\r\n        functions: graphFunctions,\r\n        analysisTime: null\r\n      };\r\n\r\n      // Add function-level hashes if granularity is 'function'\r\n      if (granularity === 'function') {\r\n        const storeSource = config.incremental?.storeSource || false;\r\n        const functionMetadata = await extractFileFunctions(filePath, storeSource);\r\n        fileEntry.functionHashes = functionMetadata;\r\n\r\n        console.log(`    ${filePath}`);\r\n        console.log(`      File hash: ${hash.substring(0, 12)}...`);\r\n        console.log(`      Functions: ${Object.keys(functionMetadata).length}`);\r\n\r\n        // Show first few function hashes\r\n        const funcNames = Object.keys(functionMetadata).slice(0, 3);\r\n        for (const name of funcNames) {\r\n          const fHash = functionMetadata[name].hash.substring(0, 8);\r\n          console.log(`        - ${name} (${fHash}...)`);\r\n        }\r\n        if (Object.keys(functionMetadata).length > 3) {\r\n          console.log(`        ... and ${Object.keys(functionMetadata).length - 3} more`);\r\n        }\r\n      } else {\r\n        console.log(`    ${filePath}`);\r\n        console.log(`      Hash: ${hash.substring(0, 12)}...`);\r\n        console.log(`      Functions: ${graphFunctions.length > 0 ? graphFunctions.join(', ') : 'none yet'}`);\r\n      }\r\n\r\n      files[filePath] = fileEntry;\r\n      totalSize += metadata.size;\r\n\r\n    } catch (error) {\r\n      console.log(`    Warning: Could not process ${filePath}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  console.log(`\\n[4] Building manifest...`);\r\n\r\n  // Load global stats from graph if available\r\n  let globalStats = {\r\n    totalFunctions: 0,\r\n    totalCalls: 0,\r\n    totalFiles: jsFiles.length,\r\n    totalSize\r\n  };\r\n\r\n  if (existsSync('.llm-context/graph.jsonl')) {\r\n    const lines = readFileSync('.llm-context/graph.jsonl', 'utf-8').split('\\n').filter(Boolean);\r\n    const functions = lines.map(line => JSON.parse(line));\r\n\r\n    globalStats.totalFunctions = functions.length;\r\n    globalStats.totalCalls = functions.reduce((sum, f) => sum + (f.calls?.length || 0), 0);\r\n  }\r\n\r\n  const manifest = {\r\n    version: '2.0.0',\r\n    granularity,\r\n    generated: new Date().toISOString(),\r\n    files,\r\n    globalStats\r\n  };\r\n\r\n  return manifest;\r\n}"
        },
        "saveManifest": {
          "hash": "8611ff4803654892098f8f606ca5b566",
          "line": 273,
          "endLine": 285,
          "size": 637,
          "async": false,
          "language": "javascript",
          "source": "function saveManifest(manifest) {\r\n  const manifestPath = '.llm-context/manifest.json';\r\n  writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));\r\n  console.log(`\\n‚úì Manifest saved to ${manifestPath}`);\r\n\r\n  // Print summary\r\n  console.log('\\n=== Manifest Summary ===');\r\n  console.log(`Files tracked: ${Object.keys(manifest.files).length}`);\r\n  console.log(`Total size: ${(manifest.globalStats.totalSize / 1024).toFixed(1)} KB`);\r\n  console.log(`Functions: ${manifest.globalStats.totalFunctions}`);\r\n  console.log(`Call relationships: ${manifest.globalStats.totalCalls}`);\r\n  console.log(`Generated: ${manifest.generated}`);\r\n}"
        },
        "main": {
          "hash": "02e7cc12be1785212a9c1d8be46c9c23",
          "line": 290,
          "endLine": 293,
          "size": 99,
          "async": true,
          "language": "javascript",
          "source": "async function main() {\r\n  const manifest = await generateManifest();\r\n  saveManifest(manifest);\r\n}"
        }
      }
    },
    "parser-factory.js": {
      "hash": "f5382c0df692e7728f4d59b84546ce75",
      "size": 5590,
      "lastModified": "2026-01-11T05:43:06.525Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {
        "initializeParser": {
          "hash": "2e3b94f04205f8a148193f70b16da0c7",
          "line": 74,
          "endLine": 79,
          "size": 129,
          "async": true,
          "language": "javascript",
          "source": "async function initializeParser() {\r\n  if (!parserInitialized) {\r\n    await Parser.init();\r\n    parserInitialized = true;\r\n  }\r\n}"
        },
        "createParser": {
          "hash": "9a9e676aad1ea1d66755edc8ebba05f9",
          "line": 90,
          "endLine": 142,
          "size": 1572,
          "async": false,
          "language": "javascript",
          "source": "static async createParser(language) {\r\n    if (!language) {\r\n      throw new Error('Language is required');\r\n    }\r\n\r\n    // Return cached parser if available\r\n    if (parserCache.has(language)) {\r\n      return parserCache.get(language);\r\n    }\r\n\r\n    // Initialize Tree-sitter WASM\r\n    await initializeParser();\r\n\r\n    // Get grammar path\r\n    const grammarPath = GRAMMAR_PATHS[language];\r\n    if (!grammarPath) {\r\n      throw new Error(`Unsupported language: ${language}. Use getSupportedLanguages() to see available languages.`);\r\n    }\r\n\r\n    // Create parser instance\r\n    const parser = new Parser();\r\n\r\n    try {\r\n      // Load language grammar (WASM)\r\n      // Construct WASM filename from grammar path\r\n      let wasmFile;\r\n      if (language === 'tsx' || language === 'typescript') {\r\n        // TypeScript has separate tsx and typescript grammars\r\n        wasmFile = `tree-sitter-${language}.wasm`;\r\n      } else {\r\n        // For most languages: tree-sitter-javascript/tree-sitter-javascript.wasm\r\n        const packageName = grammarPath.split('/').pop();\r\n        wasmFile = `${packageName}.wasm`;\r\n      }\r\n\r\n      const wasmPath = join(\r\n        __dirname,\r\n        'node_modules',\r\n        grammarPath,\r\n        wasmFile\r\n      );\r\n\r\n      const languageGrammar = await Parser.Language.load(wasmPath);\r\n      parser.setLanguage(languageGrammar);\r\n\r\n      // Cache parser\r\n      parserCache.set(language, parser);\r\n\r\n      return parser;\r\n    } catch (error) {\r\n      throw new Error(`Failed to load grammar for ${language}: ${error.message}`);\r\n    }\r\n  }"
        },
        "detectLanguage": {
          "hash": "14e0e42db79e2e9ea5df6abb5a4d79b9",
          "line": 149,
          "endLine": 152,
          "size": 128,
          "async": false,
          "language": "javascript",
          "source": "static detectLanguage(filePath) {\r\n    const ext = extname(filePath).toLowerCase();\r\n    return EXTENSION_MAP[ext] || null;\r\n  }"
        },
        "getSupportedLanguages": {
          "hash": "c8785231f66e14090d05c8649c05e73d",
          "line": 158,
          "endLine": 160,
          "size": 77,
          "async": false,
          "language": "javascript",
          "source": "static getSupportedLanguages() {\r\n    return Object.keys(GRAMMAR_PATHS);\r\n  }"
        },
        "isLanguageSupported": {
          "hash": "1d97e2c3be3c8d9f99e5a8ace0a67409",
          "line": 167,
          "endLine": 169,
          "size": 82,
          "async": false,
          "language": "javascript",
          "source": "static isLanguageSupported(language) {\r\n    return language in GRAMMAR_PATHS;\r\n  }"
        },
        "parse": {
          "hash": "8d0a33372c74ecb9942f5083c8449465",
          "line": 177,
          "endLine": 180,
          "size": 140,
          "async": false,
          "language": "javascript",
          "source": "static async parse(sourceCode, language) {\r\n    const parser = await this.createParser(language);\r\n    return parser.parse(sourceCode);\r\n  }"
        },
        "parseFile": {
          "hash": "6ccccffb51d5699e109de50d91d5e309",
          "line": 187,
          "endLine": 197,
          "size": 344,
          "async": false,
          "language": "javascript",
          "source": "static async parseFile(filePath) {\r\n    const language = this.detectLanguage(filePath);\r\n    if (!language) {\r\n      throw new Error(`Cannot detect language for file: ${filePath}`);\r\n    }\r\n\r\n    const sourceCode = readFileSync(filePath, 'utf-8');\r\n    const tree = await this.parse(sourceCode, language);\r\n\r\n    return { tree, language };\r\n  }"
        },
        "clearCache": {
          "hash": "aea5a3a2d531b5aa5878d64bcc005193",
          "line": 202,
          "endLine": 204,
          "size": 52,
          "async": false,
          "language": "javascript",
          "source": "static clearCache() {\r\n    parserCache.clear();\r\n  }"
        }
      }
    },
    "query.js": {
      "hash": "33d36537181105026b872c30b8b79c0c",
      "size": 5288,
      "lastModified": "2026-01-09T05:19:16.930Z",
      "functions": [
        "query",
        "traceCalls"
      ],
      "analysisTime": null,
      "functionHashes": {
        "query": {
          "hash": "775bb0a3ca3b75c793b0ad8a13e13632",
          "line": 52,
          "endLine": 94,
          "size": 1340,
          "async": false,
          "language": "javascript",
          "source": "function query(cmd, arg) {\r\n  switch (cmd) {\r\n    case 'find-function':\r\n      return Array.from(byName.get(arg) || []);\r\n\r\n    case 'functions-in-file':\r\n      return byFile.get(arg) || [];\r\n\r\n    case 'calls-to':\r\n      return Array.from(calledByIndex.get(arg) || []);\r\n\r\n    case 'called-by':\r\n      const func = functions.find(f => (f.name || f.id) === arg);\r\n      return func ? func.calls : [];\r\n\r\n    case 'side-effects':\r\n      return functions.filter(f => f.effects.length > 0);\r\n\r\n    case 'entry-points':\r\n      // Functions called by few others (likely entry points)\r\n      return functions.filter(f => {\r\n        const name = f.name || f.id;\r\n        const callers = calledByIndex.get(name) || new Set();\r\n        return callers.size === 0 || f.name?.includes('main') || f.name?.includes('init');\r\n      });\r\n\r\n    case 'trace':\r\n      // Trace call path from function\r\n      return traceCalls(arg, 3);\r\n\r\n    case 'stats':\r\n      return {\r\n        totalFunctions: functions.length,\r\n        filesAnalyzed: byFile.size,\r\n        totalCalls: functions.reduce((sum, f) => sum + f.calls.length, 0),\r\n        withSideEffects: functions.filter(f => f.effects.length > 0).length,\r\n        effectTypes: [...new Set(functions.flatMap(f => f.effects))]\r\n      };\r\n\r\n    default:\r\n      return { error: 'Unknown query command' };\r\n  }\r\n}"
        },
        "traceCalls": {
          "hash": "10748eb44706011d44bbd825c4f45100",
          "line": 96,
          "endLine": 110,
          "size": 440,
          "async": false,
          "language": "javascript",
          "source": "function traceCalls(funcName, depth = 3, visited = new Set()) {\r\n  if (depth === 0 || visited.has(funcName)) return [];\r\n\r\n  visited.add(funcName);\r\n\r\n  const func = functions.find(f => (f.name || f.id) === funcName);\r\n  if (!func) return [];\r\n\r\n  return {\r\n    function: funcName,\r\n    file: func.file,\r\n    line: func.line,\r\n    calls: func.calls.slice(0, 10).map(called => traceCalls(called, depth - 1, visited)).filter(Boolean)\r\n  };\r\n}"
        }
      }
    },
    "scip-parser.js": {
      "hash": "1d92669c1d83375a50e12ff550d09f9f",
      "size": 6186,
      "lastModified": "2025-11-09T04:20:42.000Z",
      "functions": [
        "parseScip"
      ],
      "analysisTime": null,
      "functionHashes": {
        "parseScip": {
          "hash": "4933995d11aa59e278fc22e8d5a173bd",
          "line": 12,
          "endLine": 196,
          "size": 5917,
          "async": true,
          "language": "javascript",
          "source": "async function parseScip() {\n  try {\n    // Load the protobuf schema\n    const root = await protobuf.load(protoFile);\n    const Index = root.lookupType('scip.Index');\n\n    // Read and decode the SCIP file\n    const buffer = readFileSync(scipFile);\n    const index = Index.decode(buffer);\n\n    const indexObj = Index.toObject(index, {\n      longs: String,\n      enums: String,\n      bytes: String,\n    });\n\n    console.log('=== SCIP Index Summary ===\\n');\n\n    const metadata = indexObj.metadata || {};\n    console.log('Metadata:');\n    console.log('  Tool:', metadata.toolInfo?.name || 'N/A', metadata.toolInfo?.version || '');\n    console.log('  Project Root:', metadata.projectRoot || 'N/A');\n\n    const documents = indexObj.documents || [];\n    console.log('\\nDocuments indexed:', documents.length);\n\n    // Group files by directory\n    const byDir = {};\n    documents.forEach(doc => {\n      const dir = doc.relativePath.split('/').slice(0, -1).join('/') || '.';\n      byDir[dir] = (byDir[dir] || 0) + 1;\n    });\n\n    console.log('\\nFiles by directory:');\n    Object.entries(byDir).slice(0, 10).forEach(([dir, count]) => {\n      console.log(`  ${dir}: ${count} files`);\n    });\n\n    // Analyze first few documents in detail\n    console.log('\\n=== Sample Documents (first 3) ===\\n');\n\n    documents.slice(0, 3).forEach((doc, idx) => {\n      console.log(`\\n[${idx + 1}] ${doc.relativePath}`);\n      console.log(`    Language: ${doc.language || 'unknown'}`);\n\n      const occurrences = doc.occurrences || [];\n      const symbols = doc.symbols || [];\n\n      console.log(`    Occurrences: ${occurrences.length}`);\n      console.log(`    Symbols defined: ${symbols.length}`);\n\n      // Show first few symbols\n      if (symbols.length > 0) {\n        console.log('\\n    Symbol Details:');\n        symbols.slice(0, 5).forEach(sym => {\n          const symStr = sym.symbol || '';\n          const kind = sym.kind || 0;\n          const docs = sym.documentation || [];\n          const sig = sym.signatureDocumentation?.text || '';\n\n          // Parse symbol to get just the name\n          const parts = symStr.split('/');\n          const name = parts[parts.length - 1]?.replace(/[.`]/g, '') || symStr;\n\n          const kindNames = {\n            1: 'Unknown',\n            6: 'Class',\n            8: 'Method',\n            9: 'Function',\n            10: 'Property',\n            12: 'Variable',\n          };\n\n          console.log(`      - ${name}`);\n          console.log(`        Kind: ${kindNames[kind] || kind}`);\n          if (sig) {\n            console.log(`        Sig: ${sig.substring(0, 60)}${sig.length > 60 ? '...' : ''}`);\n          }\n          if (docs.length > 0) {\n            const docText = docs[0];\n            console.log(`        Doc: ${docText.substring(0, 60)}${docText.length > 60 ? '...' : ''}`);\n          }\n        });\n      }\n\n      // Show sample occurrences (function calls/references)\n      if (occurrences.length > 0) {\n        console.log('\\n    Sample Occurrences (first 5):');\n        occurrences.slice(0, 5).forEach(occ => {\n          const range = occ.range || [];\n          const symbol = occ.symbol || '';\n          const roles = occ.symbolRoles || 0;\n\n          // Parse symbol to get readable name\n          const parts = symbol.split('/');\n          const name = parts[parts.length - 1]?.replace(/[.`]/g, '') || symbol;\n\n          const roleNames = {\n            1: 'Definition',\n            2: 'Import',\n            4: 'Reference',\n            8: 'WriteAccess',\n            16: 'ReadAccess',\n          };\n\n          console.log(`      - ${name}`);\n          console.log(`        Line: ${range[0] || 0}, Roles: ${roleNames[roles] || roles}`);\n        });\n      }\n    });\n\n    // Global statistics\n    console.log('\\n\\n=== Global Statistics ===\\n');\n\n    let totalOccurrences = 0;\n    let totalSymbols = 0;\n    let symbolsByKind = {};\n    let functionSymbols = [];\n\n    documents.forEach(doc => {\n      const symbols = doc.symbols || [];\n      const occurrences = doc.occurrences || [];\n\n      totalSymbols += symbols.length;\n      totalOccurrences += occurrences.length;\n\n      symbols.forEach(sym => {\n        const kind = sym.kind || 0;\n        symbolsByKind[kind] = (symbolsByKind[kind] || 0) + 1;\n\n        // Collect function symbols for later analysis\n        if (kind === 9 || kind === 8) { // Function or Method\n          functionSymbols.push({\n            name: sym.symbol,\n            file: doc.relativePath,\n            sig: sym.signatureDocumentation?.text || '',\n            doc: (sym.documentation || [])[0] || ''\n          });\n        }\n      });\n    });\n\n    console.log('Total Symbols:', totalSymbols);\n    console.log('Total Occurrences:', totalOccurrences);\n    console.log('\\nSymbols by Kind:');\n\n    const kindNames = {\n      1: 'Unknown',\n      2: 'Namespace',\n      3: 'Type',\n      6: 'Class',\n      8: 'Method',\n      9: 'Function',\n      10: 'Property',\n      12: 'Variable',\n      13: 'Constant',\n    };\n\n    Object.entries(symbolsByKind)\n      .sort((a, b) => b[1] - a[1])\n      .forEach(([kind, count]) => {\n        console.log(`  ${kindNames[kind] || kind}: ${count}`);\n      });\n\n    console.log('\\nFunctions/Methods found:', functionSymbols.length);\n    console.log('Sample functions:');\n    functionSymbols.slice(0, 10).forEach(fn => {\n      const name = fn.name.split('/').pop().replace(/[.`]/g, '');\n      console.log(`  ${name} (${fn.file})`);\n      if (fn.sig) {\n        console.log(`    Signature: ${fn.sig.substring(0, 70)}`);\n      }\n    });\n\n    // Save full data for transformer\n    console.log('\\n\\n=== Saving parsed data for transformer ===');\n    const fs = await import('fs');\n    fs.writeFileSync('.llm-context/scip-parsed.json', JSON.stringify(indexObj, null, 2));\n    console.log('Saved to .llm-context/scip-parsed.json');\n\n  } catch (error) {\n    console.error('Error parsing SCIP file:', error.message);\n    console.error(error.stack);\n  }\n}"
        }
      }
    },
    "side-effects-analyzer.js": {
      "hash": "d6a231c8d9cac115dc58a819c7cc466a",
      "size": 8996,
      "lastModified": "2026-01-11T04:25:40.974Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {
        "constructor": {
          "hash": "e5ba6c9e63fc2e4caad277fbddf9952f",
          "line": 37,
          "endLine": 41,
          "size": 165,
          "async": false,
          "language": "javascript",
          "source": "constructor(language, imports = []) {\r\n    this.language = language;\r\n    this.imports = new Set(imports);\r\n    this.patterns = EFFECT_PATTERNS[language] || {};\r\n  }"
        },
        "analyze": {
          "hash": "85ff72785034b3d186c2fda6ee5fa61c",
          "line": 49,
          "endLine": 60,
          "size": 332,
          "async": false,
          "language": "javascript",
          "source": "analyze(calls, functionSource = '') {\r\n    const effects = [];\r\n\r\n    // Analyze each call\r\n    for (const call of calls) {\r\n      const callEffects = this.analyzeCall(call, functionSource);\r\n      effects.push(...callEffects);\r\n    }\r\n\r\n    // Deduplicate effects (same type + at)\r\n    return this.deduplicateEffects(effects);\r\n  }"
        },
        "analyzeCall": {
          "hash": "d462dfcfc8f71df2597f48add4557f14",
          "line": 69,
          "endLine": 88,
          "size": 529,
          "async": false,
          "language": "javascript",
          "source": "analyzeCall(call, context = '') {\r\n    const effects = [];\r\n    const effectTypes = ['file_io', 'network', 'logging', 'database', 'dom'];\r\n\r\n    for (const effectType of effectTypes) {\r\n      const patterns = this.patterns[effectType];\r\n      if (!patterns) continue;\r\n\r\n      const confidence = this.detectEffect(call, patterns, context);\r\n      if (confidence) {\r\n        effects.push({\r\n          type: effectType,\r\n          at: call,\r\n          confidence: confidence\r\n        });\r\n      }\r\n    }\r\n\r\n    return effects;\r\n  }"
        },
        "detectEffect": {
          "hash": "218150119d64a87db8b891e0703c9f35",
          "line": 98,
          "endLine": 139,
          "size": 1358,
          "async": false,
          "language": "javascript",
          "source": "detectEffect(call, patterns, context) {\r\n    // High confidence: Direct import match\r\n    if (patterns.imports && this.hasImport(patterns.imports)) {\r\n      if (this.matchesCall(call, patterns.calls)) {\r\n        return 'high';\r\n      }\r\n    }\r\n\r\n    // High confidence: Built-in/global function\r\n    if (patterns.builtins && patterns.builtins.some(b => call.includes(b))) {\r\n      return 'high';\r\n    }\r\n\r\n    if (patterns.globals && patterns.globals.some(g => context.includes(g))) {\r\n      return 'high';\r\n    }\r\n\r\n    // Medium confidence: Direct call match (no import verification)\r\n    if (patterns.calls && this.matchesCall(call, patterns.calls)) {\r\n      return 'medium';\r\n    }\r\n\r\n    // Medium confidence: Namespace match (e.g., fs.readFile, console.log)\r\n    if (patterns.namespaces && patterns.namespaces.some(ns => call.startsWith(ns + '.'))) {\r\n      return 'medium';\r\n    }\r\n\r\n    // Low confidence: Pattern/regex match\r\n    if (patterns.patterns && this.matchesPattern(call, patterns.patterns)) {\r\n      return 'low';\r\n    }\r\n\r\n    // C/C++ includes\r\n    if ((patterns.includes || patterns.requires || patterns.commands)) {\r\n      // These are matched differently, return medium confidence if call matches\r\n      if (patterns.calls && this.matchesCall(call, patterns.calls)) {\r\n        return 'medium';\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }"
        },
        "hasImport": {
          "hash": "c38c15725e3fa9f3ed25a35b11592c2e",
          "line": 147,
          "endLine": 157,
          "size": 330,
          "async": false,
          "language": "javascript",
          "source": "hasImport(requiredImports) {\r\n    for (const required of requiredImports) {\r\n      for (const imported of this.imports) {\r\n        // Exact match or starts with (for sub-modules)\r\n        if (imported === required || imported.startsWith(required + '/')) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }"
        },
        "matchesCall": {
          "hash": "e2afc9dbca7ac707339d6b5602f9b15d",
          "line": 166,
          "endLine": 181,
          "size": 447,
          "async": false,
          "language": "javascript",
          "source": "matchesCall(call, expectedCalls) {\r\n    if (!expectedCalls) return false;\r\n\r\n    for (const expected of expectedCalls) {\r\n      // Exact match\r\n      if (call === expected) return true;\r\n\r\n      // Method call (e.g., fs.readFile matches readFile)\r\n      if (call.includes('.' + expected)) return true;\r\n\r\n      // Partial match (e.g., readFileSync matches readFile)\r\n      if (call.includes(expected)) return true;\r\n    }\r\n\r\n    return false;\r\n  }"
        },
        "matchesPattern": {
          "hash": "a520490642f8de1a47ef223098c1c6ab",
          "line": 190,
          "endLine": 204,
          "size": 366,
          "async": false,
          "language": "javascript",
          "source": "matchesPattern(call, patterns) {\r\n    if (!patterns) return false;\r\n\r\n    for (const pattern of patterns) {\r\n      try {\r\n        const regex = new RegExp(pattern, 'i');\r\n        if (regex.test(call)) return true;\r\n      } catch (error) {\r\n        // Invalid regex, skip\r\n        console.warn(`Invalid pattern: ${pattern}`);\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }"
        },
        "deduplicateEffects": {
          "hash": "c72a51c6f0511078207e057fa11e45ef",
          "line": 212,
          "endLine": 232,
          "size": 566,
          "async": false,
          "language": "javascript",
          "source": "deduplicateEffects(effects) {\r\n    const seen = new Map();\r\n\r\n    for (const effect of effects) {\r\n      const key = `${effect.type}:${effect.at}`;\r\n\r\n      if (!seen.has(key)) {\r\n        seen.set(key, effect);\r\n      } else {\r\n        // Keep higher confidence\r\n        const existing = seen.get(key);\r\n        const confidenceOrder = { high: 3, medium: 2, low: 1 };\r\n\r\n        if (confidenceOrder[effect.confidence] > confidenceOrder[existing.confidence]) {\r\n          seen.set(key, effect);\r\n        }\r\n      }\r\n    }\r\n\r\n    return Array.from(seen.values());\r\n  }"
        },
        "addImport": {
          "hash": "b7cb63457d90f6f48719473de959a85d",
          "line": 238,
          "endLine": 240,
          "size": 63,
          "async": false,
          "language": "javascript",
          "source": "addImport(importPath) {\r\n    this.imports.add(importPath);\r\n  }"
        },
        "getEffectTypes": {
          "hash": "3f7d5acee06af35e001b2eb3ad41b3ed",
          "line": 247,
          "endLine": 249,
          "size": 89,
          "async": false,
          "language": "javascript",
          "source": "static getEffectTypes(effects) {\r\n    return [...new Set(effects.map(e => e.type))];\r\n  }"
        },
        "filterByConfidence": {
          "hash": "2c7242af47307d7d0686fec81acd738d",
          "line": 257,
          "endLine": 262,
          "size": 262,
          "async": false,
          "language": "javascript",
          "source": "static filterByConfidence(effects, minConfidence = 'low') {\r\n    const confidenceOrder = { low: 1, medium: 2, high: 3 };\r\n    const minLevel = confidenceOrder[minConfidence] || 1;\r\n\r\n    return effects.filter(e => confidenceOrder[e.confidence] >= minLevel);\r\n  }"
        },
        "formatForOutput": {
          "hash": "442b0041706a5d8d667633d0565f47e5",
          "line": 269,
          "endLine": 274,
          "size": 117,
          "async": false,
          "language": "javascript",
          "source": "static formatForOutput(effects) {\r\n    return effects.map(e => ({\r\n      type: e.type,\r\n      at: e.at\r\n    }));\r\n  }"
        },
        "createAnalyzer": {
          "hash": "9539ba32dbf7e5a557fd5d2016f2df8c",
          "line": 283,
          "endLine": 285,
          "size": 105,
          "async": false,
          "language": "javascript",
          "source": "function createAnalyzer(language, imports = []) {\r\n  return new SideEffectAnalyzer(language, imports);\r\n}"
        },
        "analyzeSideEffects": {
          "hash": "5b75667729231a586039b40cba873eab",
          "line": 295,
          "endLine": 298,
          "size": 198,
          "async": false,
          "language": "javascript",
          "source": "function analyzeSideEffects(language, calls, imports = [], functionSource = '') {\r\n  const analyzer = new SideEffectAnalyzer(language, imports);\r\n  return analyzer.analyze(calls, functionSource);\r\n}"
        }
      }
    },
    "summarizer.js": {
      "hash": "990665808eb90cda16fab23038eff062",
      "size": 6667,
      "lastModified": "2025-11-09T04:20:42.000Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {}
    },
    "summary-updater.js": {
      "hash": "67b0b3abab7c7fdedce788f013d3e5c8",
      "size": 10683,
      "lastModified": "2026-01-09T05:17:51.983Z",
      "functions": [
        "loadGraph",
        "generateL1",
        "generateL2",
        "updateSummaries",
        "generateL0"
      ],
      "analysisTime": null,
      "functionHashes": {
        "loadGraph": {
          "hash": "bcb51b89991c01b869d2bc94f85bba71",
          "line": 22,
          "endLine": 31,
          "size": 300,
          "async": false,
          "language": "javascript",
          "source": "function loadGraph() {\r\n  const graphPath = '.llm-context/graph.jsonl';\r\n  if (!existsSync(graphPath)) {\r\n    console.log('‚ö† No graph.jsonl found');\r\n    return [];\r\n  }\r\n\r\n  const lines = readFileSync(graphPath, 'utf-8').split('\\n').filter(Boolean);\r\n  return lines.map(line => JSON.parse(line));\r\n}"
        },
        "generateL0": {
          "hash": "8abefb3869d7c7f3bf70027c60535085",
          "line": 36,
          "endLine": 128,
          "size": 3086,
          "async": false,
          "language": "javascript",
          "source": "function generateL0(functions) {\r\n  console.log('[1] Generating L0 (system overview)...');\r\n\r\n  // Group by file\r\n  const byFile = {};\r\n  functions.forEach(func => {\r\n    if (!byFile[func.file]) byFile[func.file] = [];\r\n    byFile[func.file].push(func);\r\n  });\r\n\r\n  // Group by domain (directory)\r\n  const byDomain = {};\r\n  Object.keys(byFile).forEach(file => {\r\n    const dir = dirname(file) || 'root';\r\n    if (!byDomain[dir]) byDomain[dir] = {};\r\n\r\n    const module = file.split('/').pop().replace('.js', '');\r\n    byDomain[dir][module] = byFile[file];\r\n  });\r\n\r\n  const totalFuncs = functions.length;\r\n  const totalCalls = functions.reduce((sum, f) => sum + f.calls.length, 0);\r\n  const effectTypes = new Set();\r\n  functions.forEach(f => f.effects.forEach(e => effectTypes.add(e)));\r\n\r\n  const entryPoints = functions.filter(f =>\r\n    f.name && (\r\n      f.name.includes('main') ||\r\n      f.name.includes('init') ||\r\n      f.name.includes('eval')\r\n    )\r\n  );\r\n\r\n  const L0 = `# LLM Context Tools - System Overview\r\n\r\n**Type**: Code analysis system for LLM-optimized context generation\r\n**Purpose**: Generate compact, semantically-rich code representations for LLM consumption\r\n**Architecture**: JavaScript modules with incremental update support\r\n\r\n## ‚ö° Quick Queries (USE THESE before grep/read)\r\n\r\n**To understand this codebase, try these queries FIRST:**\r\n\r\n\\`\\`\\`bash\r\n# Find any function\r\nllm-context query find-function <name>\r\n\r\n# Understand dependencies\r\nllm-context query calls-to <name>      # Who calls this?\r\nllm-context query trace <name>         # Full call tree\r\n\r\n# Discover patterns\r\nllm-context entry-points               # ${entryPoints.length} entry points\r\nllm-context side-effects               # Functions with I/O\r\n\r\n# Statistics\r\nllm-context stats                      # Full statistics\r\n\\`\\`\\`\r\n\r\n**Why queries > grep:**\r\n- ‚úÖ Show call relationships (grep can't)\r\n- ‚úÖ Detect side effects (grep misses these)\r\n- ‚úÖ Trace call trees (grep shows only text matches)\r\n- ‚úÖ 80-95% fewer tokens needed\r\n\r\n## Statistics\r\n- **Files**: ${Object.keys(byFile).length} modules\r\n- **Functions**: ${totalFuncs} total\r\n- **Call relationships**: ${totalCalls}\r\n- **Side effects**: ${Array.from(effectTypes).join(', ') || 'none'}\r\n\r\n## Key Components\r\n${Object.keys(byDomain).map(domain => {\r\n  const modules = Object.keys(byDomain[domain]);\r\n  return `- **${domain}**: ${modules.join(', ')}`;\r\n}).join('\\n')}\r\n\r\n## Entry Points\r\n${entryPoints.length > 0 ? entryPoints.slice(0, 5).map(f => `- \\`${f.name}\\` (${f.file}:${f.line})`).join('\\n') : '- None detected'}\r\n\r\n## Architecture Pattern\r\n- **Manifest System**: Tracks file hashes for change detection\r\n- **Incremental Analysis**: Re-analyze only changed files\r\n- **Graph Management**: JSONL format for efficient updates\r\n- **Query Interface**: Fast lookups on function call graphs\r\n`;\r\n\r\n  mkdirSync('.llm-context/summaries', { recursive: true });\r\n  writeFileSync('.llm-context/summaries/L0-system.md', L0);\r\n  console.log(`    ‚úì L0-system.md (${L0.length} chars, ~${Math.ceil(L0.length / 4)} tokens)`);\r\n\r\n  return L0;\r\n}"
        },
        "generateL1": {
          "hash": "448d0ebb34e8927dadcbf496d07fee4e",
          "line": 133,
          "endLine": 216,
          "size": 2685,
          "async": false,
          "language": "javascript",
          "source": "function generateL1(functions, changedFiles = null) {\r\n  console.log('[2] Generating L1 (domain summaries)...');\r\n\r\n  // Group by file\r\n  const byFile = {};\r\n  functions.forEach(func => {\r\n    if (!byFile[func.file]) byFile[func.file] = [];\r\n    byFile[func.file].push(func);\r\n  });\r\n\r\n  // Group by domain\r\n  const byDomain = {};\r\n  Object.keys(byFile).forEach(file => {\r\n    const dir = dirname(file) || 'root';\r\n    const module = file.split('/').pop().replace('.js', '');\r\n\r\n    if (!byDomain[dir]) byDomain[dir] = {};\r\n    byDomain[dir][module] = byFile[file];\r\n  });\r\n\r\n  // Load existing L1 if available\r\n  let existingL1 = [];\r\n  if (existsSync('.llm-context/summaries/L1-domains.json')) {\r\n    existingL1 = JSON.parse(readFileSync('.llm-context/summaries/L1-domains.json', 'utf-8'));\r\n  }\r\n\r\n  // Determine which domains were affected\r\n  const affectedDomains = new Set();\r\n  if (changedFiles) {\r\n    changedFiles.forEach(file => {\r\n      const dir = dirname(file) || 'root';\r\n      affectedDomains.add(dir);\r\n    });\r\n  } else {\r\n    // If no changed files specified, regenerate all\r\n    Object.keys(byDomain).forEach(dir => affectedDomains.add(dir));\r\n  }\r\n\r\n  console.log(`    Affected domains: ${Array.from(affectedDomains).join(', ')}`);\r\n\r\n  // Build L1 summaries\r\n  const L1Summaries = [];\r\n\r\n  // Keep existing summaries for unchanged domains\r\n  if (changedFiles) {\r\n    existingL1.forEach(summary => {\r\n      if (!affectedDomains.has(summary.domain)) {\r\n        L1Summaries.push(summary);\r\n        console.log(`    ‚Üª Kept: ${summary.domain} (unchanged)`);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Generate summaries for affected domains\r\n  Object.entries(byDomain).forEach(([domain, modules]) => {\r\n    if (!affectedDomains.has(domain) && changedFiles) return;\r\n\r\n    const domainFuncs = Object.values(modules).flat();\r\n    const funcCount = domainFuncs.length;\r\n    const moduleList = Object.keys(modules);\r\n\r\n    const domainEffects = new Set();\r\n    domainFuncs.forEach(f => f.effects.forEach(e => domainEffects.add(e)));\r\n\r\n    const summary = {\r\n      domain,\r\n      modules: moduleList,\r\n      functionCount: funcCount,\r\n      effects: Array.from(domainEffects),\r\n      keyFunctions: domainFuncs\r\n        .filter(f => f.calls.length > 3 || f.effects.length > 0)\r\n        .slice(0, 5)\r\n        .map(f => ({ name: f.name, file: f.file, line: f.line }))\r\n    };\r\n\r\n    L1Summaries.push(summary);\r\n    console.log(`    ‚úì Updated: ${domain} (${funcCount} functions)`);\r\n  });\r\n\r\n  writeFileSync('.llm-context/summaries/L1-domains.json', JSON.stringify(L1Summaries, null, 2));\r\n  console.log(`    ‚úì L1-domains.json (${L1Summaries.length} domains)`);\r\n\r\n  return L1Summaries;\r\n}"
        },
        "generateL2": {
          "hash": "3cb9d10a3e9e4b2db133037e996c3764",
          "line": 221,
          "endLine": 286,
          "size": 2110,
          "async": false,
          "language": "javascript",
          "source": "function generateL2(functions, changedFiles = null) {\r\n  console.log('[3] Generating L2 (module summaries)...');\r\n\r\n  // Group by file\r\n  const byFile = {};\r\n  functions.forEach(func => {\r\n    if (!byFile[func.file]) byFile[func.file] = [];\r\n    byFile[func.file].push(func);\r\n  });\r\n\r\n  // Load existing L2 if available\r\n  let existingL2 = [];\r\n  if (existsSync('.llm-context/summaries/L2-modules.json')) {\r\n    existingL2 = JSON.parse(readFileSync('.llm-context/summaries/L2-modules.json', 'utf-8'));\r\n  }\r\n\r\n  // Determine which files were affected\r\n  const affectedFiles = changedFiles ? new Set(changedFiles) : new Set(Object.keys(byFile));\r\n\r\n  console.log(`    Affected modules: ${affectedFiles.size}`);\r\n\r\n  const L2Summaries = [];\r\n\r\n  // Keep existing summaries for unchanged files\r\n  if (changedFiles) {\r\n    existingL2.forEach(summary => {\r\n      if (!affectedFiles.has(summary.file)) {\r\n        L2Summaries.push(summary);\r\n        console.log(`    ‚Üª Kept: ${summary.module} (unchanged)`);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Generate summaries for affected files\r\n  Object.entries(byFile).forEach(([file, funcs]) => {\r\n    if (!affectedFiles.has(file) && changedFiles) return;\r\n\r\n    const module = file.split('/').pop().replace('.js', '');\r\n    const exports = funcs.filter(f => f.calls.length > 5);\r\n    const effects = new Set();\r\n    funcs.forEach(f => f.effects.forEach(e => effects.add(e)));\r\n\r\n    const summary = {\r\n      file,\r\n      module,\r\n      functionCount: funcs.length,\r\n      exports: exports.map(f => f.name),\r\n      effects: Array.from(effects),\r\n      entryPoints: funcs\r\n        .filter(f => f.name && (\r\n          f.name.includes('main') ||\r\n          f.name.includes('process') ||\r\n          f.name.includes('init')\r\n        ))\r\n        .map(f => f.name)\r\n    };\r\n\r\n    L2Summaries.push(summary);\r\n    console.log(`    ‚úì Updated: ${module} (${funcs.length} functions)`);\r\n  });\r\n\r\n  writeFileSync('.llm-context/summaries/L2-modules.json', JSON.stringify(L2Summaries, null, 2));\r\n  console.log(`    ‚úì L2-modules.json (${L2Summaries.length} modules)`);\r\n\r\n  return L2Summaries;\r\n}"
        },
        "updateSummaries": {
          "hash": "2eba752cde81b2c5bbc654ddfedfeb05",
          "line": 292,
          "endLine": 325,
          "size": 1184,
          "async": false,
          "language": "javascript",
          "source": "function updateSummaries(changedFiles = null) {\r\n  const functions = loadGraph();\r\n\r\n  if (functions.length === 0) {\r\n    console.log('‚ö† No functions in graph - nothing to summarize');\r\n    return;\r\n  }\r\n\r\n  console.log(`Loaded ${functions.length} functions from graph\\n`);\r\n\r\n  if (changedFiles && changedFiles.length > 0) {\r\n    console.log(`Incremental mode: ${changedFiles.length} files changed`);\r\n    console.log(`Changed files: ${changedFiles.join(', ')}\\n`);\r\n  } else {\r\n    console.log('Full regeneration mode\\n');\r\n  }\r\n\r\n  const L0 = generateL0(functions);\r\n  const L1 = generateL1(functions, changedFiles);\r\n  const L2 = generateL2(functions, changedFiles);\r\n\r\n  console.log('\\n=== Summary Update Complete ===');\r\n  console.log('Generated:');\r\n  console.log('  - L0-system.md');\r\n  console.log('  - L1-domains.json');\r\n  console.log('  - L2-modules.json');\r\n\r\n  if (changedFiles && changedFiles.length > 0) {\r\n    const domainsUpdated = new Set(changedFiles.map(f => dirname(f) || 'root')).size;\r\n    console.log(`\\nEfficiency:`);\r\n    console.log(`  - Domains regenerated: ${domainsUpdated}`);\r\n    console.log(`  - Modules regenerated: ${changedFiles.length}`);\r\n  }\r\n}"
        }
      }
    },
    "test-parser.js": {
      "hash": "18f8e4de6f5ad8a4353cdba36c3a958c",
      "size": 540,
      "lastModified": "2026-01-11T06:04:00.046Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {}
    },
    "transformer.js": {
      "hash": "fd75b4a2567e0044a0f178464d941828",
      "size": 9079,
      "lastModified": "2025-11-09T04:20:42.000Z",
      "functions": [],
      "analysisTime": null,
      "functionHashes": {
        "FunctionDeclaration": {
          "hash": "c15dc80d04ef5ff85927d84990b3819d",
          "line": 78,
          "endLine": 96,
          "size": 620,
          "async": false,
          "language": "javascript",
          "source": "FunctionDeclaration(path) {\n          const funcName = path.node.id?.name || 'anonymous';\n          const funcId = `${sourcePath}#${funcName}`;\n\n          functions.push({\n            id: funcId,\n            name: funcName,\n            type: 'function',\n            file: sourcePath,\n            line: path.node.loc?.start.line || 0,\n            params: path.node.params.map(p => p.name || '?').join(', '),\n            async: path.node.async,\n            exported: false,\n            path: path // Store for second pass\n          });\n\n          callGraph.set(funcId, []);\n          sideEffects.set(funcId, []);\n        }"
        },
        "VariableDeclarator": {
          "hash": "20a21447694f682ddaafe630ade16728",
          "line": 98,
          "endLine": 119,
          "size": 777,
          "async": false,
          "language": "javascript",
          "source": "VariableDeclarator(path) {\n          if (path.node.init?.type === 'ArrowFunctionExpression' ||\n              path.node.init?.type === 'FunctionExpression') {\n            const funcName = path.node.id?.name || 'anonymous';\n            const funcId = `${sourcePath}#${funcName}`;\n\n            functions.push({\n              id: funcId,\n              name: funcName,\n              type: 'function',\n              file: sourcePath,\n              line: path.node.loc?.start.line || 0,\n              params: path.node.init.params.map(p => p.name || '?').join(', '),\n              async: path.node.init.async,\n              exported: false,\n              path: path\n            });\n\n            callGraph.set(funcId, []);\n            sideEffects.set(funcId, []);\n          }\n        }"
        },
        "CallExpression": {
          "hash": "b264c3c1c0d0260316697a68ee4cdf35",
          "line": 129,
          "endLine": 176,
          "size": 1806,
          "async": false,
          "language": "javascript",
          "source": "CallExpression(path) {\n            const callee = path.node.callee;\n            let calledName = '';\n\n            if (callee.type === 'Identifier') {\n              calledName = callee.name;\n            } else if (callee.type === 'MemberExpression') {\n              const obj = callee.object.name || '';\n              const prop = callee.property.name || '';\n              calledName = obj ? `${obj}.${prop}` : prop;\n            }\n\n            if (calledName) {\n              const calls = callGraph.get(funcId) || [];\n              calls.push(calledName);\n              callGraph.set(funcId, calls);\n\n              // Detect side effects\n              const effects = sideEffects.get(funcId) || [];\n\n              // File I/O\n              if (/read|write|append|unlink|mkdir|rmdir|fs\\./i.test(calledName)) {\n                effects.push({ type: 'file_io', at: calledName });\n              }\n\n              // Network\n              if (/fetch|request|axios|http|socket/i.test(calledName)) {\n                effects.push({ type: 'network', at: calledName });\n              }\n\n              // Console/logging\n              if (/console\\.|log\\.|logger\\.|debug|info|warn|error/i.test(calledName)) {\n                effects.push({ type: 'logging', at: calledName });\n              }\n\n              // Database\n              if (/query|execute|find|findOne|save|insert|update|delete|collection|db\\./i.test(calledName)) {\n                effects.push({ type: 'database', at: calledName });\n              }\n\n              // DOM manipulation\n              if (/querySelector|getElementById|createElement|appendChild|innerHTML|textContent/i.test(calledName)) {\n                effects.push({ type: 'dom', at: calledName });\n              }\n\n              sideEffects.set(funcId, effects);\n            }\n          }"
        }
      }
    }
  },
  "globalStats": {
    "totalFunctions": 28,
    "totalCalls": 187,
    "totalFiles": 19,
    "totalSize": 146194
  }
}